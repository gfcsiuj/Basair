<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="description" content="ŸÖÿµÿ≠ŸÅ ÿßŸÑŸáÿßÿØŸä - ÿ™ÿ∑ÿ®ŸäŸÇ ŸÇÿ±ÿ¢ŸÜŸä ŸÖÿ™ŸÉÿßŸÖŸÑ ŸÖÿπ ÿßŸÑÿ™ŸÅÿ≥Ÿäÿ± ŸàÿßŸÑÿ™ÿ±ÿ¨ŸÖÿ© ŸàÿßŸÑÿßÿ≥ÿ™ŸÖÿßÿπ ŸÑŸÑŸÇÿ±ÿßÿ° ÿßŸÑŸÖÿÆÿ™ŸÑŸÅŸäŸÜ">
    <meta name="keywords" content="ŸÇÿ±ÿ¢ŸÜ, ŸÖÿµÿ≠ŸÅ, ÿ™ŸÅÿ≥Ÿäÿ±, ÿ™ÿ±ÿ¨ŸÖÿ©, ÿ™ŸÑÿßŸàÿ©, ÿ•ÿ≥ŸÑÿßŸÖ, ŸÇÿ±ÿ¢ŸÜ ŸÉÿ±ŸäŸÖ, ŸÖÿµÿ≠ŸÅ ÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä">
    <meta name="author" content="ŸÖÿµÿ≠ŸÅ ÿßŸÑŸáÿßÿØŸä">
    <meta name="theme-color" content="#059669">
    
    <!-- PWA Meta Tags -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="ŸÖÿµÿ≠ŸÅ ÿßŸÑŸáÿßÿØŸä">
    <meta name="application-name" content="ŸÖÿµÿ≠ŸÅ ÿßŸÑŸáÿßÿØŸä">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="./manifest.json">
    
    <title>ŸÖÿµÿ≠ŸÅ ÿßŸÑŸáÿßÿØŸä - ÿßŸÑŸÇÿ±ÿ¢ŸÜ ÿßŸÑŸÉÿ±ŸäŸÖ</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='grad' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%23059669;stop-opacity:1' /%3E%3Cstop offset='100%25' style='stop-color:%2310b981;stop-opacity:1' /%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='100' height='100' fill='url(%23grad)' rx='20'/%3E%3Ctext x='50' y='50' text-anchor='middle' dy='.3em' fill='white' font-size='45' font-family='Arial' font-weight='bold'%3E%D9%85%3C/text%3E%3C/svg%3E">
    
    <!-- Google Fonts - ÿßŸÑŸÖÿ≤ŸäÿØ ŸÖŸÜ ÿßŸÑÿÆÿ∑Ÿàÿ∑ -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Amiri+Quran&family=Rubik:wght@300;400;500;600;700;800&family=Scheherazade+New:wght@400;700&family=Noto+Naskh+Arabic:wght@400;500;600;700&family=Lateef:wght@400;700&family=Kitab:wght@400;700&family=Almarai:wght@300;400;700;800&family=Cairo:wght@200;300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Tailwind CSS - Production Build -->
    <script src="https://cdn.tailwindcss.com?plugins=forms,typography,aspect-ratio,container-queries"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        'arabic': ['Amiri Quran', 'serif'],
                        'ui': ['Rubik', 'sans-serif']
                    }
                }
            }
        }
    </script>
    
    <!-- Hammer.js for better gestures -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
    
    <!-- Html2Canvas -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <!-- Chart.js for analytics -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <style>
        /* CSS Variables */
        :root {
            --primary: #059669;
            --primary-light: #10b981;
            --primary-dark: #047857;
            --secondary: #fbbf24;
            --bg-primary: #ffffff;
            --bg-secondary: #f9fafb;
            --bg-tertiary: #f3f4f6;
            --text-primary: #111827;
            --text-secondary: #6b7280;
            --text-tertiary: #9ca3af;
            --border: #e5e7eb;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
            --radius-sm: 0.375rem;
            --radius: 0.5rem;
            --radius-md: 0.75rem;
            --radius-lg: 1rem;
            --radius-xl: 1.5rem;
            --font-arabic: 'Amiri Quran', serif;
            --font-ui: 'Rubik', sans-serif;
            --font-indopak: 'Scheherazade New', serif;
            --font-noto: 'Noto Naskh Arabic', serif;
            --font-lateef: 'Lateef', serif;
            --font-kitab: 'Kitab', serif;
            --font-almarai: 'Almarai', sans-serif;
            --font-cairo: 'Cairo', sans-serif;
        }
        
        /* Dark Theme */
        [data-theme="dark"] {
            --primary: #10b981;
            --primary-light: #34d399;
            --primary-dark: #059669;
            --bg-primary: #111827;
            --bg-secondary: #1f2937;
            --bg-tertiary: #374151;
            --text-primary: #f9fafb;
            --text-secondary: #d1d5db;
            --text-tertiary: #9ca3af;
            --border: #374151;
        }
        
        /* Sepia Theme */
        [data-theme="sepia"] {
            --primary: #92400e;
            --primary-light: #b45309;
            --primary-dark: #78350f;
            --bg-primary: #fef3c7;
            --bg-secondary: #fde68a;
            --bg-tertiary: #fcd34d;
            --text-primary: #451a03;
            --text-secondary: #78350f;
            --text-tertiary: #92400e;
            --border: #fbbf24;
        }
        
        /* Blue Theme */
        [data-theme="blue"] {
            --primary: #0369a1;
            --primary-light: #0284c7;
            --primary-dark: #075985;
            --bg-primary: #f0f9ff;
            --bg-secondary: #e0f2fe;
            --bg-tertiary: #bae6fd;
            --text-primary: #082f49;
            --text-secondary: #075985;
            --text-tertiary: #0c4a6e;
            --border: #7dd3fc;
        }
        
        /* Global Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        html {
            scroll-behavior: smooth;
        }
        
        body {
            font-family: var(--font-ui);
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            direction: rtl;
            text-align: right;
            height: 100vh;
            width: 100vw;
            position: fixed;
            overscroll-behavior: none;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        /* Custom Scrollbar */
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        
        .custom-scrollbar::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 10px;
            opacity: 0.5;
        }
        
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            opacity: 1;
        }
        
        /* Font Classes */
        .font-arabic {
            font-family: var(--font-arabic);
            line-height: 2.5;
        }
        
        .font-indopak {
            font-family: var(--font-indopak);
            line-height: 2.5;
        }
        
        .font-noto {
            font-family: var(--font-noto);
            line-height: 2.3;
        }
        
        .font-lateef {
            font-family: var(--font-lateef);
            line-height: 2.4;
        }
        
        .font-kitab {
            font-family: var(--font-kitab);
            line-height: 2.5;
        }
        
        .font-almarai {
            font-family: var(--font-almarai);
            line-height: 2.2;
        }
        
        .font-cairo {
            font-family: var(--font-cairo);
            line-height: 2.2;
        }
        
        /* Add these CSS animations after the existing keyframes for enhanced memorization experience */

        @keyframes fadeIn {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }
        
        @keyframes scaleIn {
            0% { transform: scale(0.8) translateY(20px); opacity: 0; }
            100% { transform: scale(1) translateY(0); opacity: 1; }
        }
        
        @keyframes slideIn {
            0% { transform: translateX(-100%); opacity: 0; }
            100% { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes shimmer {
            0% { background-position: -200px 0; }
            100% { background-position: calc(200px + 100%) 0; }
        }
        
        .animate-fadeIn {
            animation: fadeIn 0.3s ease-out;
        }
        
        .animate-scaleIn {
            animation: scaleIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        .animate-slideIn {
            animation: slideIn 0.5s ease-out;
        }
        
        .animate-shimmer {
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            background-size: 200px 100%;
            animation: shimmer 2s infinite;
        }
        
        /* Enhanced speech feedback panel with purple theme */
        #speech-feedback {
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            background: linear-gradient(135deg, rgba(139, 69, 189, 0.15), rgba(168, 85, 247, 0.2));
            border: 2px solid rgba(139, 69, 189, 0.3);
            border-radius: 12px;
            padding: 12px 16px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 25px rgba(139, 69, 189, 0.2);
        }
        
        .speech-feedback-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(139, 69, 189, 0.2);
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(139, 69, 189, 0.3);
            transition: all 0.3s ease;
        }
        
        .speech-feedback-panel:hover {
            box-shadow: 0 15px 40px rgba(139, 69, 189, 0.4);
            transform: translateY(-2px);
        }
        
        /* Error item styling with improved purple theme */
        .error-item {
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            border-left: 5px solid #ef4444;
            background: linear-gradient(135deg, rgba(254, 242, 242, 0.9), rgba(254, 226, 226, 0.8));
            backdrop-filter: blur(5px);
            border-radius: 12px;
            margin: 8px 0;
            overflow: hidden;
            position: relative;
        }
        
        .error-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(239, 68, 68, 0.5), transparent);
            animation: shimmerError 2s infinite;
        }
        
        .error-item:hover {
            transform: translateX(-6px) scale(1.02);
            box-shadow: 0 8px 25px rgba(239, 68, 68, 0.3);
            border-left-width: 6px;
        }
        
        @keyframes shimmerError {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes slideDown {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .animate-fadeIn { animation: fadeIn 0.3s ease-out; }
        .animate-slideUp { animation: slideUp 0.3s ease-out; }
        .animate-slideDown { animation: slideDown 0.3s ease-out; }
        .animate-pulse { animation: pulse 2s infinite; }
        .animate-spin { animation: spin 1s linear infinite; }
        
        /* Page Content */
        .page-content {
            padding: 1rem;
            max-width: 800px;
            margin: 0 auto;
            min-height: calc(100vh - 140px);
        }
        
        /* Desktop Styles - ŸÖÿ≠ÿ≥ŸÜÿ© ŸÑŸÑŸÉŸÖÿ®ŸäŸàÿ™ÿ± */
        @media (min-width: 1024px) {
            body {
                position: relative;
                overflow-y: auto;
            }
            
            .page-content {
                max-width: 1000px;
                padding: 2rem;
            }
            
            #page-content {
                font-size: 1.5rem !important;
            }
            
            .ai-window {
                max-width: 500px;
                height: 600px;
                bottom: 100px;
                left: 40px;
            }
            
            .ai-fab {
                bottom: 30px;
                left: 40px;
                width: 64px;
                height: 64px;
            }
            
            /* ÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑÿ™ŸÜŸÇŸÑ ŸÑŸÑŸÉŸÖÿ®ŸäŸàÿ™ÿ± */
            #main-content {
                padding-bottom: 2rem;
            }
            
            .bottom-nav {
                position: sticky;
                bottom: 0;
            }
            
            /* ÿ£ÿ≤ÿ±ÿßÿ± ÿßŸÑÿ™ŸÜŸÇŸÑ ÿ®ŸäŸÜ ÿßŸÑÿµŸÅÿ≠ÿßÿ™ ŸÑŸÑŸÉŸÖÿ®ŸäŸàÿ™ÿ± */
            .desktop-navigation {
                position: fixed;
                top: 50%;
                transform: translateY(-50%);
                z-index: 30;
            }
            
            .desktop-navigation.prev {
                right: 20px;
            }
            
            .desktop-navigation.next {
                left: 20px;
            }
            
            .desktop-navigation button {
                width: 50px;
                height: 50px;
                border-radius: 50%;
                background: var(--primary);
                color: white;
                border: none;
                cursor: pointer;
                transition: all 0.3s;
                box-shadow: var(--shadow-lg);
            }
            
            .desktop-navigation button:hover {
                transform: scale(1.1);
                background: var(--primary-dark);
            }
        }

        /* Mobile AI Full Screen */
        @media (max-width: 768px) {
            .ai-window.active {
                position: fixed;
                inset: 0;
                max-width: 100%;
                width: 100%;
                height: 100%;
                bottom: 0;
                left: 0;
                right: 0;
                border-radius: 0;
                z-index: 100;
            }
        }
        
        /* Surah Header */
        .surah-header {
            background: linear-gradient(135deg, var(--primary), var(--primary-light));
            color: white;
            padding: 1.5rem;
            border-radius: var(--radius-lg);
            margin-bottom: 1.5rem;
            text-align: center;
            box-shadow: var(--shadow-md);
        }
        
        .surah-header h2 {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
            font-family: var(--font-arabic);
        }
        
        .surah-header .basmala {
            font-size: 1.2rem;
            font-family: var(--font-arabic);
            opacity: 0.95;
        }
        
        .ayah {
            display: inline;
            cursor: pointer;
            padding: 0 4px;
            transition: all 0.2s;
            position: relative;
        }
        
        .ayah:hover {
            background: linear-gradient(135deg, rgba(5, 150, 105, 0.1), rgba(16, 185, 129, 0.1));
            border-radius: var(--radius-sm);
        }
        
        .ayah.playing {
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.2), rgba(245, 158, 11, 0.2));
            border-radius: var(--radius-sm);
            animation: pulse 2s infinite;
        }
        
        .ayah.bookmarked::before {
            content: 'üîñ';
            position: absolute;
            top: -10px;
            right: -10px;
            font-size: 12px;
        }
        
        /* Ÿàÿ∂ÿπ ÿßŸÑÿ™ÿ≠ŸÅŸäÿ∏ ÿßŸÑŸÖÿ≠ÿ≥ŸÜ - ŸÖÿÆŸÅŸä ÿ®ÿßŸÑŸÉÿßŸÖŸÑ ŸÖÿπ ÿ™ÿØÿ±ÿ¨ ÿ£ÿ±ÿ¨ŸàÿßŸÜŸä */
        .memorization-mode .ayah-word {
            display: inline-block;
            margin: 0 3px;
            padding: 6px 10px;
            border-radius: 8px;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            min-height: 2.2em;
            position: relative;
            font-weight: 500;
            cursor: default;
            /* Hide all words initially */
            color: transparent;
            background: transparent;
            border: 1px dashed rgba(139, 69, 189, 0.3);
        }
        
        /* Show verse numbers always */
        .memorization-mode .verse-number {
            display: inline-flex !important;
            color: white !important;
            background: linear-gradient(135deg, var(--primary), var(--primary-light)) !important;
        }
        
        /* Hide AI chat in memorization mode */
        .memorization-mode .ai-fab,
        .memorization-mode .ai-window,
        #memorization-interface .ai-fab,
        #memorization-interface .ai-window {
            display: none !important;
        }
        
        .memorization-mode .ayah-word.hidden {
            /* Words are completely hidden until spoken correctly */
            visibility: hidden;
            color: transparent;
            background: transparent;
            user-select: none;
            cursor: default;
            border: none;
        }
        
        .memorization-mode .ayah-word.waiting {
            /* Current word waiting to be spoken - minimal animation for indication */
            visibility: visible;
            background: linear-gradient(135deg, rgba(139, 69, 189, 0.3), rgba(168, 85, 247, 0.4));
            color: transparent;
            border: 2px solid rgba(139, 69, 189, 0.7);
            position: relative;
            animation: pulseWaitingMinimal 3s infinite;
            box-shadow: 0 0 10px rgba(139, 69, 189, 0.3);
        }
        
        .memorization-mode .ayah-word.waiting::after {
            content: 'üé§';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.4em;
            animation: pulseIcon 1.8s infinite;
            filter: drop-shadow(0 2px 4px rgba(139, 69, 189, 0.5));
        }
        
        .memorization-mode .ayah-word.revealed {
            /* Words become visible when spoken correctly - no animations out of respect */
            visibility: visible;
            background: linear-gradient(135deg, rgba(139, 69, 189, 0.4), rgba(168, 85, 247, 0.5));
            color: var(--text-primary);
            border: 2px solid rgba(139, 69, 189, 0.8);
            box-shadow: 0 4px 15px rgba(139, 69, 189, 0.4);
            opacity: 1;
            transform: scale(1);
        }
        
        .memorization-mode .ayah-word.correct {
            /* Word spoken correctly - no animations out of respect */
            visibility: visible;
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.5), rgba(21, 128, 61, 0.6));
            color: var(--text-primary);
            border: 2px solid rgba(34, 197, 94, 0.8);
            box-shadow: 0 6px 20px rgba(34, 197, 94, 0.5);
        }
        
        .memorization-mode .ayah-word.incorrect {
            /* Incorrect word - simple styling without animations */
            visibility: visible;
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.5), rgba(220, 38, 38, 0.6));
            color: var(--text-primary);
            border: 2px solid rgba(239, 68, 68, 0.9);
            box-shadow: 0 6px 20px rgba(239, 68, 68, 0.5);
        }
        
        @keyframes pulseWaitingMinimal {
            0% { 
                transform: scale(1); 
                opacity: 0.8;
            }
            50% { 
                transform: scale(1.02); 
                opacity: 1;
            }
            100% { 
                transform: scale(1); 
                opacity: 0.8;
            }
        }
        
        @keyframes pulseWaiting {
            0% { 
                transform: scale(1); 
                box-shadow: 0 0 0 0 rgba(139, 69, 189, 0.8), 0 0 10px rgba(139, 69, 189, 0.3); 
            }
            50% { 
                transform: scale(1.03); 
                box-shadow: 0 0 0 6px rgba(139, 69, 189, 0.2), 0 0 15px rgba(139, 69, 189, 0.4); 
            }
            100% { 
                transform: scale(1); 
                box-shadow: 0 0 0 12px rgba(139, 69, 189, 0), 0 0 10px rgba(139, 69, 189, 0.3); 
            }
        }
        
        @keyframes pulseIcon {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.8; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        @keyframes revealWord {
            0% { 
                background: linear-gradient(135deg, rgba(139, 69, 189, 0.8), rgba(168, 85, 247, 0.9)); 
                transform: scale(0.8) rotateY(90deg); 
                opacity: 0;
                filter: blur(3px);
            }
            30% {
                transform: scale(1.1) rotateY(45deg);
                opacity: 0.6;
                filter: blur(1px);
            }
            70% {
                transform: scale(1.05) rotateY(10deg);
                opacity: 0.9;
                filter: blur(0px);
            }
            100% { 
                background: linear-gradient(135deg, rgba(139, 69, 189, 0.4), rgba(168, 85, 247, 0.5)); 
                transform: scale(1) rotateY(0deg); 
                opacity: 1;
                filter: blur(0px);
            }
        }
        
        @keyframes correctWord {
            0% { 
                background: linear-gradient(135deg, rgba(34, 197, 94, 0.9), rgba(21, 128, 61, 1)); 
                transform: scale(1.5) rotateZ(8deg); 
                box-shadow: 0 10px 30px rgba(34, 197, 94, 0.7);
                filter: brightness(1.3);
            }
            20% {
                transform: scale(1.3) rotateZ(-4deg);
                filter: brightness(1.2);
            }
            40% {
                transform: scale(1.15) rotateZ(2deg);
                filter: brightness(1.1);
            }
            70% {
                transform: scale(1.05) rotateZ(-1deg);
                filter: brightness(1.05);
            }
            100% { 
                background: linear-gradient(135deg, rgba(34, 197, 94, 0.5), rgba(21, 128, 61, 0.6)); 
                transform: scale(1) rotateZ(0deg); 
                box-shadow: 0 6px 20px rgba(34, 197, 94, 0.5);
                filter: brightness(1);
            }
        }
        
        @keyframes incorrectWord {
            0% { 
                background: linear-gradient(135deg, rgba(239, 68, 68, 0.9), rgba(220, 38, 38, 1)); 
                transform: translateX(-10px) scale(1.3); 
                box-shadow: 0 10px 30px rgba(239, 68, 68, 0.7);
                filter: brightness(1.2) contrast(1.1);
            }
            10% { transform: translateX(10px) scale(1.2); }
            20% { transform: translateX(-8px) scale(1.15); }
            30% { transform: translateX(8px) scale(1.1); }
            40% { transform: translateX(-6px) scale(1.08); }
            50% { transform: translateX(6px) scale(1.05); }
            60% { transform: translateX(-4px) scale(1.03); }
            70% { transform: translateX(4px) scale(1.02); }
            80% { transform: translateX(-2px) scale(1.01); }
            90% { transform: translateX(2px) scale(1); }
            100% { 
                background: linear-gradient(135deg, rgba(239, 68, 68, 0.5), rgba(220, 38, 38, 0.6)); 
                transform: translateX(0) scale(1); 
                box-shadow: 0 6px 20px rgba(239, 68, 68, 0.5);
                filter: brightness(1) contrast(1);
            }
        }
        
        .memorization-controls {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-primary);
            padding: 1rem;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-xl);
            z-index: 40;
            display: none;
        }
        
        .memorization-mode .memorization-controls {
            display: block;
        }
        
        .recording-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: rgba(239, 68, 68, 0.1);
            border-radius: var(--radius-md);
            color: #ef4444;
        }
        
        .recording-indicator.active {
            animation: pulse 1.5s infinite;
        }
        
        .verse-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 1.75rem;
            height: 1.75rem;
            background: linear-gradient(135deg, var(--primary), var(--primary-light));
            color: white;
            border-radius: 50%;
            font-size: 0.7rem;
            font-weight: 600;
            margin: 0 0.25rem;
            vertical-align: middle;
            box-shadow: var(--shadow-sm);
        }
        
        /* Bottom Navigation */
        .bottom-nav {
            background: var(--bg-primary);
            border-top: 1px solid var(--border);
            box-shadow: 0 -4px 6px -1px rgb(0 0 0 / 0.1);
        }
        
        .nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
            color: var(--text-secondary);
            transition: all 0.2s;
            position: relative;
        }
        
        .nav-item.active {
            color: var(--primary);
        }
        
        .nav-item.active::before {
            content: '';
            position: absolute;
            top: 0;
            left: 20%;
            right: 20%;
            height: 2px;
            background: var(--primary);
            border-radius: 0 0 4px 4px;
        }
        
        .nav-item:active {
            transform: scale(0.95);
        }
        
        /* Panels */
        .panel {
            position: fixed;
            inset: 0;
            z-index: 50;
            background: var(--bg-primary);
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .panel.visible {
            transform: translateY(0);
        }
        
        .panel-header {
            background: linear-gradient(135deg, var(--primary), var(--primary-light));
            color: white;
            padding: 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: var(--shadow-md);
        }
        
        /* Menu Panel */
        #menu-panel {
            background: var(--bg-primary);
        }
        
        .menu-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .menu-item:hover {
            background: var(--bg-secondary);
        }
        
        .menu-item i {
            width: 24px;
            text-align: center;
            color: var(--primary);
        }
        
        /* AI Chat */
        .ai-fab {
            position: fixed;
            bottom: 80px;
            left: 20px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary), var(--primary-light));
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-lg);
            cursor: pointer;
            transition: all 0.3s;
            z-index: 40;
        }
        
        .ai-fab:hover {
            transform: scale(1.1);
            box-shadow: var(--shadow-xl);
        }
        
        .ai-fab:active {
            transform: scale(0.95);
        }
        
        .ai-window {
            position: fixed;
            bottom: 150px;
            left: 20px;
            right: 20px;
            max-width: 400px;
            height: 500px;
            background: var(--bg-primary);
            border-radius: var(--radius-xl);
            box-shadow: var(--shadow-xl);
            display: none;
            flex-direction: column;
            z-index: 45;
            overflow: hidden;
            border: 1px solid var(--border);
        }
        
        @media (min-width: 768px) {
            .ai-window {
                right: auto;
                width: 400px;
            }
        }
        
        .ai-window.active {
            display: flex;
            animation: slideUp 0.3s ease-out;
        }
        
        /* Button Styles */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.625rem 1.25rem;
            border-radius: var(--radius-md);
            font-weight: 500;
            transition: all 0.2s;
            cursor: pointer;
            border: none;
            outline: none;
            gap: 0.5rem;
        }
        
        .btn:active {
            transform: scale(0.98);
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--primary), var(--primary-light));
            color: white;
        }
        
        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        /* Loading */
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top: 3px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        /* Context Menu */
        .context-menu {
            background: var(--bg-primary);
            border-radius: var(--radius-xl) var(--radius-xl) 0 0;
            box-shadow: 0 -10px 25px -5px rgb(0 0 0 / 0.1);
            border: 1px solid var(--border);
            border-bottom: none;
        }
        
        /* Cards */
        .card {
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
            padding: 1rem;
            box-shadow: var(--shadow);
            transition: all 0.3s;
        }
        
        .card:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }
        
        /* Input */
        .input {
            width: 100%;
            padding: 0.75rem 1rem;
            border-radius: var(--radius-md);
            border: 1px solid var(--border);
            background: var(--bg-secondary);
            color: var(--text-primary);
            transition: all 0.2s;
            outline: none;
        }
        
        .input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(5, 150, 105, 0.1);
        }
        
        /* Select */
        .select {
            appearance: none;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: left 0.5rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            padding-left: 2.5rem;
        }
        
        /* Checkbox */
        .checkbox {
            width: 1.25rem;
            height: 1.25rem;
            border-radius: var(--radius-sm);
            border: 2px solid var(--border);
            appearance: none;
            transition: all 0.2s;
            position: relative;
        }
        
        .checkbox:checked {
            background: var(--primary);
            border-color: var(--primary);
        }
        
        .checkbox:checked::after {
            content: '‚úì';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 0.75rem;
        }
        
        /* Swipe Indicators */
        .swipe-hint {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            width: 40px;
            height: 40px;
            background: var(--primary);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 30;
        }
        
        .swipe-hint.show {
            opacity: 0.8;
        }
        
        .swipe-hint.left {
            left: 10px;
        }
        
        .swipe-hint.right {
            right: 10px;
        }
        
        /* Progress Ring */
        .progress-ring {
            transform: rotate(-90deg);
        }
        
        .progress-ring-circle {
            stroke: var(--primary);
            stroke-width: 4;
            fill: none;
            stroke-dasharray: 440;
            stroke-dashoffset: 440;
            transition: stroke-dashoffset 0.5s ease;
        }
        
        /* Stats Card */
        .stats-card {
            background: linear-gradient(135deg, var(--primary), var(--primary-light));
            color: white;
            border-radius: var(--radius-lg);
            padding: 1.5rem;
            box-shadow: var(--shadow-md);
        }
        
        /* Achievement Badge */
        .achievement-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            background: var(--bg-tertiary);
            padding: 0.5rem 1rem;
            border-radius: var(--radius-xl);
            font-size: 0.875rem;
            box-shadow: var(--shadow);
        }
        
        .achievement-badge.unlocked {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: white;
        }
        
        /* Skeleton Loading */
        .skeleton {
            background: linear-gradient(90deg, var(--bg-secondary) 25%, var(--bg-tertiary) 50%, var(--bg-secondary) 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
        }
        
        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        
        .skeleton-line {
            height: 20px;
            margin-bottom: 10px;
            border-radius: var(--radius-sm);
        }
        
        .skeleton-line.short {
            width: 60%;
        }
        
        /* Share Image Preview */
        #share-image-preview {
            background: var(--bg-primary);
            padding: 3rem;
            border-radius: var(--radius-lg);
            text-align: center;
            min-height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            position: relative;
        }

        #share-image-preview .watermark {
            position: absolute;
            bottom: 20px;
            right: 20px;
            opacity: 0.5;
            font-size: 0.75rem;
        }
        
        /* Swipe Hints */
        .swipe-hint {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 1rem;
            border-radius: var(--radius-lg);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 30;
            pointer-events: none;
        }
        
        .swipe-hint.left {
            left: 20px;
        }
        
        .swipe-hint.right {
            right: 20px;
        }
        
        .swipe-hint.show {
            opacity: 1;
        }
        
        /* Khatmah Card */
        .khatmah-card {
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            padding: 1.5rem;
            margin-bottom: 1rem;
            box-shadow: var(--shadow);
            transition: all 0.3s;
        }
        
        .khatmah-card:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }
        
        .khatmah-status {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: var(--radius-xl);
            font-size: 0.75rem;
            font-weight: 500;
        }
        
        .khatmah-status.active {
            background: rgba(16, 185, 129, 0.1);
            color: var(--primary);
        }
        
        .khatmah-status.completed {
            background: rgba(251, 191, 36, 0.1);
            color: #f59e0b;
        }
        
        /* Modal */
        .modal {
            position: fixed;
            inset: 0;
            z-index: 100;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            padding: 1rem;
        }
        
        .modal.active {
            display: flex;
            animation: fadeIn 0.2s ease-out;
        }
        
        .modal-content {
            background: var(--bg-primary);
            border-radius: var(--radius-xl);
            max-width: 500px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: var(--shadow-xl);
            animation: slideUp 0.3s ease-out;
        }
        
        /* Chart Container */
        .chart-container {
            position: relative;
            height: 300px;
            margin: 1rem 0;
        }
    </style>
</head>
<body data-theme="light">
    
    <!-- Main App Container -->
    <div class="flex flex-col h-screen w-screen">
        
        <!-- Main Reading Interface -->
        <div id="main-reading-interface">
            <!-- Top Header -->
            <header class="bg-gradient-to-l from-emerald-600 to-emerald-700 text-white shadow-md z-40">
                <div class="flex items-center justify-between px-4 py-3">
                    <div class="flex items-center gap-3">
                        <button id="menu-btn" class="p-2 rounded-lg hover:bg-white/10 transition-colors">
                            <i class="fas fa-bars text-lg"></i>
                        </button>
                        <div>
                            <h1 class="text-sm font-bold" id="page-surah-name">ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ...</h1>
                            <p class="text-xs opacity-90" id="page-info">
                                <span id="page-juz"></span> ‚Ä¢ <span id="page-number"></span>
                            </p>
                        </div>
                    </div>
                    
                    <div class="flex items-center gap-2">
                        <!-- Audio Controls -->
                        <button id="audio-prev-btn" class="p-2 rounded-lg hover:bg-white/10 transition-colors">
                            <i class="fas fa-backward text-sm"></i>
                        </button>
                        <button id="audio-play-btn" class="p-2 rounded-lg hover:bg-white/10 transition-colors">
                            <i id="play-icon" class="fas fa-play text-lg"></i>
                            <i id="pause-icon" class="fas fa-pause text-lg hidden"></i>
                        </button>
                        <button id="audio-next-btn" class="p-2 rounded-lg hover:bg-white/10 transition-colors">
                            <i class="fas fa-forward text-sm"></i>
                        </button>
                        
                        <!-- Progress Bar -->
                        <div id="audio-progress-bar" class="w-24 h-1 bg-white/30 rounded-full cursor-pointer hidden sm:block">
                            <div id="audio-progress" class="h-full bg-white rounded-full transition-all" style="width: 0%"></div>
                        </div>
                        
                        <!-- Search -->
                        <button id="search-btn" class="p-2 rounded-lg hover:bg-white/10 transition-colors">
                            <i class="fas fa-search text-lg"></i>
                        </button>
                    </div>
                </div>
            </header>
            
            <!-- Main Content Area -->
            <main id="main-content" class="flex-1 overflow-y-auto custom-scrollbar relative">
                <!-- Page Content -->
                <div id="page-wrapper" class="page-content">
                    <!-- Loading skeleton -->
                    <div id="skeleton-loading" class="hidden p-4">
                        <div class="skeleton skeleton-line"></div>
                        <div class="skeleton skeleton-line"></div>
                        <div class="skeleton skeleton-line short"></div>
                        <div class="skeleton skeleton-line"></div>
                        <div class="skeleton skeleton-line short"></div>
                    </div>
                    
                    <!-- Verses content -->
                    <div id="page-content" class="font-arabic text-xl leading-loose"></div>
                    
                    <!-- Swipe hints -->
                    <div class="swipe-hint left">
                        <i class="fas fa-arrow-left"></i>
                        <span>ÿßÿ≥ÿ≠ÿ® ŸÑŸÑÿµŸÅÿ≠ÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ©</span>
                    </div>
                    <div class="swipe-hint right">
                        <i class="fas fa-arrow-right"></i>
                        <span>ÿßÿ≥ÿ≠ÿ® ŸÑŸÑÿµŸÅÿ≠ÿ© ÿßŸÑÿ≥ÿßÿ®ŸÇÿ©</span>
                    </div>
                </div>
            </main>
            
            <!-- Bottom Navigation -->
            <nav class="bottom-nav">
                <div class="grid grid-cols-5 max-w-lg mx-auto">
                    <button class="nav-item active" data-panel="home">
                        <i class="fas fa-book-quran text-xl mb-1"></i>
                        <span class="text-xs">ÿßŸÑŸÖÿµÿ≠ŸÅ</span>
                    </button>
                    <button class="nav-item" onclick="App.startMemorizationMode('page')">
                        <i class="fas fa-brain text-xl mb-1"></i>
                        <span class="text-xs">ÿßŸÑÿ≠ŸÅÿ∏</span>
                    </button>
                    <button class="nav-item" data-panel="index-panel">
                        <i class="fas fa-list text-xl mb-1"></i>
                        <span class="text-xs">ÿßŸÑŸÅŸáÿ±ÿ≥</span>
                    </button>
                    <button class="nav-item" data-panel="bookmarks-panel">
                        <i class="fas fa-bookmark text-xl mb-1"></i>
                        <span class="text-xs">ÿßŸÑŸÖŸÅÿ∂ŸÑÿ©</span>
                    </button>
                    <button class="nav-item" data-panel="khatmah-panel">
                        <i class="fas fa-chart-line text-xl mb-1"></i>
                        <span class="text-xs">ÿßŸÑÿÆÿ™ŸÖÿ©</span>
                    </button>
                    <button class="nav-item" data-panel="settings-panel">
                        <i class="fas fa-cog text-xl mb-1"></i>
                        <span class="text-xs">ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™</span>
                    </button>
                </div>
            </nav>
        </div>
        
        <!-- Separate Memorization Interface -->
        <div id="memorization-interface" class="hidden">
            <!-- Memorization Header -->
            <header class="bg-gradient-to-l from-purple-600 to-purple-700 text-white shadow-md z-40">
                <div class="flex items-center justify-between px-4 py-3">
                    <div class="flex items-center gap-3">
                        <button id="back-to-main" class="p-2 rounded-lg hover:bg-white/10 transition-colors">
                            <i class="fas fa-arrow-right text-lg"></i>
                        </button>
                        <div>
                            <h1 class="text-sm font-bold">Ÿàÿ∂ÿπ ÿßŸÑÿ™ÿ≠ŸÅŸäÿ∏</h1>
                            <p class="text-xs opacity-90" id="memorization-info">
                                <span id="memorization-surah-name"></span> ‚Ä¢ <span id="memorization-range"></span>
                            </p>
                        </div>
                    </div>
                    
                    <div class="flex items-center gap-2">
                        <!-- Memorization Controls -->
                        <button id="memorization-show-verse-header" class="p-2 rounded-lg hover:bg-white/10 transition-colors" title="ÿ•ÿ∏Ÿáÿßÿ± ÿßŸÑÿ¢Ÿäÿ©">
                            <i class="fas fa-eye text-lg"></i>
                        </button>
                        <button id="memorization-hint-header" class="p-2 rounded-lg hover:bg-white/10 transition-colors" title="ÿ™ŸÑŸÖŸäÿ≠">
                            <i class="fas fa-lightbulb text-lg"></i>
                        </button>
                        <button id="memorization-play-audio-header" class="p-2 rounded-lg hover:bg-white/10 transition-colors" title="ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿµŸàÿ™">
                            <i class="fas fa-play text-lg"></i>
                        </button>
                        <button id="memorization-settings" class="p-2 rounded-lg hover:bg-white/10 transition-colors" title="ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ≠ŸÅÿ∏">
                            <i class="fas fa-cog text-lg"></i>
                        </button>
                    </div>
                </div>
            </header>
            
            <!-- Memorization Content -->
            <main id="memorization-content" class="flex-1 overflow-y-auto custom-scrollbar relative bg-gradient-to-br from-purple-50 via-indigo-50 to-purple-100 dark:from-purple-900/20 dark:via-indigo-900/15 dark:to-purple-800/20">
                
                <!-- Memorization Page Content -->
                <div id="memorization-page-wrapper" class="page-content pt-4">
                    <div id="memorization-page-content" class="font-arabic text-2xl leading-loose text-center py-8"></div>
                </div>
                
                <!-- Errors Panel - Simple error count indicator -->
                <div class="fixed top-20 right-4 z-30">
                    <div id="memorization-errors-indicator" class="bg-red-500 text-white rounded-full px-3 py-1 text-sm font-bold hidden">
                        <i class="fas fa-exclamation-triangle mr-1"></i>
                        <span id="memorization-errors-count">0</span>
                    </div>
                </div>
                
                <!-- Floating Progress Ring -->
                <div class="fixed top-20 left-4 z-30">
                    <div class="relative w-16 h-16">
                        <svg class="progress-ring w-16 h-16">
                            <circle class="progress-ring-circle" stroke="#e5e7eb" stroke-width="3" fill="transparent" r="26" cx="32" cy="32"/>
                            <circle id="memorization-progress-ring" class="progress-ring-circle" stroke="#8b5cf6" stroke-width="3" fill="transparent" r="26" cx="32" cy="32"/>
                        </svg>
                        <div class="absolute inset-0 flex items-center justify-center">
                            <span id="memorization-progress-percent" class="text-sm font-bold text-purple-600">0%</span>
                        </div>
                    </div>
                </div>
            </main>
            
            <!-- Simplified Memorization Footer -->
            <footer class="bg-gradient-to-r from-purple-700 via-purple-600 to-indigo-700 text-white p-4">
                <!-- Essential Control Buttons Only -->
                <div class="flex items-center justify-center gap-3 mb-3">
                    <button id="memorization-hint-footer" class="btn bg-yellow-500 hover:bg-yellow-600 text-white border-0 text-sm px-3 py-2 rounded-lg flex items-center gap-1">
                        <i class="fas fa-lightbulb"></i>
                        <span>ÿ™ŸÑŸÖŸäÿ≠</span>
                    </button>
                    <button id="memorization-skip-word-footer" class="btn bg-orange-500 hover:bg-orange-600 text-white border-0 text-sm px-3 py-2 rounded-lg flex items-center gap-1">
                        <i class="fas fa-forward"></i>
                        <span>ÿ™ÿÆÿ∑Ÿä</span>
                    </button>
                    <button id="memorization-reset-footer" class="btn bg-blue-500 hover:bg-blue-600 text-white border-0 text-sm px-3 py-2 rounded-lg flex items-center gap-1">
                        <i class="fas fa-redo"></i>
                        <span>ÿ•ÿπÿßÿØÿ©</span>
                    </button>
                    <button id="stop-memorization" class="btn bg-red-500 hover:bg-red-600 text-white border-0 px-4 py-2 rounded-lg flex items-center gap-1">
                        <i class="fas fa-stop"></i>
                        <span>ÿ•ŸäŸÇÿßŸÅ</span>
                    </button>
                </div>
                
                <!-- Minimal Progress Info -->
                <div class="text-center text-sm">
                    <!-- Speech Interim Feedback -->
                    <div id="speech-interim-feedback" class="text-xs text-yellow-200 opacity-50 mb-2 min-h-4"></div>
                    
                    <div class="mb-2 flex items-center justify-between">
                        <span>ÿßŸÑÿ™ŸÇÿØŸÖ: <span id="memorization-progress-text" class="font-bold">Ÿ†</span> ŸÖŸÜ <span id="memorization-total-text" class="font-bold">Ÿ†</span> ŸÉŸÑŸÖÿ©</span>
                        <span>ÿßŸÑÿ£ÿÆÿ∑ÿßÿ°: <span id="memorization-errors-count" class="font-bold text-red-300">Ÿ†</span></span>
                    </div>
                    <div class="w-full h-2 bg-white/20 rounded-full">
                        <div id="memorization-progress-bar-footer" class="h-full bg-gradient-to-r from-yellow-300 to-green-400 rounded-full transition-all duration-500" style="width: 0%"></div>
                    </div>
                </div>
            </footer>
        </div>
        
    </div>
    
    <!-- AI Assistant FAB -->
    <button class="ai-fab">
        <i class="fas fa-robot text-2xl"></i>
    </button>
    
    <!-- AI Chat Window -->
    <div class="ai-window">
        <div class="panel-header rounded-t-2xl">
            <div class="flex items-center gap-3">
                <div class="w-10 h-10 bg-white/20 rounded-full flex items-center justify-center">
                    <i class="fas fa-robot"></i>
                </div>
                <div>
                    <h3 class="font-bold">ÿπÿ®ÿØ ÿßŸÑÿ≠ŸÉŸäŸÖ</h3>
                    <p class="text-xs opacity-90">ŸÖÿ≥ÿßÿπÿØŸÉ ÿßŸÑÿ∞ŸÉŸä</p>
                </div>
            </div>
            <button id="close-ai" class="p-2 hover:bg-white/10 rounded-lg transition-colors">
                <i class="fas fa-times text-xl"></i>
            </button>
        </div>
        
        <div id="ai-messages" class="flex-1 overflow-y-auto p-4 custom-scrollbar">
            <div class="flex gap-3 mb-4">
                <div class="w-8 h-8 bg-gradient-to-br from-emerald-500 to-emerald-600 rounded-full flex items-center justify-center flex-shrink-0">
                    <i class="fas fa-robot text-white text-xs"></i>
                </div>
                <div class="bg-gradient-to-l from-emerald-50 to-emerald-100 dark:from-emerald-900/20 dark:to-emerald-800/20 p-3 rounded-2xl rounded-tr-sm max-w-[80%]">
                    <p class="text-sm">ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ! ÿ£ŸÜÿß ÿπÿ®ÿØ ÿßŸÑÿ≠ŸÉŸäŸÖÿå ŸÉŸäŸÅ ŸäŸÖŸÉŸÜŸÜŸä ŸÖÿ≥ÿßÿπÿØÿ™ŸÉ ŸÅŸä ÿ±ÿ≠ŸÑÿ™ŸÉ ŸÖÿπ ÿßŸÑŸÇÿ±ÿ¢ŸÜ ÿßŸÑŸÉÿ±ŸäŸÖÿü</p>
                </div>
            </div>
        </div>
        
        <div id="ai-suggestions" class="px-4 py-2 flex gap-2 overflow-x-auto custom-scrollbar border-t" style="border-color: var(--border)">
            <!-- Suggestions will be added dynamically -->
        </div>
        
        <div class="p-4 border-t" style="border-color: var(--border)">
            <div class="flex gap-2">
                <input id="ai-input" type="text" class="input flex-1" placeholder="ÿßÿ≥ÿ£ŸÑ ÿπÿ®ÿØ ÿßŸÑÿ≠ŸÉŸäŸÖ...">
                <button id="ai-send" class="btn btn-primary">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Menu Panel -->
    <div id="menu-panel" class="panel">
        <div class="panel-header">
            <h2 class="text-xl font-bold">ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©</h2>
            <button class="close-panel p-2 hover:bg-white/10 rounded-lg transition-colors">
                <i class="fas fa-times text-xl"></i>
            </button>
        </div>
        <div class="flex-1 overflow-y-auto">
            <div class="menu-item" onclick="App.startMemorizationMode('page')">
                <i class="fas fa-brain"></i>
                <div>
                    <h4 class="font-bold">Ÿàÿ∂ÿπ ÿßŸÑÿ™ÿ≠ŸÅŸäÿ∏</h4>
                    <p class="text-xs" style="color: var(--text-secondary)">ÿßÿ≠ŸÅÿ∏ ÿßŸÑŸÇÿ±ÿ¢ŸÜ ÿ®ÿßŸÑÿ™ÿπÿ±ŸÅ ÿπŸÑŸâ ÿßŸÑÿµŸàÿ™</p>
                </div>
            </div>
            <div class="menu-item" onclick="App.openPanel('reading-modes-panel')">
                <i class="fas fa-book-open"></i>
                <div>
                    <h4 class="font-bold">ÿ£Ÿàÿ∂ÿßÿπ ÿßŸÑŸÇÿ±ÿßÿ°ÿ©</h4>
                    <p class="text-xs" style="color: var(--text-secondary)">ŸÇÿ±ÿßÿ°ÿ©ÿå ÿ≠ŸÅÿ∏ÿå ŸÖÿ±ÿßÿ¨ÿπÿ©</p>
                </div>
            </div>
            <div class="menu-item" onclick="App.openPanel('statistics-panel')">
                <i class="fas fa-chart-bar"></i>
                <div>
                    <h4 class="font-bold">ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™</h4>
                    <p class="text-xs" style="color: var(--text-secondary)">ÿ™ÿßÿ®ÿπ ÿ™ŸÇÿØŸÖŸÉ ŸÅŸä ÿßŸÑŸÇÿ±ÿßÿ°ÿ©</p>
                </div>
            </div>
            <div class="menu-item" onclick="App.openPanel('duas-panel')">
                <i class="fas fa-hands-praying"></i>
                <div>
                    <h4 class="font-bold">ÿßŸÑÿ£ÿØÿπŸäÿ©</h4>
                    <p class="text-xs" style="color: var(--text-secondary)">ÿ£ÿØÿπŸäÿ© ŸÖŸÜ ÿßŸÑŸÇÿ±ÿ¢ŸÜ ŸàÿßŸÑÿ≥ŸÜÿ©</p>
                </div>
            </div>
            <div class="menu-item" onclick="App.openPanel('tasbih-panel')">
                <i class="fas fa-circle-notch"></i>
                <div>
                    <h4 class="font-bold">ÿßŸÑÿ™ÿ≥ÿ®Ÿäÿ≠</h4>
                    <p class="text-xs" style="color: var(--text-secondary)">ÿπÿØÿßÿØ ÿßŸÑÿ™ÿ≥ÿ®Ÿäÿ≠ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä</p>
                </div>
            </div>
            <div class="menu-item" onclick="App.openPanel('notes-panel')">
                <i class="fas fa-sticky-note"></i>
                <div>
                    <h4 class="font-bold">ÿßŸÑŸÖŸÑÿßÿ≠ÿ∏ÿßÿ™</h4>
                    <p class="text-xs" style="color: var(--text-secondary)">ÿØŸàŸÜ ŸÖŸÑÿßÿ≠ÿ∏ÿßÿ™ŸÉ Ÿàÿ™ÿ£ŸÖŸÑÿßÿ™ŸÉ</p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Ayah Context Menu -->
    <div id="ayah-menu" class="fixed bottom-0 left-0 right-0 context-menu transform translate-y-full transition-transform z-50 hidden">
        <div class="p-4">
            <div class="mb-4">
                <p id="selected-ayah" class="font-arabic text-lg mb-2"></p>
                <p id="selected-info" class="text-sm" style="color: var(--text-secondary)"></p>
            </div>
            
            <div class="grid grid-cols-3 gap-3">
                <button id="ayah-play" class="card text-center py-3">
                    <i class="fas fa-play-circle text-2xl mb-2" style="color: var(--primary)"></i>
                    <span class="text-xs">ÿßÿ≥ÿ™ŸÖÿßÿπ</span>
                </button>
                <button id="ayah-tafsir" class="card text-center py-3">
                    <i class="fas fa-book-open text-2xl mb-2" style="color: var(--primary)"></i>
                    <span class="text-xs">ÿßŸÑÿ™ŸÅÿ≥Ÿäÿ±</span>
                </button>
                <button id="ayah-bookmark" class="card text-center py-3">
                    <i class="fas fa-bookmark text-2xl mb-2" style="color: var(--primary)"></i>
                    <span class="text-xs">ÿ≠ŸÅÿ∏</span>
                </button>
                <button id="ayah-share" class="card text-center py-3">
                    <i class="fas fa-share-alt text-2xl mb-2" style="color: var(--primary)"></i>
                    <span class="text-xs">ŸÖÿ¥ÿßÿ±ŸÉÿ©</span>
                </button>
                <button id="ayah-copy" class="card text-center py-3">
                    <i class="fas fa-copy text-2xl mb-2" style="color: var(--primary)"></i>
                    <span class="text-xs">ŸÜÿ≥ÿÆ</span>
                </button>
                <button id="ayah-ai" class="card text-center py-3">
                    <i class="fas fa-robot text-2xl mb-2" style="color: var(--primary)"></i>
                    <span class="text-xs">ÿßÿ≥ÿ£ŸÑ</span>
                </button>
            </div>
        </div>
    </div>
    <div id="ayah-menu-backdrop" class="fixed inset-0 bg-black/30 backdrop-blur-sm z-45 hidden"></div>
    
    <!-- Share Options Modal -->
    <div id="share-options-modal" class="modal">
        <div class="modal-content p-6">
            <h3 class="text-xl font-bold mb-4">ŸÖÿ¥ÿßÿ±ŸÉÿ© ÿßŸÑÿ¢Ÿäÿ©</h3>
            <div class="space-y-3">
                <button id="share-as-text" class="btn btn-primary w-full">
                    <i class="fas fa-file-alt"></i>
                    ŸÖÿ¥ÿßÿ±ŸÉÿ© ŸÉŸÜÿµ
                </button>
                <button id="share-as-image-btn" class="btn btn-primary w-full">
                    <i class="fas fa-image"></i>
                    ŸÖÿ¥ÿßÿ±ŸÉÿ© ŸÉÿµŸàÿ±ÿ©
                </button>
            </div>
            <button id="close-share-modal" class="btn btn-secondary w-full mt-4">
                ÿ•ŸÑÿ∫ÿßÿ°
            </button>
        </div>
    </div>
    
    <!-- Share as Image Panel -->
    <div id="share-image-panel" class="panel">
        <div class="panel-header">
            <h2 class="text-xl font-bold">ŸÖÿ¥ÿßÿ±ŸÉÿ© ŸÉÿµŸàÿ±ÿ©</h2>
            <button class="close-panel p-2 hover:bg-white/10 rounded-lg transition-colors">
                <i class="fas fa-times text-xl"></i>
            </button>
        </div>
        <div class="flex-1 overflow-y-auto p-4">
            <!-- Image Preview -->
            <div id="share-image-preview" class="mb-4">
                <p id="share-text" class="font-arabic text-2xl mb-4"></p>
                <p id="share-info" class="text-sm mb-4"></p>
                <p class="watermark">ŸÖÿµÿ≠ŸÅ ÿßŸÑŸáÿßÿØŸä</p>
            </div>
            
            <!-- Customization Options -->
            <div class="space-y-4">
                <div>
                    <label class="block text-sm mb-2">ÿ≠ÿ¨ŸÖ ÿßŸÑÿÆÿ∑</label>
                    <input type="range" id="share-font-size" min="16" max="40" value="24" class="w-full">
                    <div class="flex justify-between text-xs mt-1" style="color: var(--text-secondary)">
                        <span>ÿµÿ∫Ÿäÿ±</span>
                        <span id="share-font-size-value">24px</span>
                        <span>ŸÉÿ®Ÿäÿ±</span>
                    </div>
                </div>
                
                <div>
                    <label class="block text-sm mb-2">ŸÑŸàŸÜ ÿßŸÑÿÆŸÑŸÅŸäÿ©</label>
                    <div class="grid grid-cols-6 gap-2">
                        <button class="share-bg-color w-10 h-10 rounded-lg border-2" style="background: #ffffff" data-color="#ffffff"></button>
                        <button class="share-bg-color w-10 h-10 rounded-lg border-2" style="background: #f3f4f6" data-color="#f3f4f6"></button>
                        <button class="share-bg-color w-10 h-10 rounded-lg border-2" style="background: #fef3c7" data-color="#fef3c7"></button>
                        <button class="share-bg-color w-10 h-10 rounded-lg border-2" style="background: #dcfce7" data-color="#dcfce7"></button>
                        <button class="share-bg-color w-10 h-10 rounded-lg border-2" style="background: #e0e7ff" data-color="#e0e7ff"></button>
                        <button class="share-bg-color w-10 h-10 rounded-lg border-2" style="background: #1f2937" data-color="#1f2937"></button>
                    </div>
                </div>
                
                <div>
                    <label class="block text-sm mb-2">ŸÑŸàŸÜ ÿßŸÑŸÜÿµ</label>
                    <div class="grid grid-cols-6 gap-2">
                        <button class="share-text-color w-10 h-10 rounded-lg border-2" style="background: #111827" data-color="#111827"></button>
                        <button class="share-text-color w-10 h-10 rounded-lg border-2" style="background: #059669" data-color="#059669"></button>
                        <button class="share-text-color w-10 h-10 rounded-lg border-2" style="background: #0369a1" data-color="#0369a1"></button>
                        <button class="share-text-color w-10 h-10 rounded-lg border-2" style="background: #92400e" data-color="#92400e"></button>
                        <button class="share-text-color w-10 h-10 rounded-lg border-2" style="background: #7c3aed" data-color="#7c3aed"></button>
                        <button class="share-text-color w-10 h-10 rounded-lg border-2" style="background: #ffffff" data-color="#ffffff"></button>
                    </div>
                </div>
                
                <div>
                    <label class="block text-sm mb-2">ŸÜŸàÿπ ÿßŸÑÿÆÿ∑</label>
                    <select id="share-font-type" class="input">
                        <option value="Amiri Quran">ÿπÿ´ŸÖÿßŸÜŸä</option>
                        <option value="Scheherazade New">ŸáŸÜÿØŸä ÿ®ÿßŸÉÿ≥ÿ™ÿßŸÜŸä</option>
                        <option value="Noto Naskh Arabic">ŸÜÿ≥ÿÆ</option>
                        <option value="Lateef">ŸÑÿ∑ŸäŸÅ</option>
                        <option value="Kitab">ŸÉÿ™ÿßÿ®</option>
                        <option value="Almarai">ÿßŸÑŸÖÿ±ÿßÿπŸä</option>
                        <option value="Cairo">ÿßŸÑŸÇÿßŸáÿ±ÿ©</option>
                    </select>
                </div>
                
                <div class="flex gap-2">
                    <button id="generate-share-image" class="btn btn-primary flex-1">
                        <i class="fas fa-share"></i>
                        ŸÖÿ¥ÿßÿ±ŸÉÿ©
                    </button>
                    <button id="download-share-image" class="btn btn-secondary flex-1">
                        <i class="fas fa-download"></i>
                        ÿ™ÿ≠ŸÖŸäŸÑ
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Memorization Panel -->
    <div id="memorization-panel" class="panel">
        <div class="panel-header">
            <h2 class="text-xl font-bold">Ÿàÿ∂ÿπ ÿßŸÑÿ™ÿ≠ŸÅŸäÿ∏</h2>
            <button class="close-panel p-2 hover:bg-white/10 rounded-lg transition-colors">
                <i class="fas fa-times text-xl"></i>
            </button>
        </div>
        <div class="flex-1 overflow-y-auto custom-scrollbar p-4">
            
            <!-- Memorization Mode Selection -->
            <div class="card mb-4">
                <h3 class="font-bold mb-3 flex items-center gap-2">
                    <i class="fas fa-brain" style="color: var(--primary)"></i>
                    ÿßÿÆÿ™ÿ± ŸÜŸàÿπ ÿßŸÑÿ≠ŸÅÿ∏
                </h3>
                <div class="space-y-3">
                    <button id="start-verse-memorization" class="btn btn-primary w-full">
                        <i class="fas fa-microphone"></i>
                        ÿ≠ŸÅÿ∏ ÿßŸÑÿ¢Ÿäÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©
                    </button>
                    <button id="start-page-memorization" class="btn btn-secondary w-full">
                        <i class="fas fa-file-alt"></i>
                        ÿ≠ŸÅÿ∏ ÿßŸÑÿµŸÅÿ≠ÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©
                    </button>
                    <button id="start-surah-memorization" class="btn btn-secondary w-full">
                        <i class="fas fa-book"></i>
                        ÿ≠ŸÅÿ∏ ÿ≥Ÿàÿ±ÿ© ŸÖÿÆÿ™ÿßÿ±ÿ©
                    </button>
                </div>
            </div>
            
            <!-- Custom Range Selection -->
            <div class="card mb-4">
                <h3 class="font-bold mb-3 flex items-center gap-2">
                    <i class="fas fa-sliders-h" style="color: var(--primary)"></i>
                    ÿ™ÿ≠ÿØŸäÿØ ŸÜÿ∑ÿßŸÇ ŸÖÿÆÿµÿµ
                </h3>
                <div class="space-y-3">
                    <div class="grid grid-cols-2 gap-3">
                        <div>
                            <label class="block text-sm mb-1">ŸÖŸÜ ÿ≥Ÿàÿ±ÿ©</label>
                            <select id="memorization-from-surah" class="input text-sm">
                                <!-- Will be populated dynamically -->
                            </select>
                        </div>
                        <div>
                            <label class="block text-sm mb-1">ŸÖÿ© ÿ¢Ÿäÿ©</label>
                            <input type="number" id="memorization-from-ayah" class="input text-sm" min="1" value="1">
                        </div>
                    </div>
                    <div class="grid grid-cols-2 gap-3">
                        <div>
                            <label class="block text-sm mb-1">ÿ•ŸÑŸâ ÿ≥Ÿàÿ±ÿ©</label>
                            <select id="memorization-to-surah" class="input text-sm">
                                <!-- Will be populated dynamically -->
                            </select>
                        </div>
                        <div>
                            <label class="block text-sm mb-1">ÿ•ŸÑŸâ ÿ¢Ÿäÿ©</label>
                            <input type="number" id="memorization-to-ayah" class="input text-sm" min="1" value="1">
                        </div>
                    </div>
                    <button id="start-custom-memorization" class="btn btn-primary w-full">
                        <i class="fas fa-play"></i>
                        ÿ®ÿØÿ° ÿßŸÑÿ≠ŸÅÿ∏ ÿßŸÑŸÖÿÆÿµÿµ
                    </button>
                </div>
            </div>
            
            <!-- Memorization Settings -->
            <div class="card mb-4">
                <h3 class="font-bold mb-3 flex items-center gap-2">
                    <i class="fas fa-cog" style="color: var(--primary)"></i>
                    ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ≠ŸÅÿ∏
                </h3>
                <div class="space-y-3">
                    <div class="flex justify-between items-center">
                        <label class="text-sm">ÿßŸÑÿ™ŸÜÿ®ŸäŸá ÿπŸÜÿØ ÿßŸÑÿÆÿ∑ÿ£</label>
                        <input type="checkbox" id="memorization-sound-alerts" class="checkbox" checked>
                    </div>
                    <div class="flex justify-between items-center">
                        <label class="text-sm">ÿ•ÿ∏Ÿáÿßÿ± ÿßŸÑÿ™ÿ¥ŸÉŸäŸÑ</label>
                        <input type="checkbox" id="memorization-show-tashkeel" class="checkbox" checked>
                    </div>
                    <div class="flex justify-between items-center">
                        <label class="text-sm">ÿßŸÑÿ™ŸÉÿ±ÿßÿ± ÿπŸÜÿØ ÿßŸÑÿÆÿ∑ÿ£</label>
                        <input type="checkbox" id="memorization-auto-repeat" class="checkbox" checked>
                    </div>
                    <div>
                        <label class="block text-sm mb-1">ÿ≠ÿ≥ÿßÿ≥Ÿäÿ© ÿßŸÑÿ™ÿπÿ±ŸÅ ÿπŸÑŸâ ÿßŸÑÿµŸàÿ™</label>
                        <input type="range" id="memorization-sensitivity" min="0.5" max="1" step="0.1" value="0.8" class="w-full">
                        <div class="flex justify-between text-xs mt-1" style="color: var(--text-secondary)">
                            <span>ŸÖŸÜÿÆŸÅÿ∂</span>
                            <span id="memorization-sensitivity-value">80%</span>
                            <span>ÿπÿßŸÑŸä</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Memorization Statistics -->
            <div class="card">
                <h3 class="font-bold mb-3 flex items-center gap-2">
                    <i class="fas fa-chart-bar" style="color: var(--primary)"></i>
                    ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ≠ŸÅÿ∏
                </h3>
                <div class="grid grid-cols-2 gap-3 text-center">
                    <div>
                        <p class="text-lg font-bold" style="color: var(--primary)" id="memorization-total-words">0</p>
                        <p class="text-xs" style="color: var(--text-secondary)">ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑŸÉŸÑŸÖÿßÿ™</p>
                    </div>
                    <div>
                        <p class="text-lg font-bold" style="color: var(--secondary)" id="memorization-correct-words">0</p>
                        <p class="text-xs" style="color: var(--text-secondary)">ŸÉŸÑŸÖÿßÿ™ ÿµÿ≠Ÿäÿ≠ÿ©</p>
                    </div>
                    <div>
                        <p class="text-lg font-bold text-red-500" id="memorization-incorrect-words">0</p>
                        <p class="text-xs" style="color: var(--text-secondary)">ŸÉŸÑŸÖÿßÿ™ ÿÆÿßÿ∑ÿ¶ÿ©</p>
                    </div>
                    <div>
                        <p class="text-lg font-bold" style="color: var(--primary)" id="memorization-accuracy">0%</p>
                        <p class="text-xs" style="color: var(--text-secondary)">ÿØŸÇÿ© ÿßŸÑÿ≠ŸÅÿ∏</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Panels -->
    
    <!-- Index Panel -->
    <div id="index-panel" class="panel">
        <div class="panel-header">
            <h2 class="text-xl font-bold">ŸÅŸáÿ±ÿ≥ ÿßŸÑÿ≥Ÿàÿ±</h2>
            <button class="close-panel p-2 hover:bg-white/10 rounded-lg transition-colors">
                <i class="fas fa-times text-xl"></i>
            </button>
        </div>
        <div class="p-4">
            <div class="relative">
                <input id="surah-search" type="text" class="input pr-10" placeholder="ÿßÿ®ÿ≠ÿ´ ÿπŸÜ ÿ≥Ÿàÿ±ÿ©...">
                <i class="fas fa-search absolute left-3 top-1/2 -translate-y-1/2" style="color: var(--text-tertiary)"></i>
            </div>
        </div>
        <div id="surah-list" class="flex-1 overflow-y-auto custom-scrollbar px-4 pb-4">
            <!-- Surahs will be loaded dynamically -->
        </div>
    </div>
    
    <!-- Panels -->

    <!-- Index Panel -->
    <div id="index-panel" class="panel">
        <div class="panel-header">
            <h2 class="text-xl font-bold">ŸÅŸáÿ±ÿ≥ ÿßŸÑŸÇÿ±ÿ¢ŸÜ</h2>
            <button class="close-panel p-2 hover:bg-white/10 rounded-lg transition-colors">
                <i class="fas fa-times text-xl"></i>
            </button>
        </div>
    </div>
    
    <!-- Search Panel -->
    <div id="search-panel" class="panel">
        <div class="panel-header">
            <h2 class="text-xl font-bold">ÿßŸÑÿ®ÿ≠ÿ´ ŸÅŸä ÿßŸÑŸÇÿ±ÿ¢ŸÜ</h2>
            <button class="close-panel p-2 hover:bg-white/10 rounded-lg transition-colors">
                <i class="fas fa-times text-xl"></i>
            </button>
        </div>
        <div class="p-4">
            <div class="relative">
                <input id="search-input" type="text" class="input pr-10" placeholder="ÿßÿ®ÿ≠ÿ´ ŸÅŸä ÿßŸÑŸÇÿ±ÿ¢ŸÜ...">
                <i class="fas fa-search absolute left-3 top-1/2 -translate-y-1/2" style="color: var(--text-tertiary)"></i>
            </div>
        </div>
        <div id="search-results" class="flex-1 overflow-y-auto custom-scrollbar px-4 pb-4">
            <!-- Search results will appear here -->
        </div>
    </div>
    
    <!-- Settings Panel -->
    <div id="settings-panel" class="panel">
        <div class="panel-header">
            <h2 class="text-xl font-bold">ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™</h2>
            <button class="close-panel p-2 hover:bg-white/10 rounded-lg transition-colors">
                <i class="fas fa-times text-xl"></i>
            </button>
        </div>
        <div class="flex-1 overflow-y-auto custom-scrollbar p-4">
            
            <!-- Theme Selection -->
            <div class="card mb-4">
                <h3 class="font-bold mb-3 flex items-center gap-2">
                    <i class="fas fa-palette" style="color: var(--primary)"></i>
                    ÿßŸÑŸÖÿ∏Ÿáÿ±
                </h3>
                <div class="grid grid-cols-2 gap-3">
                    <button class="theme-option p-3 rounded-lg border-2 transition-all text-center" data-theme="light" style="border-color: var(--border)">
                        <i class="fas fa-sun text-yellow-500 mb-2"></i>
                        <p class="text-sm">ŸÅÿßÿ™ÿ≠</p>
                    </button>
                    <button class="theme-option p-3 rounded-lg border-2 transition-all text-center" data-theme="dark" style="border-color: var(--border)">
                        <i class="fas fa-moon text-blue-500 mb-2"></i>
                        <p class="text-sm">ÿØÿßŸÉŸÜ</p>
                    </button>
                    <button class="theme-option p-3 rounded-lg border-2 transition-all text-center" data-theme="sepia" style="border-color: var(--border)">
                        <i class="fas fa-coffee text-amber-600 mb-2"></i>
                        <p class="text-sm">ÿ≥Ÿäÿ®Ÿäÿß</p>
                    </button>
                    <button class="theme-option p-3 rounded-lg border-2 transition-all text-center" data-theme="blue" style="border-color: var(--border)">
                        <i class="fas fa-water text-blue-600 mb-2"></i>
                        <p class="text-sm">ÿ£ÿ≤ÿ±ŸÇ</p>
                    </button>
                </div>
            </div>
            
            <!-- Reading Settings -->
            <div class="card mb-4">
                <h3 class="font-bold mb-3 flex items-center gap-2">
                    <i class="fas fa-book-reader" style="color: var(--primary)"></i>
                    ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑŸÇÿ±ÿßÿ°ÿ©
                </h3>
                <div class="space-y-3">
                    <div>
                        <label class="block text-sm mb-2">ÿ≠ÿ¨ŸÖ ÿßŸÑÿÆÿ∑</label>
                        <input type="range" id="font-size" min="14" max="30" value="20" class="w-full">
                        <div class="flex justify-between text-xs mt-1" style="color: var(--text-secondary)">
                            <span>ÿµÿ∫Ÿäÿ±</span>
                            <span id="font-size-value">20px</span>
                            <span>ŸÉÿ®Ÿäÿ±</span>
                        </div>
                    </div>
                    <div>
                        <label class="block text-sm mb-2">ŸÜŸàÿπ ÿßŸÑÿÆÿ∑</label>
                        <select id="font-type" class="input">
                            <option value="font-arabic">ÿπÿ´ŸÖÿßŸÜŸä</option>
                            <option value="font-indopak">ŸáŸÜÿØŸä ÿ®ÿßŸÉÿ≥ÿ™ÿßŸÜŸä</option>
                            <option value="font-noto">ŸÜÿ≥ÿÆ</option>
                            <option value="font-lateef">ŸÑÿ∑ŸäŸÅ</option>
                            <option value="font-kitab">ŸÉÿ™ÿßÿ®</option>
                            <option value="font-almarai">ÿßŸÑŸÖÿ±ÿßÿπŸä</option>
                            <option value="font-cairo">ÿßŸÑŸÇÿßŸáÿ±ÿ©</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm mb-2">ÿßŸÑŸÇÿßÿ±ÿ¶</label>
                        <select id="reciter-select" class="input">
                            <!-- Will be populated dynamically -->
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm mb-2">ÿßŸÑÿ™ŸÅÿ≥Ÿäÿ±</label>
                        <select id="tafsir-select" class="input">
                            <option value="169">ÿßŸÑÿ™ŸÅÿ≥Ÿäÿ± ÿßŸÑŸÖŸäÿ≥ÿ±</option>
                            <option value="164">ÿ™ŸÅÿ≥Ÿäÿ± ÿßŸÑÿ≥ÿπÿØŸä</option>
                            <option value="163">ÿ™ŸÅÿ≥Ÿäÿ± ÿßŸÑÿ®ÿ∫ŸàŸä</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm mb-2">ÿßŸÑÿ™ÿ±ÿ¨ŸÖÿ©</label>
                        <select id="translation-select" class="input">
                            <option value="131">Dr. Mustafa Khattab</option>
                            <option value="20">Sahih International</option>
                            <option value="85">Abdul Haleem</option>
                        </select>
                    </div>
                </div>
            </div>
            
        </div>
    </div>
    
    <!-- Bookmarks Panel -->
    <div id="bookmarks-panel" class="panel">
        <div class="panel-header">
            <h2 class="text-xl font-bold">ÿßŸÑŸÖŸÅÿ∂ŸÑÿ©</h2>
            <button class="close-panel p-2 hover:bg-white/10 rounded-lg transition-colors">
                <i class="fas fa-times text-xl"></i>
            </button>
        </div>
        <div id="bookmarks-list" class="flex-1 overflow-y-auto custom-scrollbar p-4">
            <p class="text-center opacity-50">ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿπŸÜÿßÿµÿ± ŸÖÿ≠ŸÅŸàÿ∏ÿ©</p>
        </div>
    </div>
    
    <!-- Khatmah Panel -->
    <div id="khatmah-panel" class="panel">
        <div class="panel-header">
            <h2 class="text-xl font-bold">ÿßŸÑÿÆÿ™ŸÖÿßÿ™</h2>
            <button class="close-panel p-2 hover:bg-white/10 rounded-lg transition-colors">
                <i class="fas fa-times text-xl"></i>
            </button>
        </div>
        <div class="flex-1 overflow-y-auto custom-scrollbar p-4">
            <!-- Create New Khatmah -->
            <div class="card mb-4">
                <h3 class="font-bold mb-3 flex items-center gap-2">
                    <i class="fas fa-plus-circle" style="color: var(--primary)"></i>
                    ÿ•ŸÜÿ¥ÿßÿ° ÿÆÿ™ŸÖÿ© ÿ¨ÿØŸäÿØÿ©
                </h3>
                <div class="space-y-3">
                    <input type="text" id="khatmah-name" class="input" placeholder="ÿßÿ≥ŸÖ ÿßŸÑÿÆÿ™ŸÖÿ© (ŸÖÿ´ÿßŸÑ: ÿÆÿ™ŸÖÿ© ÿ±ŸÖÿ∂ÿßŸÜ)">
                    <input type="text" id="khatmah-goal" class="input" placeholder="ÿßŸÑŸáÿØŸÅ (ŸÖÿ´ÿßŸÑ: ÿÆÿ™ŸÖ ÿßŸÑŸÇÿ±ÿ¢ŸÜ ŸÅŸä 30 ŸäŸàŸÖ)">
                    <input type="number" id="khatmah-daily-pages" class="input" placeholder="ÿπÿØÿØ ÿßŸÑÿµŸÅÿ≠ÿßÿ™ ÿßŸÑŸäŸàŸÖŸäÿ©" min="1" max="604" value="20">
                    <button id="create-khatmah" class="btn btn-primary w-full">
                        <i class="fas fa-plus"></i>
                        ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿÆÿ™ŸÖÿ©
                    </button>
                </div>
            </div>
            
            <!-- Current Khatmahs -->
            <div class="mb-4">
                <h3 class="font-bold mb-3 flex items-center gap-2">
                    <i class="fas fa-book-open" style="color: var(--primary)"></i>
                    ÿßŸÑÿÆÿ™ŸÖÿßÿ™ ÿßŸÑÿ≠ÿßŸÑŸäÿ©
                </h3>
                <div id="current-khatmahs">
                    <!-- Current khatmahs will be loaded here -->
                </div>
            </div>
            
            <!-- Completed Khatmahs -->
            <div>
                <h3 class="font-bold mb-3 flex items-center gap-2">
                    <i class="fas fa-trophy" style="color: var(--secondary)"></i>
                    ÿßŸÑÿÆÿ™ŸÖÿßÿ™ ÿßŸÑŸÖŸÉÿ™ŸÖŸÑÿ©
                </h3>
                <div id="completed-khatmahs">
                    <!-- Completed khatmahs will be loaded here -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- Khatmah Analytics Modal -->
    <div id="khatmah-analytics-modal" class="modal">
        <div class="modal-content p-6" style="max-width: 600px">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold">ÿ™ÿ≠ŸÑŸäŸÑÿßÿ™ ÿßŸÑÿÆÿ™ŸÖÿ©</h3>
                <button id="close-analytics" class="text-2xl">&times;</button>
            </div>
            
            <div id="analytics-content">
                <!-- Analytics will be loaded here -->
            </div>
        </div>
    </div>
    
    <!-- Tafsir Popup -->
    <div id="tafsir-popup" class="fixed inset-0 z-[100] bg-black/50 backdrop-blur-sm hidden items-center justify-center p-4">
        <div class="bg-white dark:bg-gray-800 rounded-xl max-w-2xl w-full max-h-[80vh] overflow-hidden shadow-xl">
            <div class="panel-header rounded-t-xl">
                <h3 class="text-lg font-bold">ÿßŸÑÿ™ŸÅÿ≥Ÿäÿ± ŸàÿßŸÑÿ™ÿ±ÿ¨ŸÖÿ©</h3>
                <button id="close-tafsir" class="p-2 hover:bg-white/10 rounded-lg transition-colors">
                    <i class="fas fa-times text-xl"></i>
                </button>
            </div>
            <div id="tafsir-content" class="p-4 overflow-y-auto max-h-[60vh] custom-scrollbar">
                <!-- Tafsir content will be loaded here -->
            </div>
        </div>
    </div>
    
    <!-- Audio Players -->
    <audio id="page-audio" class="hidden"></audio>
    <audio id="ayah-audio" class="hidden"></audio>
    
    <script>
    // App Configuration
    const CONFIG = {
        API_BASE: 'https://api.quran.com/api/v4',
        AUDIO_BASE: 'https://verses.quran.com/',
        TOTAL_PAGES: 604,
        GEMINI_API_KEY: 'AIzaSyCZynYml3QFl3GT_d_pWfpa4xeic-hpLPQ',
        GEMINI_API_URL: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent'
    };
    
    // Application State
    const state = {
        currentPage: parseInt(localStorage.getItem('lastPage')) || 1,
        currentTheme: localStorage.getItem('theme') || 'light',
        fontSize: parseInt(localStorage.getItem('fontSize')) || 20,
        fontType: localStorage.getItem('fontType') || 'font-arabic',
        surahs: [],
        reciters: [],
        tafsirs: [],
        translations: [],
        selectedReciter: parseInt(localStorage.getItem('selectedReciter')) || 7,
        selectedTafsir: parseInt(localStorage.getItem('selectedTafsir')) || 169,
        selectedTranslation: parseInt(localStorage.getItem('selectedTranslation')) || 131,
        pageData: null,
        selectedAyah: null,
        isPlaying: false,
        currentAudioIndex: 0,
        audioQueue: [],
        bookmarks: JSON.parse(localStorage.getItem('bookmarks')) || [],
        khatmahs: JSON.parse(localStorage.getItem('khatmahs')) || [],
        shareSettings: {
            fontSize: 24,
            bgColor: '#ffffff',
            textColor: '#111827',
            fontFamily: 'Amiri Quran'
        },
        currentSurahsInPage: [],
        memorizationMode: false,
        speechRecognition: null,
        currentMemorizationWords: [],
        lastProcessedWord: null, // ÿ™ÿ™ÿ®ÿπ ÿ¢ÿÆÿ± ŸÉŸÑŸÖÿ© ÿ™ŸÖÿ™ ŸÖÿπÿßŸÑÿ¨ÿ™Ÿáÿß
        memorizationStats: {
            totalWords: 0,
            correctWords: 0,
            incorrectWords: 0,
            currentWordIndex: 0,
            errors: [],
            accuracy: 0
        },
        memorizationSettings: {
            soundAlerts: true,
            showTashkeel: true,
            autoRepeat: true,
            sensitivity: 0.8
        },
        memorizationRange: {
            type: 'page', // 'page', 'ayah', 'surah', 'custom'
            fromSurah: 1,
            fromAyah: 1,
            toSurah: 1,
            toAyah: 1
        }
    };
    
    // API Functions
    const API = {
        async fetchWithRetry(url, retries = 3) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    return await response.json();
                } catch (error) {
                    if (i === retries - 1) throw error;
                    await new Promise(r => setTimeout(r, 1000 * (i + 1)));
                }
            }
        },
        
        async getChapters() {
            const data = await this.fetchWithRetry(`${CONFIG.API_BASE}/chapters?language=ar`);
            return data.chapters;
        },
        
        async getReciters() {
            const data = await this.fetchWithRetry(`${CONFIG.API_BASE}/resources/recitations?language=ar`);
            return data.recitations;
        },
        
        async getTafsirs() {
            const data = await this.fetchWithRetry(`${CONFIG.API_BASE}/resources/tafsirs?language=ar`);
            return data.tafsirs;
        },
        
        async getTranslations() {
            const data = await this.fetchWithRetry(`${CONFIG.API_BASE}/resources/translations`);
            return data.translations;
        },
        
        async getPageData(pageNumber) {
            const url = `${CONFIG.API_BASE}/verses/by_page/${pageNumber}?language=ar&words=false&audio=${state.selectedReciter}&tafsirs=${state.selectedTafsir}&translations=${state.selectedTranslation}&fields=text_uthmani,chapter_id,juz_number,page_number,verse_key,verse_number`;
            console.log('API URL:', url);
            
            try {
                const data = await this.fetchWithRetry(url);
                console.log('API Response:', data);
                
                if (!data || !data.verses) {
                    throw new Error('Invalid API response structure');
                }
                
                return data.verses;
            } catch (error) {
                console.error('API Error:', error);
                throw new Error(`Failed to load page data: ${error.message}`);
            }
        },
        
        async searchQuran(query) {
            const data = await this.fetchWithRetry(`${CONFIG.API_BASE}/search?q=${encodeURIComponent(query)}&language=ar`);
            return data.search;
        },
        
        async getVerseByKey(verseKey) {
            const url = `${CONFIG.API_BASE}/verses/by_key/${verseKey}?language=ar&audio=${state.selectedReciter}&tafsirs=${state.selectedTafsir}&translations=${state.selectedTranslation}`;
            const data = await this.fetchWithRetry(url);
            return data.verse;
        }
    };
    
    // Core Application
    const App = {
        // Advanced Arabic Text Normalization for Speech Recognition
        normalizeArabicText(text) {
            if (!text) return '';
            
            return text
                // Remove all diacritics and tashkeel
                .replace(/[\u064B-\u065F\u0670\u06D6-\u06ED\u08F0-\u08FF\u06DF-\u06E8]/g, '')
                // Normalize Alif variations
                .replace(/[\u0671\u0623\u0625\u0622]/g, '\u0627')
                // Normalize Ta Marbuta
                .replace(/\u0629/g, '\u0647')
                // Normalize Ya variations
                .replace(/\u0649/g, '\u064a')
                // Remove Tatweel
                .replace(/\u0640/g, '')
                // Remove control characters
                .replace(/[\u200C-\u200F\u202A-\u202E]/g, '')
                // Normalize whitespace
                .replace(/\s+/g, ' ')
                .trim();
        },

        // Calculate text similarity for speech recognition
        calculateSimilarity(spoken, expected) {
            const normalizedSpoken = this.normalizeArabicText(spoken);
            const normalizedExpected = this.normalizeArabicText(expected);
            
            if (normalizedSpoken === normalizedExpected) return 1.0;
            
            // Levenshtein distance for fuzzy matching
            const matrix = [];
            const len1 = normalizedSpoken.length;
            const len2 = normalizedExpected.length;
            
            for (let i = 0; i <= len2; i++) {
                matrix[i] = [i];
            }
            
            for (let j = 0; j <= len1; j++) {
                matrix[0][j] = j;
            }
            
            for (let i = 1; i <= len2; i++) {
                for (let j = 1; j <= len1; j++) {
                    if (normalizedExpected.charAt(i - 1) === normalizedSpoken.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            
            const distance = matrix[len2][len1];
            const maxLength = Math.max(len1, len2);
            return maxLength === 0 ? 1 : (maxLength - distance) / maxLength;
        },
        async init() {
            console.log('Initializing app...');
            
            // Remove loading screen if it exists
            const loadingScreen = document.getElementById('loading-screen');
            if (loadingScreen) {
                loadingScreen.style.display = 'none';
            }
            
            try {
                // Apply saved settings
                document.body.setAttribute('data-theme', state.currentTheme);
                this.applySettings();
                
                // Add immediate test data for debugging
                const testData = [
                    {
                        text_uthmani: 'ÿ®Ÿêÿ≥ŸíŸÖŸê ÿßŸÑŸÑŸéŸëŸáŸê ÿßŸÑÿ±ŸéŸëÿ≠ŸíŸÖŸéŸ∞ŸÜŸê ÿßŸÑÿ±ŸéŸëÿ≠ŸêŸäŸÖŸê',
                        chapter_id: 1,
                        verse_key: '1:1',
                        verse_number: 1,
                        juz_number: 1
                    },
                    {
                        text_uthmani: 'ÿßŸÑŸíÿ≠ŸéŸÖŸíÿØŸè ŸÑŸêŸÑŸéŸëŸáŸê ÿ±Ÿéÿ®ŸêŸë ÿßŸÑŸíÿπŸéÿßŸÑŸéŸÖŸêŸäŸÜŸé',
                        chapter_id: 1,
                        verse_key: '1:2',
                        verse_number: 2,
                        juz_number: 1
                    }
                ];
                
                console.log('Loading chapters and reciters...');
                // Try to load resources, but continue with test data if it fails
                try {
                    const [chapters, reciters] = await Promise.all([
                        API.getChapters(),
                        API.getReciters()
                    ]);
                    
                    console.log('Chapters loaded:', chapters ? chapters.length : 'null');
                    console.log('Reciters loaded:', reciters ? reciters.length : 'null');
                    
                    state.surahs = chapters || [{ id: 1, name_arabic: 'ÿßŸÑŸÅÿßÿ™ÿ≠ÿ©' }];
                    state.reciters = reciters || [{ id: 7, reciter_name: 'Mishary Rashid Alafasy' }];
                } catch (apiError) {
                    console.warn('API failed, using fallback data:', apiError);
                    state.surahs = [{ id: 1, name_arabic: 'ÿßŸÑŸÅÿßÿ™ÿ≠ÿ©' }];
                    state.reciters = [{ id: 7, reciter_name: 'Mishary Rashid Alafasy' }];
                }
                
                // Setup UI
                this.populateSelects();
                this.initSurahList();
                this.initEventListeners();
                this.initAI();
                
                // Show test data immediately
                state.pageData = testData;
                state.currentPage = 1;
                this.renderPage();
                
                console.log('Loading actual page:', state.currentPage);
                // Try to load actual page data in background
                try {
                    await this.loadPage(state.currentPage);
                } catch (pageError) {
                    console.warn('Page loading failed, keeping test data:', pageError);
                }
                
                // Update displays
                this.updateKhatmahsDisplay();
                
                console.log('App initialized successfully');
            } catch (error) {
                console.error('Initialization error:', error);
                // Even if init fails, show test data
                state.pageData = [
                    {
                        text_uthmani: 'ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ - Ÿáÿ∞ÿß ŸÜÿµ ÿ™ÿ¨ÿ±Ÿäÿ®Ÿä',
                        chapter_id: 1,
                        verse_key: '1:1',
                        verse_number: 1,
                        juz_number: 1
                    }
                ];
                state.currentPage = 1;
                this.renderPage();
            }
        },
        
        applySettings() {
            const fontSizeEl = document.getElementById('font-size');
            const fontSizeValueEl = document.getElementById('font-size-value');
            const pageContentEl = document.getElementById('page-content');
            const fontTypeEl = document.getElementById('font-type');
            const tafsirSelectEl = document.getElementById('tafsir-select');
            const translationSelectEl = document.getElementById('translation-select');
            
            if (fontSizeEl) fontSizeEl.value = state.fontSize;
            if (fontSizeValueEl) fontSizeValueEl.textContent = state.fontSize + 'px';
            if (pageContentEl) pageContentEl.style.fontSize = state.fontSize + 'px';
            
            if (fontTypeEl) fontTypeEl.value = state.fontType;
            if (pageContentEl) pageContentEl.className = state.fontType + ' text-xl leading-loose';
            
            // Load saved tafsir and translation selections
            if (tafsirSelectEl) tafsirSelectEl.value = state.selectedTafsir;
            if (translationSelectEl) translationSelectEl.value = state.selectedTranslation;
        },
        
        populateSelects() {
            const reciterSelect = document.getElementById('reciter-select');
            if (reciterSelect) {
                reciterSelect.innerHTML = '';
                state.reciters.forEach(r => {
                    const option = new Option(r.reciter_name, r.id);
                    reciterSelect.add(option);
                });
                reciterSelect.value = state.selectedReciter;
            }
            
            // Populate memorization surah selects
            const fromSurahSelect = document.getElementById('memorization-from-surah');
            const toSurahSelect = document.getElementById('memorization-to-surah');
            
            if (fromSurahSelect && toSurahSelect) {
                fromSurahSelect.innerHTML = '';
                toSurahSelect.innerHTML = '';
                
                state.surahs.forEach(surah => {
                    const option1 = new Option(surah.name_arabic, surah.id);
                    const option2 = new Option(surah.name_arabic, surah.id);
                    fromSurahSelect.add(option1);
                    toSurahSelect.add(option2);
                });
                
                fromSurahSelect.value = state.memorizationRange.fromSurah;
                toSurahSelect.value = state.memorizationRange.toSurah;
            }
        },
        
        async loadPage(pageNumber) {
            if (pageNumber < 1 || pageNumber > CONFIG.TOTAL_PAGES) return;
            
            console.log('Loading page:', pageNumber);
            
            // Show skeleton loading
            const loadingScreen = document.getElementById('loading-screen');
            const skeletonLoading = document.getElementById('skeleton-loading');
            const pageWrapper = document.getElementById('page-wrapper');
            
            if (loadingScreen) loadingScreen.style.display = 'none';
            if (skeletonLoading) skeletonLoading.classList.remove('hidden');
            if (pageWrapper) pageWrapper.classList.add('hidden');
            
            try {
                console.log('Fetching page data for page:', pageNumber);
                const verses = await API.getPageData(pageNumber);
                console.log('Received verses:', verses);
                
                if (!verses || verses.length === 0) {
                    throw new Error('No verses received from API');
                }
                
                state.pageData = verses;
                state.currentPage = pageNumber;
                
                localStorage.setItem('lastPage', pageNumber);
                
                this.renderPage();
                this.setupAudio();
                this.trackPageInKhatmah(pageNumber);
                
                console.log('Page loaded successfully with', verses.length, 'verses');
            } catch (error) {
                console.error('Error loading page:', error);
                document.getElementById('page-content').innerHTML = `
                    <div class="text-center p-8">
                        <i class="fas fa-exclamation-triangle text-4xl text-red-500 mb-4"></i>
                        <h3 class="text-lg font-bold mb-2">ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿµŸÅÿ≠ÿ©</h3>
                        <p class="text-sm text-gray-600 mb-4">${error.message}</p>
                        <div class="space-x-2">
                            <button onclick="App.loadPage(${pageNumber})" class="btn btn-primary">
                                <i class="fas fa-redo"></i> ÿ•ÿπÿßÿØÿ© ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ©
                            </button>
                            <button onclick="App.loadPage(1)" class="btn btn-secondary">
                                <i class="fas fa-home"></i> ÿßŸÑÿµŸÅÿ≠ÿ© ÿßŸÑÿ£ŸàŸÑŸâ
                            </button>
                        </div>
                    </div>
                `;
                this.showToast('ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿµŸÅÿ≠ÿ©', 'error');
            } finally {
                const skeletonLoading = document.getElementById('skeleton-loading');
                const pageWrapper = document.getElementById('page-wrapper');
                
                if (skeletonLoading) skeletonLoading.classList.add('hidden');
                if (pageWrapper) pageWrapper.classList.remove('hidden');
            }
        },
        
        renderPage() {
            const pageContent = document.getElementById('page-content');
            pageContent.innerHTML = '';
            
            console.log('Rendering page. PageData:', state.pageData);
            console.log('PageData length:', state.pageData ? state.pageData.length : 'null');
            console.log('Page content element:', pageContent);
            
            // Add debug message to page
            pageContent.innerHTML = '<div style="padding: 20px; background: yellow; color: black;">üîÑ ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ¢Ÿäÿßÿ™...</div>';
            
            if (!state.pageData || state.pageData.length === 0) {
                console.error('No page data available');
                pageContent.innerHTML = '<div class="text-center p-8"><p class="text-red-500">ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ®ŸäÿßŸÜÿßÿ™ ŸÑŸáÿ∞Ÿá ÿßŸÑÿµŸÅÿ≠ÿ©</p><button onclick="App.loadPage(1)" class="btn btn-primary mt-4">ÿ±ÿ¨Ÿàÿπ ŸÑŸÑÿµŸÅÿ≠ÿ© ÿßŸÑÿ£ŸàŸÑŸâ</button></div>';
                return;
            }
            
            // Clear the loading message
            pageContent.innerHTML = '';
            
            // Track surahs in current page
            state.currentSurahsInPage = [];
            let currentSurahId = null;
            
            // Store all words for memorization mode
            state.currentMemorizationWords = [];
            
            state.pageData.forEach(verse => {
                console.log('Processing verse:', verse);
                
                // Check if new surah starts
                if (verse.chapter_id !== currentSurahId) {
                    currentSurahId = verse.chapter_id;
                    const surah = state.surahs.find(s => s.id === currentSurahId);
                    
                    console.log('Found surah:', surah);
                    
                    if (surah) {
                        state.currentSurahsInPage.push(surah);
                        
                        // Add surah header
                        const surahHeader = document.createElement('div');
                        surahHeader.className = 'surah-header';
                        surahHeader.innerHTML = `
                            <h2>${surah.name_arabic}</h2>
                            ${surah.id !== 1 && surah.id !== 9 ? '<p class="basmala">ÿ®Ÿêÿ≥ŸíŸÖŸê ÿßŸÑŸÑŸéŸëŸáŸê ÿßŸÑÿ±ŸéŸëÿ≠ŸíŸÖŸéŸ∞ŸÜŸê ÿßŸÑÿ±ŸéŸëÿ≠ŸêŸäŸÖŸê</p>' : ''}
                        `;
                        pageContent.appendChild(surahHeader);
                        console.log('Added surah header');
                    }
                }
                
                const ayahSpan = document.createElement('span');
                ayahSpan.className = 'ayah';
                ayahSpan.dataset.verseKey = verse.verse_key;
                ayahSpan.dataset.text = verse.text_uthmani;
                
                console.log('Created ayah span for verse:', verse.verse_key);
                
                // Check if bookmarked
                if (state.bookmarks.some(b => b.verseKey === verse.verse_key)) {
                    ayahSpan.classList.add('bookmarked');
                }
                
                // Prepare for memorization mode - wrap each word
                if (state.memorizationMode) {
                    console.log('Memorization mode - processing words');
                    const words = verse.text_uthmani.split(' ');
                    words.forEach((word, wordIndex) => {
                        if (word.trim().length > 0) {
                            const cleanedWord = word.trim();
                            // Remove pure diacritics that are not words
                            const plainWord = this.convertToPlainText(cleanedWord);
                            
                            // Only add if it's an actual word (has Arabic letters)
                            if (this.isActualWord(plainWord)) {
                                state.currentMemorizationWords.push(cleanedWord);
                                const wordSpan = document.createElement('span');
                                wordSpan.className = 'ayah-word hidden'; // Always start hidden
                                wordSpan.textContent = cleanedWord + ' ';
                                wordSpan.dataset.word = cleanedWord;
                                wordSpan.dataset.plainWord = plainWord; // Store plain version
                                wordSpan.dataset.wordIndex = wordIndex;
                                ayahSpan.appendChild(wordSpan);
                            }
                        }
                    });
                    // Set first word to waiting after all words are created
                    setTimeout(() => {
                        const firstWord = ayahSpan.querySelector('.ayah-word');
                        if (firstWord && state.memorizationStats.currentWordIndex === 0) {
                            firstWord.classList.add('waiting');
                        }
                    }, 100);
                } else {
                    // Normal mode - display text directly with verse number
                    const verseText = verse.text_uthmani || verse.text_imlaei || verse.text || 'ŸÜÿµ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÅÿ±';
                    console.log('Adding verse text:', verseText.substring(0, 50) + '...');
                    
                    ayahSpan.innerHTML = verseText + ' ';
                    
                    console.log('Text added to ayah');
                }
                
                const numberSpan = document.createElement('span');
                numberSpan.className = 'verse-number';
                numberSpan.textContent = 'Ô¥ø' + (verse.verse_number || '?') + 'Ô¥æ';
                ayahSpan.appendChild(numberSpan);
                
                console.log('Number span added');
                
                ayahSpan.appendChild(document.createTextNode(' '));
                
                pageContent.appendChild(ayahSpan);
                console.log('Ayah added to page content. Total children:', pageContent.children.length);
            });
            
            // Update header
            const firstVerse = state.pageData[0];
            const firstSurah = state.surahs.find(s => s.id === firstVerse.chapter_id);
            
            document.getElementById('page-surah-name').textContent = firstSurah ? firstSurah.name_arabic : '';
            document.getElementById('page-juz').textContent = `ÿßŸÑÿ¨ÿ≤ÿ° ${firstVerse.juz_number || ''}`;
            document.getElementById('page-number').textContent = `ÿµŸÅÿ≠ÿ© ${state.currentPage}`;
            
            // Initialize memorization stats if in memorization mode
            if (state.memorizationMode) {
                state.memorizationStats.totalWords = state.currentMemorizationWords.length;
                state.memorizationStats.currentWordIndex = 0;
                this.updateMemorizationDisplay();
                
                // ÿ™ŸÖŸäŸäÿ≤ ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑÿ£ŸàŸÑŸâ ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±
                const firstWordElement = document.querySelector('.ayah-word');
                if (firstWordElement) {
                    firstWordElement.classList.add('waiting');
                }
                
                console.log(`Memorization mode initialized with ${state.memorizationStats.totalWords} words`);
            }
            
            console.log('PAGE RENDER COMPLETED. Final innerHTML length:', pageContent.innerHTML.length);
            console.log('Final page content preview:', pageContent.innerHTML.substring(0, 200) + '...');
        },
        
        // Ÿàÿ∂ÿπ ÿßŸÑÿ™ÿ≠ŸÅŸäÿ∏ - ŸÖÿ≠ÿ≥ŸëŸÜ ŸÖÿπ Ÿàÿßÿ¨Ÿáÿ© ŸÖŸÜŸÅÿµŸÑÿ© - ÿ®ÿØÿ° ŸÖÿ®ÿßÿ¥ÿ±
        startMemorizationMode(type = 'page') {
            state.memorizationMode = true;
            state.memorizationRange.type = type;
            
            // ÿ•ÿ∫ŸÑÿßŸÇ ÿ£Ÿä ŸÑŸàÿ≠ÿ© ŸÖŸÅÿ™Ÿàÿ≠ÿ© ÿ£ŸàŸÑÿßŸã
            document.querySelectorAll('.panel.visible').forEach(panel => {
                panel.classList.remove('visible');
            });
            
            // ÿßŸÑÿ™ÿ®ÿØŸäŸÑ ÿ•ŸÑŸâ ÿßŸÑŸàÿßÿ¨Ÿáÿ© ÿßŸÑŸÖŸÜŸÅÿµŸÑÿ© ŸÖÿ®ÿßÿ¥ÿ±ÿ©
            this.switchToMemorizationInterface();
            
            // ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ≠ŸÅÿ∏
            this.resetMemorizationStats();
            
            // ÿ•ÿπÿßÿØÿ© ÿπÿ±ÿ∂ ÿßŸÑÿµŸÅÿ≠ÿ© ŸÖÿπ Ÿàÿ∂ÿπ ÿßŸÑÿ≠ŸÅÿ∏
            this.renderMemorizationPage();
            
            // ÿ®ÿØÿ° ÿßŸÑÿ™ÿπÿ±ŸÅ ÿπŸÑŸâ ÿßŸÑÿµŸàÿ™ ÿπÿ®ÿ± AssemblyAI
            startAssemblyAiStreaming();
            
            this.showToast('ÿ®ÿØÿ£ Ÿàÿ∂ÿπ ÿßŸÑÿ≠ŸÅÿ∏ - ÿßÿ®ÿØÿ£ ÿ®ÿßŸÑÿ™ŸÑÿßŸàÿ©', 'success');
        },
        
        // ÿßŸÑÿ™ÿ®ÿØŸäŸÑ ÿ•ŸÑŸâ Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑÿ≠ŸÅÿ∏ ÿßŸÑŸÖŸÜŸÅÿµŸÑÿ©
        switchToMemorizationInterface() {
            const mainInterface = document.getElementById('main-reading-interface');
            const memorizationInterface = document.getElementById('memorization-interface');
            
            console.log('Switching to memorization interface...');
            console.log('Main interface found:', !!mainInterface);
            console.log('Memorization interface found:', !!memorizationInterface);
            
            if (mainInterface && memorizationInterface) {
                mainInterface.classList.add('hidden');
                memorizationInterface.classList.remove('hidden');
                
                // ÿ™ÿ≠ÿØŸäÿ´ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸáŸäÿØÿ±
                this.updateMemorizationHeader();
                
                console.log('Successfully switched to memorization interface');
            } else {
                console.error('Could not find memorization interface elements');
                console.error('Main interface element:', mainInterface);
                console.error('Memorization interface element:', memorizationInterface);
                this.showToast('ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ŸÅÿπŸäŸÑ Ÿàÿ∂ÿπ ÿßŸÑÿ≠ŸÅÿ∏', 'error');
            }
        },
        
        // ÿßŸÑÿÆÿ±Ÿàÿ¨ ŸÖŸÜ Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑÿ≠ŸÅÿ∏
        exitMemorizationInterface() {
            const mainInterface = document.getElementById('main-reading-interface');
            const memorizationInterface = document.getElementById('memorization-interface');
            
            console.log('Exiting memorization interface...');
            
            if (memorizationInterface) {
                memorizationInterface.classList.add('hidden');
            }
            
            if (mainInterface) {
                mainInterface.classList.remove('hidden');
            }
            
            // ÿ•ŸäŸÇÿßŸÅ Ÿàÿ∂ÿπ ÿßŸÑÿ≠ŸÅÿ∏
            this.stopMemorizationMode();
        },
        
        // ÿ™ŸÖŸÉŸäŸÜ ÿßŸÑÿ™ŸÜŸÇŸÑ ÿ®ŸäŸÜ ÿßŸÑÿµŸÅÿ≠ÿßÿ™ ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑÿ≠ŸÅÿ∏
        navigatePageInMemorization(direction) {
            const newPage = state.currentPage + direction;
            if (newPage >= 1 && newPage <= CONFIG.TOTAL_PAGES) {
                // ÿ•ŸäŸÇÿßŸÅ ÿßŸÑÿ™ÿπÿ±ŸÅ ÿπŸÑŸâ ÿßŸÑÿµŸàÿ™ ŸÖÿ§ŸÇÿ™ÿßŸã
                stopAssemblyAiStreaming();
                if (state.speechRecognition) {
                    state.speechRecognition.stop();
                }
                
                // ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ≠ŸÅÿ∏ ŸÑŸÑÿµŸÅÿ≠ÿ© ÿßŸÑÿ¨ÿØŸäÿØÿ©
                this.resetMemorizationStats();
                
                // ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿµŸÅÿ≠ÿ© ÿßŸÑÿ¨ÿØŸäÿØÿ©
                this.loadPage(newPage).then(() => {
                    // ÿ•ÿπÿßÿØÿ© ÿ®ÿØÿ° Ÿàÿ∂ÿπ ÿßŸÑÿ≠ŸÅÿ∏ ŸÖÿπ ÿßŸÑÿµŸÅÿ≠ÿ© ÿßŸÑÿ¨ÿØŸäÿØÿ©
                    this.renderMemorizationPage();
                    
                    // ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ•ÿÆŸÅÿßÿ° ÿ¨ŸÖŸäÿπ ÿßŸÑŸÉŸÑŸÖÿßÿ™
                    setTimeout(() => {
                        const wordElements = document.querySelectorAll('.ayah-word');
                        const memWordElements = document.querySelectorAll('#memorization-page-content .ayah-word');
                        const elements = memWordElements.length > 0 ? memWordElements : wordElements;
                        
                        elements.forEach((word, index) => {
                            word.classList.remove('revealed', 'waiting', 'correct', 'incorrect');
                            word.classList.add('hidden');
                            
                            // ÿ™ÿπŸäŸäŸÜ ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑÿ£ŸàŸÑŸâ ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±
                            if (index === 0) {
                                word.classList.add('waiting');
                            }
                        });
                        
                        // ÿ•ÿπÿßÿØÿ© ÿ®ÿØÿ° ÿßŸÑÿ™ÿπÿ±ŸÅ ÿπŸÑŸâ ÿßŸÑÿµŸàÿ™ ÿπÿ®ÿ± AssemblyAI
                        startAssemblyAiStreaming();
                    }, 300);
                });
            }
        },
        
        // ÿ™ÿ≠ÿØŸäÿ´ ŸáŸäÿØÿ± ÿßŸÑÿ≠ŸÅÿ∏
        updateMemorizationHeader() {
            const surahNameEl = document.getElementById('memorization-surah-name');
            const rangeEl = document.getElementById('memorization-range');
            
            if (state.currentSurahsInPage.length > 0) {
                const firstSurah = state.currentSurahsInPage[0];
                if (surahNameEl) surahNameEl.textContent = firstSurah.name_arabic;
                if (rangeEl) rangeEl.textContent = `ÿµŸÅÿ≠ÿ© ${state.currentPage}`;
            }
        },
        
        // ÿπÿ±ÿ∂ ÿµŸÅÿ≠ÿ© ÿßŸÑÿ≠ŸÅÿ∏
        renderMemorizationPage() {
            const memorizationContent = document.getElementById('memorization-page-content');
            const mainContent = document.getElementById('page-content');
            
            if (memorizationContent && mainContent) {
                // ŸÜÿ≥ÿÆ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ŸÖŸÜ ÿßŸÑÿµŸÅÿ≠ÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©
                memorizationContent.innerHTML = mainContent.innerHTML;
                
                // ÿ™ÿ∑ÿ®ŸäŸÇ Ÿàÿ∂ÿπ ÿßŸÑÿ≠ŸÅÿ∏
                document.body.classList.add('memorization-mode');
                
                // ÿ•ÿπÿØÿßÿØ ÿßŸÑŸÉŸÑŸÖÿßÿ™ ŸÑŸÑÿ≠ŸÅÿ∏
                this.setupMemorizationWords();
                
                // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿπÿ±ÿ∂
                this.updateMemorizationProgressDisplay();
            }
        },
        
        // ÿ•ÿπÿØÿßÿØ ŸÉŸÑŸÖÿßÿ™ ÿßŸÑÿ≠ŸÅÿ∏
        setupMemorizationWords() {
            const memorizationContent = document.getElementById('memorization-page-content');
            const wordElements = memorizationContent.querySelectorAll('.ayah-word');
            
            state.currentMemorizationWords = [];
            
            wordElements.forEach((word, index) => {
                const wordText = word.dataset.text || word.textContent.trim();
                state.currentMemorizationWords.push(wordText);
                
                // ÿ•ÿÆŸÅÿßÿ° ÿ¨ŸÖŸäÿπ ÿßŸÑŸÉŸÑŸÖÿßÿ™ ŸÅŸä ÿßŸÑÿ®ÿØÿßŸäÿ©
                word.classList.add('hidden');
                word.classList.remove('revealed', 'waiting');
                
                // ÿ™ŸÖŸäŸäÿ≤ ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑÿ£ŸàŸÑŸâ
                if (index === 0) {
                    word.classList.add('waiting');
                }
            });
            
            // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™
            state.memorizationStats.totalWords = state.currentMemorizationWords.length;
            state.memorizationStats.currentWordIndex = 0;
            
            console.log(`Memorization initialized with ${state.memorizationStats.totalWords} words`);
        },
        
        // ÿ™ÿ≠ÿØŸäÿ´ ÿπÿ±ÿ∂ ÿßŸÑÿ™ŸÇÿØŸÖ ŸÅŸä Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑÿ≠ŸÅÿ∏
        updateMemorizationProgressDisplay() {
            // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿØÿßÿ¶ÿ±ÿ© ÿßŸÑŸÖÿ¶ŸàŸäÿ©
            const progressRing = document.getElementById('memorization-progress-ring');
            const progressPercent = document.getElementById('memorization-progress-percent');
            
            if (progressRing && progressPercent) {
                const progress = state.memorizationStats.totalWords > 0 
                    ? (state.memorizationStats.currentWordIndex / state.memorizationStats.totalWords) * 100 
                    : 0;
                const circumference = 2 * Math.PI * 26; // radius = 26
                const strokeDashoffset = circumference - (progress / 100) * circumference;
                
                progressRing.style.strokeDasharray = circumference;
                progressRing.style.strokeDashoffset = strokeDashoffset;
                progressPercent.textContent = Math.round(progress) + '%';
            }
            
            // ÿ™ÿ≠ÿØŸäÿ´ ÿ¥ÿ±Ÿäÿ∑ ÿßŸÑÿ™ŸÇÿØŸÖ ŸÅŸä ÿßŸÑŸÅŸàÿ™ÿ±
            const progressBarFooter = document.getElementById('memorization-progress-bar-footer');
            if (progressBarFooter) {
                const progress = state.memorizationStats.totalWords > 0 
                    ? (state.memorizationStats.currentWordIndex / state.memorizationStats.totalWords) * 100 
                    : 0;
                progressBarFooter.style.width = progress + '%';
            }
            
            // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÜÿµŸàÿµ
            const progressText = document.getElementById('memorization-progress-text');
            const totalText = document.getElementById('memorization-total-text');
            const accuracyEl = document.getElementById('memorization-accuracy');
            const errorsCountEl = document.getElementById('memorization-errors-count');
            
            if (progressText) {
                progressText.textContent = this.convertToArabicNumbers(state.memorizationStats.currentWordIndex);
            }
            if (totalText) {
                totalText.textContent = this.convertToArabicNumbers(state.memorizationStats.totalWords);
            }
            
            // ÿ≠ÿ≥ÿßÿ® ÿßŸÑÿØŸÇÿ©
            if (accuracyEl) {
                const accuracy = state.memorizationStats.totalWords > 0 
                    ? Math.round((state.memorizationStats.correctWords / (state.memorizationStats.correctWords + state.memorizationStats.incorrectWords)) * 100) || 0
                    : 0;
                accuracyEl.textContent = this.convertToArabicNumbers(accuracy) + '%';
                
                // ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑŸÑŸàŸÜ ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿßŸÑÿØŸÇÿ©
                if (accuracy >= 90) {
                    accuracyEl.className = 'font-bold text-green-300';
                } else if (accuracy >= 75) {
                    accuracyEl.className = 'font-bold text-yellow-300';
                } else {
                    accuracyEl.className = 'font-bold text-red-300';
                }
            }
            
            // ÿ™ÿ≠ÿØŸäÿ´ ÿπÿØÿØ ÿßŸÑÿ£ÿÆÿ∑ÿßÿ°
            if (errorsCountEl) {
                errorsCountEl.textContent = this.convertToArabicNumbers(state.memorizationStats.errors.length);
            }
            
            // ÿ™ÿ≠ÿØŸäÿ´ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ£ÿÆÿ∑ÿßÿ°
            this.updateErrorsList();
        },
        
        // ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑÿ£ÿ±ŸÇÿßŸÖ ÿ•ŸÑŸâ ÿπÿ±ÿ®Ÿäÿ©
        convertToArabicNumbers(num) {
            const arabicNumbers = ['Ÿ†', 'Ÿ°', 'Ÿ¢', 'Ÿ£', 'Ÿ§', 'Ÿ•', 'Ÿ¶', 'Ÿß', 'Ÿ®', 'Ÿ©'];
            return String(num).replace(/[0-9]/g, function(match) {
                return arabicNumbers[parseInt(match)];
            });
        },
        
        stopMemorizationMode() {
            state.memorizationMode = false;
            document.body.classList.remove('memorization-mode');
            
            // Stop AssemblyAI streaming
            stopAssemblyAiStreaming();
            
            // Also stop old speech recognition if still running
            if (state.speechRecognition) {
                state.speechRecognition.stop();
                state.speechRecognition = null;
            }
            
            document.querySelector('.recording-indicator')?.classList.remove('active');
            
            // ÿπÿ±ÿ∂ ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ŸÜŸáÿßÿ¶Ÿäÿ©
            this.showMemorizationResults();
            
            // ÿßŸÑÿπŸàÿØÿ© ÿ•ŸÑŸâ ÿßŸÑŸàÿßÿ¨Ÿáÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ© ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÅŸä Ÿàÿßÿ¨Ÿáÿ© ŸÖŸÜŸÅÿµŸÑÿ©
            const memorizationInterface = document.getElementById('memorization-interface');
            if (!memorizationInterface.classList.contains('hidden')) {
                this.exitMemorizationInterface();
            } else {
                // ÿ•ÿπÿßÿØÿ© ÿπÿ±ÿ∂ ÿßŸÑÿµŸÅÿ≠ÿ© ÿ®ÿØŸàŸÜ Ÿàÿ∂ÿπ ÿßŸÑÿ≠ŸÅÿ∏
                this.renderPage();
            }
        },
        
        resetMemorizationStats() {
            state.memorizationStats = {
                totalWords: 0,
                correctWords: 0,
                incorrectWords: 0,
                currentWordIndex: 0,
                errors: [],
                accuracy: 0
            };
            
            this.updateMemorizationDisplay();
        },
        
// üö´ OLD SYSTEM DISABLED: Performance-First Speech Recognition Architecture
        // This function has been replaced by the new Hugging Face API-based system
        /*
        initSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window || 'SpeechRecognition' in window)) {
                this.showToast('ÿßŸÑŸÖÿ™ÿµŸÅÿ≠ ŸÑÿß ŸäÿØÿπŸÖ ÿßŸÑÿ™ÿπÿ±ŸÅ ÿπŸÑŸâ ÿßŸÑÿµŸàÿ™', 'error');
                return;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            state.speechRecognition = new SpeechRecognition();
            
            // üéØ Ultra-Enhanced Recognition Settings for Maximum Performance
            state.speechRecognition.lang = 'ar-SA';
            state.speechRecognition.continuous = true;
            state.speechRecognition.interimResults = true;
            state.speechRecognition.maxAlternatives = 10; // Optimized: reduced from 50 to 10 for better performance
            
            // üî• Performance Optimization Settings
            if (state.speechRecognition.speechSynthesis) {
                state.speechRecognition.speechSynthesis.rate = 3.0; // Ultra-maximum speed for fastest recitation
            }
            
            // üéõÔ∏è Ultra-high sensitivity settings with performance optimization
            state.speechRecognition.grammars = state.speechRecognition.grammars || [];
            
            // üß† Initialize Performance Caches
            this.initPerformanceCaches();
            
            // ‚ö° Initialize Background Processing
            this.initBackgroundProcessing();
            
            // ‚ö° Ultra-Minimal Timeouts for Immediate Response (Performance Optimized)
            let processingTimeout = null;
            let lastFinalTranscript = '';
            let interimProcessingTimeout = null;
            let lastInterimProcessed = '';
            let immediateProcessingTimeout = null;
            let performanceStartTime = performance.now();
            let recognitionCount = 0;
            
            // üéØ Performance Monitoring
            const performanceMetrics = {
                avgProcessingTime: 0,
                totalRecognitions: 0,
                successfulMatches: 0,
                cacheHits: 0
            };
            
            // üöÄ Ultra-Performance onresult Handler with Improved Interim Processing
            state.speechRecognition.onresult = (event) => {
                const processingStart = performance.now();
                recognitionCount++;
                performanceMetrics.totalRecognitions++;
                
                let interimTranscript = '';
                let finalTranscript = '';
                
                // ‚ö° Process all alternatives, not just the first one
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const result = event.results[i];
                    
                    if (result.isFinal) {
                        // üéØ Process multiple alternatives for better accuracy
                        let bestMatch = null;
                        let bestScore = 0;
                        
                        for (let j = 0; j < Math.min(result.length, 3); j++) {
                            const transcript = result[j].transcript.trim();
                            const confidence = result[j].confidence;
                            
                            if (transcript) {
                                const score = this.evaluateTranscriptQuality(transcript, confidence);
                                if (score > bestScore) {
                                    bestMatch = { transcript, confidence };
                                    bestScore = score;
                                }
                            }
                        }
                        
                        if (bestMatch) {
                            finalTranscript = bestMatch.transcript;
                            this.processSequentialText(finalTranscript, bestMatch.confidence, processingStart);
                        }
                    } else {
                        // üîç Improved interim handling - treat as complete unit
                        const transcript = result[0].transcript.trim();
                        const confidence = result[0].confidence;
                        
                        if (confidence > 0.4 && transcript.length > 0) {
                            interimTranscript = transcript;
                            
                            // üéØ Process interim as sequence, not individual words
                            clearTimeout(interimProcessingTimeout);
                            interimProcessingTimeout = setTimeout(() => {
                                this.processInterimSequence(transcript, confidence);
                            }, 100); // Slightly longer delay for better interim processing
                        }
                    }
                }
                
                // üìä Performance Metrics Update
                const processingTime = performance.now() - processingStart;
                performanceMetrics.avgProcessingTime = 
                    (performanceMetrics.avgProcessingTime * (performanceMetrics.totalRecognitions - 1) + processingTime) / performanceMetrics.totalRecognitions;
                
                // üîç Show enhanced interim feedback
                if (interimTranscript && !finalTranscript) {
                    this.showEnhancedInterimFeedback(interimTranscript, processingTime);
                }
            };
            
            state.speechRecognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                
                if (event.error === 'no-speech') {
                    this.showToast('ŸÑŸÖ Ÿäÿ™ŸÖ ÿ≥ŸÖÿßÿπ ÿµŸàÿ™ Ÿàÿßÿ∂ÿ≠', 'warning');
                } else if (event.error === 'network') {
                    this.showToast('ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿßÿ™ÿµÿßŸÑ', 'error');
                } else if (event.error === 'not-allowed') {
                    this.showToast('Ÿäÿ¨ÿ® ÿßŸÑÿ≥ŸÖÿßÿ≠ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÖŸäŸÉÿ±ŸàŸÅŸàŸÜ', 'error');
                    return;
                } else {
                    this.showToast(`ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ™ÿπÿ±ŸÅ ÿπŸÑŸâ ÿßŸÑÿµŸàÿ™: ${event.error}`, 'error');
                }
                
                // Ultra-fast restart after error for continuous capture
                setTimeout(() => {
                    if (state.memorizationMode && state.speechRecognition) {
                        try {
                            state.speechRecognition.start();
                            console.log('Speech recognition restarted after error for ultra-fast continuous capture');
                        } catch (e) {
                            // Only log actual errors, not "already started" errors
                            if (!e.message.includes('already started')) {
                                console.warn('Could not restart speech recognition after error:', e.message);
                                // Try one more time with slightly longer delay for real errors only
                                setTimeout(() => {
                                    try {
                                        if (state.speechRecognition && state.memorizationMode) {
                                            state.speechRecognition.start();
                                        }
                                    } catch (e2) {
                                        if (!e2.message.includes('already started')) {
                                            console.error('Final restart attempt failed:', e2.message);
                                        }
                                    }
                                }, 300);
                            }
                        }
                    }
                }, 200); // Slightly longer delay after error
            };
            
            state.speechRecognition.onstart = () => {
                console.log('Speech recognition started successfully');
                const indicator = document.querySelector('.recording-indicator');
                if (indicator) indicator.classList.add('active');
                // Speech feedback disabled per user request
            };
            
            state.speechRecognition.onend = () => {
                console.log('Speech recognition ended - restarting immediately for continuous capture');
                const indicator = document.querySelector('.recording-indicator');
                if (indicator) indicator.classList.remove('active');
                
                // Ultra-fast restart for continuous ultra-responsive recognition
                if (state.memorizationMode && state.speechRecognition) {
                    setTimeout(() => {
                        try {
                            // Check if recognition is not already running
                            if (state.speechRecognition && state.memorizationMode) {
                                state.speechRecognition.start();
                                console.log('Speech recognition restarted for continuous ultra-fast capture');
                            }
                        } catch (e) {
                            // Only log the error if it's not the "already started" error
                            if (!e.message.includes('already started')) {
                                console.warn('Could not restart immediately:', e.message);
                                // Try again with longer delay only for actual errors
                                setTimeout(() => {
                                    try {
                                        if (state.speechRecognition && state.memorizationMode) {
                                            state.speechRecognition.start();
                                        }
                                    } catch (e2) {
                                        if (!e2.message.includes('already started')) {
                                            console.warn('Second restart attempt failed:', e2.message);
                                        }
                                    }
                                }, 100);
                            }
                        }
                    }, 50); // Very fast restart
                }
            };
            
            // Start recognition with better error handling
            try {
                state.speechRecognition.start();
                this.showToast('ÿ®ÿØÿ£ ÿßŸÑÿ™ÿπÿ±ŸÅ ÿπŸÑŸâ ÿßŸÑÿµŸàÿ™ - ÿßÿ®ÿØÿ£ ÿ®ÿßŸÑÿ™ŸÑÿßŸàÿ©', 'success');
            } catch (error) {
                console.error('Could not start speech recognition:', error);
                this.showToast('ŸÅÿ¥ŸÑ ŸÅŸä ÿ®ÿØÿ° ÿßŸÑÿ™ÿπÿ±ŸÅ ÿπŸÑŸâ ÿßŸÑÿµŸàÿ™', 'error');
            }
        },
        */
        // End of disabled old speech recognition system

        restartSpeechRecognition() {
            try {
                if (state.speechRecognition && state.memorizationMode) {
                    state.speechRecognition.start();
                }
            } catch (error) {
                console.error('Error restarting speech recognition:', error);
            }
        },
        
        // üß† Performance Caches Initialization
        initPerformanceCaches() {
            // üó∫Ô∏è Initialize Word Recognition Cache
            if (!this.wordRecognitionCache) {
                this.wordRecognitionCache = new Map();
            }
            
            // üöÄ Initialize Pattern Cache for Quranic Letters
            if (!this.patternCache) {
                this.patternCache = new Map();
            }
            
            // üéØ Initialize Similarity Calculation Cache
            if (!this.similarityCache) {
                this.similarityCache = new Map();
            }
            
            // üî• Pre-load Common Quranic Words for Ultra-Fast Access
            this.preloadCommonQuranicWords();
            
            console.log('üß† Performance caches initialized for ultra-fast recognition');
        },
        
        // ‚ö° Background Processing Initialization
        initBackgroundProcessing() {
            // üîÑ Initialize background processing queues
            this.processingQueue = [];
            this.isProcessingQueue = false;
            
            // üîç Initialize recognition state tracking
            this.recognitionState = {
                lastProcessingTime: 0,
                consecutiveMatches: 0,
                adaptiveThreshold: 0.7,
                currentAccuracy: 1.0
            };
            
            console.log('‚ö° Background processing engine initialized');
        },
        
        // üöÄ Pre-load Common Quranic Words
        preloadCommonQuranicWords() {
            const commonQuranicWords = [
                // üïãÔ∏è Most Common Words
                'ÿßŸÑŸÑŸá', 'ÿßŸÑÿ±ÿ≠ŸÖŸÜ', 'ÿßŸÑÿ±ÿ≠ŸäŸÖ', 'ÿ±ÿ®', 'ÿßŸÑÿπÿßŸÑŸÖŸäŸÜ',
                'ÿßŸÑÿ≠ŸÖÿØ', 'ŸÖÿßŸÑŸÉ', 'ŸäŸàŸÖ', 'ÿßŸÑÿØŸäŸÜ', 'ÿ•ŸäÿßŸÉ',
                'ŸÜÿπÿ®ÿØ', 'ŸÜÿ≥ÿ™ÿπŸäŸÜ', 'ÿßŸáÿØŸÜÿß', 'ÿßŸÑÿµÿ±ÿßÿ∑',
                'ÿßŸÑŸÖÿ≥ÿ™ŸÇŸäŸÖ', 'ÿßŸÑÿ∞ŸäŸÜ', 'ÿ£ŸÜÿπŸÖÿ™', 'ÿπŸÑŸäŸáŸÖ',
                'ÿ®ÿ≥ŸÖ', 'ŸàŸÑÿß', 'ŸÑŸäÿ≥', 'ÿßŸÑÿ∂ÿßŸÑŸäŸÜ',
                // üìú Disconnected Letters
                'ÿßŸÑŸÖ', 'ÿßŸÑŸÖÿµ', 'ÿßŸÑÿ±', 'ÿßŸÑŸÖÿ±', 'ŸÉŸáŸäÿπÿµ',
                'ÿ∑Ÿá', 'ÿ∑ÿ≥ŸÖ', 'Ÿäÿ≥', 'ÿµ', 'ŸÇ', 'ŸÜ', 'ÿ≠ŸÖ'
            ];
            
            // üéÜ Pre-calculate normalized forms and cache them
            commonQuranicWords.forEach(word => {
                const normalized = this.normalizeQuranText(word);
                const plain = this.convertToPlainText(word);
                const plainNormalized = this.normalizeQuranText(plain);
                
                // üó∫Ô∏è Cache all variations
                this.wordRecognitionCache.set(word, {
                    original: word,
                    normalized: normalized,
                    plain: plain,
                    plainNormalized: plainNormalized,
                    commonVariations: this.generateCommonVariations(word)
                });
            });
            
            console.log(`üéÜ Pre-loaded ${commonQuranicWords.length} common Quranic words for ultra-fast recognition`);
        },
        
        // üîÑ Generate Common Pronunciation Variations
        generateCommonVariations(word) {
            const variations = new Set();
            const normalized = this.normalizeQuranText(word);
            
            // üî• Add common pronunciation patterns
            variations.add(normalized);
            variations.add(normalized.replace(/ÿßŸÑ/g, 'ŸÑ')); // ÿßŸÑ -> ŸÑ
            variations.add(normalized.replace(/Ÿá$/g, 'ÿ©')); // Final Ÿá -> ÿ©
            variations.add(normalized.replace(/Ÿä$/g, 'Ÿâ')); // Final Ÿä -> Ÿâ
            
            return Array.from(variations);
        },
        
        // üöÄ Ultra-Fast Quranic Speech Processing
        processQuranicSpeechUltraFast(transcript, confidence, processingStart) {
            console.log(`üöÄ Ultra-fast processing: "${transcript}" with confidence: ${confidence}`);
            
            // ‚ö° Cache Check for Ultra-Fast Recognition
            const cacheKey = transcript.toLowerCase().trim();
            if (this.wordRecognitionCache.has(cacheKey)) {
                console.log('üöÄ Cache hit! Ultra-fast word recognition');
                const cachedWord = this.wordRecognitionCache.get(cacheKey);
                this.processSequentialWord(cachedWord.original);
                return;
            }
            
            // üî• Update display immediately for responsiveness
            const lastHeardEl = document.getElementById('last-heard-word');
            if (lastHeardEl) {
                lastHeardEl.textContent = transcript;
            }
            
            // üéØ Process Special Quranic Patterns First (Highest Priority)
            if (this.processSpecialQuranicPatterns(transcript)) {
                console.log('üéØ Special pattern processed ultra-fast');
                return;
            }
            
            // ‚ö° Split and process individual words for ultra-fast recognition
            const words = transcript.trim().split(/\s+/);
            words.forEach(word => {
                if (word && word.length > 0) {
                    this.processSequentialWordUltraFast(word.trim());
                }
            });
            
            // üìä Performance metrics
            const totalTime = performance.now() - processingStart;
            console.log(`üìä Ultra-fast processing completed in ${totalTime.toFixed(2)}ms`);
        },
        
        // ‚ö° Ultra-Fast Sequential Word Processing
        processSequentialWordUltraFast(spokenWord) {
            // üöÄ Ultra-short duplicate filtering for maximum responsiveness
            const now = Date.now();
            if (this.lastProcessedWord && this.lastProcessedWord.word === spokenWord && 
                (now - this.lastProcessedWord.time) < 100) { // Reduced to 100ms for ultra responsiveness
                console.log('‚ö° Skipping ultra-recent duplicate word:', spokenWord);
                return;
            }
            
            this.lastProcessedWord = { word: spokenWord, time: now };
            
            // üî• Process the word with ultra-fast algorithms
            this.checkSingleWordUltraFast(spokenWord);
        },
        
        // üöÄ Ultra-Fast Single Word Checking
        checkSingleWordUltraFast(spokenWord) {
            if (state.memorizationStats.currentWordIndex >= state.currentMemorizationWords.length) {
                console.log('üèÅ Memorization completed - all words processed');
                return;
            }
            
            const currentCorrectWord = state.currentMemorizationWords[state.memorizationStats.currentWordIndex];
            
            // ‚ö° Ultra-fast word comparison with cache optimization
            const isCorrect = this.compareWordsUltraFast(spokenWord, currentCorrectWord);
            
            if (isCorrect) {
                console.log(`‚úÖ Ultra-fast match found: "${spokenWord}" ‚Üí "${currentCorrectWord}"`);
                this.processCorrectWordUltraFast(currentCorrectWord);
            } else {
                console.log(`‚ùå No ultra-fast match: "${spokenWord}" vs "${currentCorrectWord}"`);
                this.processIncorrectWordUltraFast(spokenWord, currentCorrectWord);
            }
        },
        
        // üöÄ Ultra-Fast Word Comparison
        compareWordsUltraFast(spoken, correct) {
            // ‚ö° Cache lookup first
            const cacheKey = `${spoken}:${correct}`;
            if (this.similarityCache.has(cacheKey)) {
                return this.similarityCache.get(cacheKey);
            }
            
            // üî• Use existing enhanced comparison but with ultra-fast caching
            const result = this.compareWordsTajweed(spoken, correct);
            
            // üó∫Ô∏è Cache the result for future ultra-fast lookups
            this.similarityCache.set(cacheKey, result);
            
            return result;
        },
        
        // ‚úÖ Enhanced Correct Word Processing with Visual Feedback
        processCorrectWordUltraFast(correctWord) {
            // üéÜ Update statistics immediately
            state.memorizationStats.correctWords++;
            state.memorizationStats.currentWordIndex++;
            
            // ‚ö° Update accuracy instantly
            state.memorizationStats.accuracy = 
                (state.memorizationStats.correctWords / (state.memorizationStats.correctWords + state.memorizationStats.incorrectWords)) * 100;
            
            // üöÄ Enhanced UI updates with visual feedback
            this.updateWordUIWithEnhancedFeedback(correctWord, true);
            this.updateMemorizationDisplayUltraFast();
            
            // üéØ Enhanced success feedback
            this.showSequenceFeedback('‚úÖ ÿµÿ≠Ÿäÿ≠!', '#22c55e', 600);
            
            // üîç Highlight next word for guidance
            this.highlightNextTargetWord();
        },
        
        // ‚ùå Enhanced Incorrect Word Processing with Visual Feedback
        processIncorrectWordUltraFast(spokenWord, correctWord) {
            // üìà Update error statistics
            state.memorizationStats.incorrectWords++;
            state.memorizationStats.errors.push({
                spoken: spokenWord,
                correct: correctWord,
                timestamp: new Date().toISOString()
            });
            
            // ‚ö° Update accuracy
            state.memorizationStats.accuracy = 
                (state.memorizationStats.correctWords / (state.memorizationStats.correctWords + state.memorizationStats.incorrectWords)) * 100;
            
            // üöÄ Enhanced error feedback with visual indicators
            this.showEnhancedErrorFeedback(spokenWord, correctWord);
            this.updateMemorizationDisplayUltraFast();
        },
        
        // üéÜ Enhanced UI Word Update with Visual Feedback
        updateWordUIWithEnhancedFeedback(word, isCorrect) {
            const wordElements = document.querySelectorAll('.ayah-word');
            const currentIndex = state.memorizationStats.currentWordIndex - 1; // -1 because we already incremented
            
            if (wordElements[currentIndex]) {
                const element = wordElements[currentIndex];
                
                // Remove previous states
                element.classList.remove('waiting', 'hidden', 'current-target');
                
                // Add result state with animation
                element.classList.add(isCorrect ? 'correct' : 'incorrect', 'revealed');
                
                // Add temporary highlight animation
                element.style.transform = 'scale(1.1)';
                element.style.transition = 'all 0.3s ease';
                
                setTimeout(() => {
                    element.style.transform = 'scale(1)';
                }, 300);
            }
            
            // ‚ö° Set next word as waiting with visual indication
            if (wordElements[state.memorizationStats.currentWordIndex]) {
                const nextElement = wordElements[state.memorizationStats.currentWordIndex];
                nextElement.classList.add('waiting', 'current-target');
                nextElement.style.border = '2px solid #3b82f6';
                nextElement.style.borderRadius = '4px';
            }
        },
        
        // üîç Highlight Next Target Word
        highlightNextTargetWord() {
            const wordElements = document.querySelectorAll('.ayah-word');
            
            // Remove previous highlights
            wordElements.forEach(el => {
                el.classList.remove('current-target');
                el.style.border = '';
                el.style.borderRadius = '';
            });
            
            // Highlight current target
            if (state.memorizationStats.currentWordIndex < wordElements.length) {
                const targetElement = wordElements[state.memorizationStats.currentWordIndex];
                targetElement.classList.add('current-target');
                targetElement.style.border = '2px solid #10b981';
                targetElement.style.borderRadius = '4px';
                targetElement.style.backgroundColor = 'rgba(16, 185, 129, 0.1)';
                
                // Scroll into view if needed
                targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        },
        
        // üî• Enhanced Error Feedback with Visual Indicators
        showEnhancedErrorFeedback(spoken, correct) {
            // Show in feedback area
            this.showSequenceFeedback(`‚ùå "‚Äé${spoken}‚Äé" ‚Üí "‚Äé${correct}‚Äé"`, '#ef4444', 1500);
            
            // Highlight the incorrect word in red temporarily
            const currentIndex = state.memorizationStats.currentWordIndex;
            const wordElements = document.querySelectorAll('.ayah-word');
            
            if (wordElements[currentIndex]) {
                const element = wordElements[currentIndex];
                const originalBg = element.style.backgroundColor;
                
                element.style.backgroundColor = 'rgba(239, 68, 68, 0.2)';
                element.style.border = '2px solid #ef4444';
                
                setTimeout(() => {
                    element.style.backgroundColor = originalBg;
                    element.style.border = '2px solid #10b981'; // Back to target highlight
                }, 1000);
            }
        },
        
        // üöÄ Ultra-Fast UI Updates
        updateWordUIUltraFast(word, isCorrect) {
            const wordElements = document.querySelectorAll('.ayah-word');
            const currentIndex = state.memorizationStats.currentWordIndex - 1; // -1 because we already incremented
            
            if (wordElements[currentIndex]) {
                wordElements[currentIndex].classList.remove('waiting', 'hidden');
                wordElements[currentIndex].classList.add(isCorrect ? 'correct' : 'incorrect', 'revealed');
            }
            
            // ‚ö° Set next word as waiting
            if (wordElements[state.memorizationStats.currentWordIndex]) {
                wordElements[state.memorizationStats.currentWordIndex].classList.add('waiting');
            }
        },
        
        // ‚ö° Ultra-Fast Memorization Display Update
        updateMemorizationDisplayUltraFast() {
            // üìä Quick stats update
            const totalWordsEl = document.getElementById('total-words');
            const correctWordsEl = document.getElementById('correct-words');
            const accuracyEl = document.getElementById('accuracy');
            
            if (totalWordsEl) {
                totalWordsEl.textContent = this.convertToArabicNumbers(state.memorizationStats.correctWords + state.memorizationStats.incorrectWords);
            }
            
            if (correctWordsEl) {
                correctWordsEl.textContent = this.convertToArabicNumbers(state.memorizationStats.correctWords);
            }
            
            if (accuracyEl) {
                const accuracy = Math.round(state.memorizationStats.accuracy);
                accuracyEl.textContent = `${this.convertToArabicNumbers(accuracy)}%`;
                
                // üé® Ultra-fast color coding
                if (accuracy >= 90) {
                    accuracyEl.className = 'font-bold text-green-400';
                } else if (accuracy >= 70) {
                    accuracyEl.className = 'font-bold text-yellow-400';
                } else {
                    accuracyEl.className = 'font-bold text-red-400';
                }
            }
        },
        
        // üîç Ultra-Fast Feedback Display
        showUltraFastFeedback(transcript, processingTime) {
            const feedbackEl = document.getElementById('speech-interim-feedback');
            if (feedbackEl) {
                feedbackEl.textContent = `üéôÔ∏è ${transcript} (‚ö°${processingTime.toFixed(0)}ms)`;
                feedbackEl.style.opacity = '1';
                feedbackEl.style.color = '#10b981'; // Green for ultra-fast
                
                // ‚ö° Clear ultra-fast feedback
                clearTimeout(this.ultraFastFeedbackTimeout);
                this.ultraFastFeedbackTimeout = setTimeout(() => {
                    feedbackEl.style.opacity = '0.3';
                }, 800);
            }
        },
        
        // ‚úÖ Ultra-Fast Success Feedback
        showUltraFastSuccessFeedback() {
            const feedbackEl = document.getElementById('speech-interim-feedback');
            if (feedbackEl) {
                feedbackEl.textContent = '‚úÖ ÿµÿ≠Ÿäÿ≠!';
                feedbackEl.style.color = '#10b981';
                feedbackEl.style.opacity = '1';
                
                setTimeout(() => {
                    feedbackEl.style.opacity = '0.3';
                }, 500);
            }
        },
        
        // ‚ùå Ultra-Fast Error Feedback
        showUltraFastErrorFeedback(spoken, correct) {
            const feedbackEl = document.getElementById('speech-interim-feedback');
            if (feedbackEl) {
                feedbackEl.textContent = `‚ùå "‚Äé${spoken}‚Äé" ‚Üí "‚Äé${correct}‚Äé"`;
                feedbackEl.style.color = '#ef4444';
                feedbackEl.style.opacity = '1';
                
                setTimeout(() => {
                    feedbackEl.style.opacity = '0.3';
                }, 1000);
            }
        },
        
        // üöÄ PHASE 2: Advanced Real-Time Processing Engine
        
        // üéÜ Enhanced Quranic Pattern Recognition with Real-Time Optimization
        processSpecialQuranicPatternsRealTime(transcript) {
            const normalized = transcript.toLowerCase().trim();
            
            // üî• Advanced Quranic Letter Mappings with Multiple Pronunciation Variations
            const quranicLetterMappings = {
                // ÿßŸÑŸÖ - Alif Lam Mim (Multiple Variations)
                'alif lam mim': 'ÿßŸÑŸÖ', 'alef lam mim': 'ÿßŸÑŸÖ', 'alef lam meem': 'ÿßŸÑŸÖ',
                'ÿ£ŸÑŸÅ ŸÑÿßŸÖ ŸÖŸäŸÖ': 'ÿßŸÑŸÖ', 'a l m': 'ÿßŸÑŸÖ', 'alm': 'ÿßŸÑŸÖ',
                'alif laam meem': 'ÿßŸÑŸÖ', 'alef laam meem': 'ÿßŸÑŸÖ',
                
                // ÿßŸÑŸÖÿµ - Alif Lam Mim Sad
                'alif lam mim sad': 'ÿßŸÑŸÖÿµ', 'alef lam mim sad': 'ÿßŸÑŸÖÿµ',
                'ÿ£ŸÑŸÅ ŸÑÿßŸÖ ŸÖŸäŸÖ ÿµÿßÿØ': 'ÿßŸÑŸÖÿµ', 'a l m s': 'ÿßŸÑŸÖÿµ',
                
                // ÿßŸÑÿ± - Alif Lam Ra
                'alif lam ra': 'ÿßŸÑÿ±', 'alef lam ra': 'ÿßŸÑÿ±', 'alef lam raa': 'ÿßŸÑÿ±',
                'ÿ£ŸÑŸÅ ŸÑÿßŸÖ ÿ±ÿßÿ°': 'ÿßŸÑÿ±', 'a l r': 'ÿßŸÑÿ±', 'alr': 'ÿßŸÑÿ±',
                
                // ÿßŸÑŸÖÿ± - Alif Lam Mim Ra
                'alif lam mim ra': 'ÿßŸÑŸÖÿ±', 'alef lam mim ra': 'ÿßŸÑŸÖÿ±',
                'ÿ£ŸÑŸÅ ŸÑÿßŸÖ ŸÖŸäŸÖ ÿ±ÿßÿ°': 'ÿßŸÑŸÖÿ±', 'a l m r': 'ÿßŸÑŸÖÿ±',
                
                // ŸÉŸáŸäÿπÿµ - Kaf Ha Ya Ain Sad
                'kaf ha ya ain sad': 'ŸÉŸáŸäÿπÿµ', 'kaf haa yaa ain sad': 'ŸÉŸáŸäÿπÿµ',
                'ŸÉÿßŸÅ Ÿáÿßÿ° Ÿäÿßÿ° ÿπŸäŸÜ ÿµÿßÿØ': 'ŸÉŸáŸäÿπÿµ', 'k h y a s': 'ŸÉŸáŸäÿπÿµ',
                
                // ÿ∑Ÿá - Ta Ha
                'ta ha': 'ÿ∑Ÿá', 'taa ha': 'ÿ∑Ÿá', 'taa haa': 'ÿ∑Ÿá',
                'ÿ∑ÿßÿ° Ÿáÿßÿ°': 'ÿ∑Ÿá', 'taha': 'ÿ∑Ÿá', 't h': 'ÿ∑Ÿá',
                
                // ÿ∑ÿ≥ŸÖ - Ta Sin Mim
                'ta sin mim': 'ÿ∑ÿ≥ŸÖ', 'taa sin mim': 'ÿ∑ÿ≥ŸÖ', 'taa seen meem': 'ÿ∑ÿ≥ŸÖ',
                'ÿ∑ÿßÿ° ÿ≥ŸäŸÜ ŸÖŸäŸÖ': 'ÿ∑ÿ≥ŸÖ', 't s m': 'ÿ∑ÿ≥ŸÖ', 'tsm': 'ÿ∑ÿ≥ŸÖ',
                
                // Ÿäÿ≥ - Ya Sin
                'ya sin': 'Ÿäÿ≥', 'yaa sin': 'Ÿäÿ≥', 'yaa seen': 'Ÿäÿ≥',
                'Ÿäÿßÿ° ÿ≥ŸäŸÜ': 'Ÿäÿ≥', 'yasin': 'Ÿäÿ≥', 'y s': 'Ÿäÿ≥',
                
                // ÿµ - Sad
                'sad': 'ÿµ', 'saad': 'ÿµ', 'ÿµÿßÿØ': 'ÿµ',
                
                // ŸÇ - Qaf
                'qaf': 'ŸÇ', 'qaaf': 'ŸÇ', 'ŸÇÿßŸÅ': 'ŸÇ',
                
                // ŸÜ - Nun
                'nun': 'ŸÜ', 'noon': 'ŸÜ', 'ŸÜŸàŸÜ': 'ŸÜ',
                
                // ÿ≠ŸÖ - Ha Mim
                'ha mim': 'ÿ≠ŸÖ', 'haa mim': 'ÿ≠ŸÖ', 'ha meem': 'ÿ≠ŸÖ',
                'haa meem': 'ÿ≠ŸÖ', 'ÿ≠ÿßÿ° ŸÖŸäŸÖ': 'ÿ≠ŸÖ',
                'h m': 'ÿ≠ŸÖ', 'hm': 'ÿ≠ŸÖ'
            };
            
            // ‚ö° Real-time exact match checking (highest priority)
            for (const [pronunciation, arabic] of Object.entries(quranicLetterMappings)) {
                if (normalized === pronunciation) {
                    console.log(`‚úÖ Real-time exact Quranic pattern: "${pronunciation}" ‚Üí "${arabic}"`);
                    this.processSequentialWordUltraFast(arabic);
                    return true;
                }
            }
            
            // üîç Enhanced fuzzy matching with real-time optimization
            for (const [pronunciation, arabic] of Object.entries(quranicLetterMappings)) {
                const similarity = this.calculateRealTimeSimilarity(normalized, pronunciation);
                if (similarity >= 0.55) { // Lowered threshold for better capture
                    console.log(`‚úÖ Real-time fuzzy Quranic pattern: "${pronunciation}" ‚Üí "${arabic}" (${similarity.toFixed(2)})`);
                    this.processSequentialWordUltraFast(arabic);
                    return true;
                }
            }
            
            // üéÜ Partial matching for connected speech
            for (const [pronunciation, arabic] of Object.entries(quranicLetterMappings)) {
                if (normalized.includes(pronunciation) || pronunciation.includes(normalized)) {
                    console.log(`‚úÖ Real-time partial Quranic pattern: "${pronunciation}" ‚Üí "${arabic}"`);
                    this.processSequentialWordUltraFast(arabic);
                    return true;
                }
            }
            
            return false;
        },
        
        // üîÑ Real-Time Word Sequence Processing
        processWordSequenceRealTime(spokenWords) {
            console.log('üîÑ Real-time word sequence processing:', spokenWords);
            
            // ‚ö° Parallel processing for multiple words
            const promises = spokenWords.map(word => {
                if (word && word.trim().length > 0) {
                    return this.processSequentialWordUltraFast(word.trim());
                }
            });
            
            // üî• Process combined words for connected speech
            if (spokenWords.length > 1) {
                const combined = spokenWords.join('');
                if (combined.length > 2) {
                    this.processSequentialWordUltraFast(combined);
                }
                
                // üéÜ Process variations of combined words
                const spaced = spokenWords.join(' ');
                if (spaced !== combined) {
                    this.processSequentialWordUltraFast(spaced);
                }
            }
            
            return promises;
        },
        
        // üéØ Enhanced Real-Time Arabic Text Normalization
        normalizeArabicTextRealTime(text) {
            if (!text) return '';
            
            // ‚ö° Check cache first for ultra-fast processing
            if (this.normalizationCache && this.normalizationCache.has(text)) {
                return this.normalizationCache.get(text);
            }
            
            const normalized = text
                // üî• Remove all diacritics and tashkeel
                .replace(/[\u064B-\u065F\u0670\u06D6-\u06ED\u08F0-\u08FF\u06DF-\u06E8]/g, '')
                // üéÜ Normalize Alif variations
                .replace(/[\u0671\u0623\u0625\u0622]/g, '\u0627')
                // üîÑ Normalize Ta Marbuta
                .replace(/\u0629/g, '\u0647')
                // ‚ö° Normalize Ya variations
                .replace(/\u0649/g, '\u064a')
                // üî• Remove Tatweel
                .replace(/\u0640/g, '')
                // üéØ Remove control characters
                .replace(/[\u200C-\u200F\u202A-\u202E]/g, '')
                // üöÄ Normalize whitespace
                .replace(/\s+/g, ' ')
                .trim();
            
            // üó∫Ô∏è Cache the result
            if (!this.normalizationCache) {
                this.normalizationCache = new Map();
            }
            this.normalizationCache.set(text, normalized);
            
            return normalized;
        },
        
        // üî• Real-Time Multi-Strategy Similarity Calculation
        calculateRealTimeSimilarity(a, b) {
            if (!a || !b) return 0;
            if (a === b) return 1;
            
            // ‚ö° Cache check for ultra-fast processing
            const cacheKey = `${a}:${b}`;
            if (this.similarityCache && this.similarityCache.has(cacheKey)) {
                return this.similarityCache.get(cacheKey);
            }
            
            // üéØ Multiple algorithms with optimized weights for Quranic text
            const levenshtein = this.calculateLevenshteinSimilarity(a, b);
            const jaro = this.calculateJaroSimilarity(a, b);
            const phonetic = this.calculatePhoneticSimilarity(a, b);
            const substring = this.calculateSubstringSimilarity(a, b);
            const quranic = this.calculateQuranicSimilarity(a, b); // New Quranic-specific algorithm
            
            // üî• Optimized weights for Quranic recitation
            const weightedScore = (
                levenshtein * 0.3 +    // 30% Exact character matching
                jaro * 0.25 +          // 25% Word structure
                phonetic * 0.25 +      // 25% Sound similarity
                substring * 0.1 +      // 10% Partial matching
                quranic * 0.1          // 10% Quranic-specific patterns
            );
            
            const result = Math.min(1, weightedScore);
            
            // üó∫Ô∏è Cache the result
            if (!this.similarityCache) {
                this.similarityCache = new Map();
            }
            this.similarityCache.set(cacheKey, result);
            
            return result;
        },
        
        // üïåÔ∏è New Quranic-Specific Similarity Algorithm
        calculateQuranicSimilarity(a, b) {
            const quranicPatterns = [
                // üî• Common Quranic word patterns
                ['ÿßŸÑŸÑŸá', 'ŸÑŸÑŸá'], // Allah variations
                ['ÿßŸÑÿ±ÿ≠ŸÖŸÜ', 'ÿ±ÿ≠ŸÖŸÜ'], // Rahman variations
                ['ÿßŸÑÿ±ÿ≠ŸäŸÖ', 'ÿ±ÿ≠ŸäŸÖ'], // Raheem variations
                ['ÿ®ÿ≥ŸÖ', 'ÿ®ÿßÿ≥ŸÖ'], // Bism variations
                ['ÿ•ŸäÿßŸÉ', 'ÿßŸäÿßŸÉ'], // Iyyaka variations
            ];
            
            // ‚ö° Check if either word matches known Quranic patterns
            for (const [pattern1, pattern2] of quranicPatterns) {
                if ((a.includes(pattern1) || a.includes(pattern2)) && 
                    (b.includes(pattern1) || b.includes(pattern2))) {
                    return 0.9; // High similarity for Quranic pattern matches
                }
            }
            
            // üéØ Check for common Arabic root patterns
            if (this.shareArabicRoot(a, b)) {
                return 0.7;
            }
            
            return 0;
        },
        
        // üå± Arabic Root Pattern Matching
        shareArabicRoot(a, b) {
            if (a.length < 3 || b.length < 3) return false;
            
            // üî• Extract potential root letters (simplified)
            const getRootLetters = (word) => {
                return word.replace(/[ÿßŸÑŸàŸäŸáÿ©]/g, '').substring(0, 3);
            };
            
            const rootA = getRootLetters(a);
            const rootB = getRootLetters(b);
            
            // ‚ö° Check if roots share at least 2 letters
            let commonLetters = 0;
            for (let i = 0; i < Math.min(rootA.length, rootB.length); i++) {
                if (rootA[i] === rootB[i]) {
                    commonLetters++;
                }
            }
            
            return commonLetters >= 2;
        },
        
        // üöÄ Real-Time Intelligent Buffering System
        initRealTimeBuffering() {
            this.speechBuffer = {
                interim: [],
                final: [],
                maxSize: 10,
                processingQueue: [],
                isProcessing: false
            };
            
            // ‚ö° Start buffer processing loop
            this.startBufferProcessing();
        },
        
        // üîÑ Buffer Processing Loop
        startBufferProcessing() {
            setInterval(() => {
                if (this.speechBuffer && this.speechBuffer.processingQueue.length > 0 && !this.speechBuffer.isProcessing) {
                    this.processBufferQueue();
                }
            }, 50); // Process every 50ms for ultra-responsiveness
        },
        
        // ‚ö° Process Buffer Queue
        async processBufferQueue() {
            if (!this.speechBuffer || this.speechBuffer.isProcessing) return;
            
            this.speechBuffer.isProcessing = true;
            
            while (this.speechBuffer.processingQueue.length > 0) {
                const item = this.speechBuffer.processingQueue.shift();
                await this.processQueueItem(item);
            }
            
            this.speechBuffer.isProcessing = false;
        },
        
        // üéØ Process Individual Queue Item
        async processQueueItem(item) {
            const { transcript, confidence, timestamp } = item;
            
            // üî• Skip if too old (prevent processing stale speech)
            if (Date.now() - timestamp > 2000) {
                console.log('‚ö†Ô∏è Skipping stale speech item');
                return;
            }
            
            // ‚ö° Process with ultra-fast algorithm
            this.processQuranicSpeechUltraFast(transcript, confidence, timestamp);
        },
        
        // üî• Enhanced Real-Time Recognition State Management
        updateRecognitionState(success, processingTime) {
            if (!this.recognitionState) {
                this.recognitionState = {
                    lastProcessingTime: 0,
                    consecutiveMatches: 0,
                    consecutiveFailures: 0,
                    adaptiveThreshold: 0.7,
                    currentAccuracy: 1.0,
                    averageProcessingTime: 0,
                    totalProcessed: 0
                };
            }
            
            this.recognitionState.totalProcessed++;
            this.recognitionState.lastProcessingTime = processingTime;
            
            // üìä Update average processing time
            this.recognitionState.averageProcessingTime = 
                (this.recognitionState.averageProcessingTime * (this.recognitionState.totalProcessed - 1) + processingTime) / 
                this.recognitionState.totalProcessed;
            
            if (success) {
                this.recognitionState.consecutiveMatches++;
                this.recognitionState.consecutiveFailures = 0;
                
                // üöÄ Lower threshold for better user experience on success
                this.recognitionState.adaptiveThreshold = Math.max(0.5, this.recognitionState.adaptiveThreshold - 0.02);
            } else {
                this.recognitionState.consecutiveFailures++;
                this.recognitionState.consecutiveMatches = 0;
                
                // üéØ Raise threshold temporarily on failures
                this.recognitionState.adaptiveThreshold = Math.min(0.9, this.recognitionState.adaptiveThreshold + 0.01);
            }
            
            // üìà Update current accuracy
            const recentSuccesses = Math.max(1, this.recognitionState.consecutiveMatches);
            const recentTotal = recentSuccesses + this.recognitionState.consecutiveFailures;
            this.recognitionState.currentAccuracy = recentSuccesses / recentTotal;
            
            console.log(`üìà Recognition state: ${this.recognitionState.currentAccuracy.toFixed(2)} accuracy, ${this.recognitionState.adaptiveThreshold.toFixed(2)} threshold, ${processingTime.toFixed(0)}ms`);
        },
        
        // üß† PHASE 3: Intelligent Caching & Memory Optimization
        
        // üó∫Ô∏è Advanced Smart Cache System
        initSmartCaching() {
            // üöÄ Initialize multiple cache layers
            this.cacheSystem = {
                // ‚ö° Level 1: Ultra-fast word recognition cache
                wordCache: new Map(),
                // üéØ Level 2: Pattern recognition cache  
                patternCache: new Map(),
                // üî• Level 3: Similarity calculation cache
                similarityCache: new Map(),
                // üéÜ Level 4: Prediction cache
                predictionCache: new Map(),
                // üìä Cache statistics
                stats: {
                    hits: 0,
                    misses: 0,
                    totalQueries: 0,
                    hitRate: 0
                }
            };
            
            // üîÑ Initialize cache warming
            this.initCacheWarming();
            
            // ‚ö° Initialize memory optimization
            this.initMemoryOptimization();
            
            console.log('üß† Smart caching system initialized with multi-level optimization');
        },
        
        // üî• Cache Warming - Pre-load Critical Data
        initCacheWarming() {
            // üéÜ Pre-warm with most common Quranic words
            const criticalWords = [
                // üïåÔ∏è Al-Fatiha (most recited)
                'ÿ®ÿ≥ŸÖ', 'ÿßŸÑŸÑŸá', 'ÿßŸÑÿ±ÿ≠ŸÖŸÜ', 'ÿßŸÑÿ±ÿ≠ŸäŸÖ',
                'ÿßŸÑÿ≠ŸÖÿØ', 'ŸÑŸÑŸá', 'ÿ±ÿ®', 'ÿßŸÑÿπÿßŸÑŸÖŸäŸÜ',
                'ÿßŸÑÿ±ÿ≠ŸÖŸÜ', 'ÿßŸÑÿ±ÿ≠ŸäŸÖ', 'ŸÖÿßŸÑŸÉ', 'ŸäŸàŸÖ', 'ÿßŸÑÿØŸäŸÜ',
                'ÿ•ŸäÿßŸÉ', 'ŸÜÿπÿ®ÿØ', 'Ÿàÿ•ŸäÿßŸÉ', 'ŸÜÿ≥ÿ™ÿπŸäŸÜ',
                'ÿßŸáÿØŸÜÿß', 'ÿßŸÑÿµÿ±ÿßÿ∑', 'ÿßŸÑŸÖÿ≥ÿ™ŸÇŸäŸÖ',
                'ÿµÿ±ÿßÿ∑', 'ÿßŸÑÿ∞ŸäŸÜ', 'ÿ£ŸÜÿπŸÖÿ™', 'ÿπŸÑŸäŸáŸÖ',
                'ÿ∫Ÿäÿ±', 'ÿßŸÑŸÖÿ∫ÿ∂Ÿàÿ®', 'ÿπŸÑŸäŸáŸÖ', 'ŸàŸÑÿß', 'ÿßŸÑÿ∂ÿßŸÑŸäŸÜ',
                
                // üìú Disconnected letters
                'ÿßŸÑŸÖ', 'ÿßŸÑŸÖÿµ', 'ÿßŸÑÿ±', 'ÿßŸÑŸÖÿ±', 'ŸÉŸáŸäÿπÿµ',
                'ÿ∑Ÿá', 'ÿ∑ÿ≥ŸÖ', 'Ÿäÿ≥', 'ÿµ', 'ŸÇ', 'ŸÜ', 'ÿ≠ŸÖ',
                
                // üöÄ Common connecting words
                'Ÿà', 'ŸÅŸä', 'ŸÖŸÜ', 'ÿ•ŸÑŸâ', 'ÿπŸÜ', 'ŸÑŸá', 'ÿ®Ÿá',
                'ŸÑŸÉŸÖ', 'ŸàŸÑŸÉŸÖ', 'ÿ•ŸÜ', 'ÿ£ŸÜ', 'ŸÑŸÖ', 'ŸÑŸÜ'
            ];
            
            // ‚ö° Pre-calculate and cache all variations
            criticalWords.forEach(word => {
                this.warmWordCache(word);
            });
            
            console.log(`üî• Cache warmed with ${criticalWords.length} critical Quranic words`);
        },
        
        // üéÜ Warm Individual Word Cache
        warmWordCache(word) {
            const variations = {
                original: word,
                normalized: this.normalizeQuranText(word),
                plain: this.convertToPlainText(word),
                pronunciation: this.generatePronunciationVariations(word),
                roots: this.extractArabicRoots(word),
                phonetic: this.getArabicPhoneticCode(word)
            };
            
            // üó∫Ô∏è Cache all variations for ultra-fast lookup
            this.cacheSystem.wordCache.set(word, variations);
            this.cacheSystem.wordCache.set(variations.normalized, variations);
            this.cacheSystem.wordCache.set(variations.plain, variations);
            
            // üî• Cache pronunciation variations
            variations.pronunciation.forEach(variation => {
                this.cacheSystem.wordCache.set(variation, variations);
            });
        },
        
        // üå± Generate Pronunciation Variations
        generatePronunciationVariations(word) {
            const variations = new Set();
            const normalized = this.normalizeQuranText(word);
            
            // üî• Add common Arabic pronunciation patterns
            variations.add(normalized);
            
            // ‚ö° Handle definite article variations
            if (normalized.startsWith('ÿßŸÑ')) {
                variations.add(normalized.replace('ÿßŸÑ', 'ŸÑ'));
                variations.add(normalized.substring(2)); // Remove ÿßŸÑ completely
            }
            
            // üéØ Handle ta marbuta variations
            if (normalized.endsWith('Ÿá')) {
                variations.add(normalized.slice(0, -1) + 'ÿ©');
            }
            if (normalized.endsWith('ÿ©')) {
                variations.add(normalized.slice(0, -1) + 'Ÿá');
            }
            
            // üöÄ Handle ya variations
            if (normalized.endsWith('Ÿä')) {
                variations.add(normalized.slice(0, -1) + 'Ÿâ');
            }
            if (normalized.endsWith('Ÿâ')) {
                variations.add(normalized.slice(0, -1) + 'Ÿä');
            }
            
            // üéÜ Handle hamza variations
            variations.add(normalized.replace(/[ÿ£ÿ•ÿ¢]/g, 'ÿß'));
            
            // üîÑ Handle doubled letters
            variations.add(normalized.replace(/(.)(\1+)/g, '$1'));
            
            return Array.from(variations);
        },
        
        // üå± Extract Arabic Roots
        extractArabicRoots(word) {
            const normalized = this.normalizeQuranText(word);
            const roots = [];
            
            // üî• Remove common prefixes and suffixes
            let root = normalized
                .replace(/^(ÿßŸÑ|ÿ®ÿßŸÑ|ŸàÿßŸÑ|ŸÅÿßŸÑ|ŸÑŸÑ)/g, '') // Remove definite articles
                .replace(/(Ÿáÿß|ŸáŸÖ|ŸáŸÜ|Ÿá|ÿ©|ŸàŸÜ|ŸäŸÜ|ÿßŸÜ|ÿ™ŸäŸÜ|ÿ™ÿßŸÜ)$/g, '') // Remove suffixes
                .replace(/^(ŸÖ|Ÿä|ÿ™|ŸÜ|ÿß)/g, ''); // Remove common prefixes
            
            // ‚ö° Extract 3-letter root (most common in Arabic)
            if (root.length >= 3) {
                roots.push(root.substring(0, 3));
            }
            
            // üéØ Extract 4-letter root if applicable
            if (root.length >= 4) {
                roots.push(root.substring(0, 4));
            }
            
            return roots;
        },
        
        // ‚ö° Memory Optimization System
        initMemoryOptimization() {
            // üîÑ Set cache size limits
            this.cacheSystem.maxSizes = {
                wordCache: 1000,        // Top 1000 most used words
                patternCache: 200,      // Top 200 patterns
                similarityCache: 500,   // Top 500 similarity calculations
                predictionCache: 100    // Top 100 predictions
            };
            
            // üìä Initialize cache monitoring
            this.startCacheMonitoring();
            
            // üöÄ Setup automatic cache cleanup
            this.setupCacheCleanup();
            
            console.log('‚ö° Memory optimization system initialized');
        },
        
        // üìä Cache Performance Monitoring
        startCacheMonitoring() {
            setInterval(() => {
                this.analyzeCachePerformance();
            }, 30000); // Monitor every 30 seconds
        },
        
        // üó∫Ô∏è Analyze Cache Performance
        analyzeCachePerformance() {
            const stats = this.cacheSystem.stats;
            stats.hitRate = stats.totalQueries > 0 ? (stats.hits / stats.totalQueries) * 100 : 0;
            
            console.log(`üìä Cache Performance: ${stats.hitRate.toFixed(1)}% hit rate (${stats.hits}/${stats.totalQueries})`);
            
            // üöÄ Optimize cache if hit rate is low
            if (stats.hitRate < 70 && stats.totalQueries > 50) {
                this.optimizeCacheStrategy();
            }
            
            // üîÑ Reset stats periodically
            if (stats.totalQueries > 1000) {
                stats.hits = Math.floor(stats.hits * 0.8);
                stats.misses = Math.floor(stats.misses * 0.8);
                stats.totalQueries = Math.floor(stats.totalQueries * 0.8);
            }
        },
        
        // üî• Optimize Cache Strategy
        optimizeCacheStrategy() {
            console.log('üî• Optimizing cache strategy for better performance');
            
            // ‚ö° Pre-load more common words based on current memorization
            if (state.currentMemorizationWords && state.currentMemorizationWords.length > 0) {
                state.currentMemorizationWords.forEach(word => {
                    this.warmWordCache(word);
                });
            }
            
            // üéØ Warm cache with next likely words
            this.predictAndCacheNextWords();
        },
        
        // üîç Predict and Cache Next Words
        predictAndCacheNextWords() {
            if (!state.currentMemorizationWords || state.memorizationStats.currentWordIndex >= state.currentMemorizationWords.length) {
                return;
            }
            
            // ‚ö° Cache next 5 words for ultra-fast access
            const nextWords = state.currentMemorizationWords.slice(
                state.memorizationStats.currentWordIndex,
                state.memorizationStats.currentWordIndex + 5
            );
            
            nextWords.forEach(word => {
                this.warmWordCache(word);
            });
            
            console.log(`üîç Pre-cached next ${nextWords.length} words for prediction`);
        },
        
        // üîÑ Smart Cache Cleanup
        setupCacheCleanup() {
            setInterval(() => {
                this.cleanupCaches();
            }, 60000); // Cleanup every minute
        },
        
        // üßπ Cleanup Caches
        cleanupCaches() {
            // üó∫Ô∏è Track cache usage
            const cacheUsage = {
                wordCache: this.cacheSystem.wordCache.size,
                patternCache: this.cacheSystem.patternCache.size,
                similarityCache: this.cacheSystem.similarityCache.size
            };
            
            // üî• Clean similarity cache if too large
            if (this.cacheSystem.similarityCache.size > this.cacheSystem.maxSizes.similarityCache) {
                const entries = Array.from(this.cacheSystem.similarityCache.entries());
                // Keep most recent 60%
                const keepCount = Math.floor(entries.length * 0.6);
                this.cacheSystem.similarityCache.clear();
                entries.slice(-keepCount).forEach(([key, value]) => {
                    this.cacheSystem.similarityCache.set(key, value);
                });
            }
            
            // ‚ö° Clean pattern cache if too large
            if (this.cacheSystem.patternCache.size > this.cacheSystem.maxSizes.patternCache) {
                const entries = Array.from(this.cacheSystem.patternCache.entries());
                const keepCount = Math.floor(entries.length * 0.7);
                this.cacheSystem.patternCache.clear();
                entries.slice(-keepCount).forEach(([key, value]) => {
                    this.cacheSystem.patternCache.set(key, value);
                });
            }
            
            console.log(`üßπ Cache cleanup: Word:${cacheUsage.wordCache}, Pattern:${cacheUsage.patternCache}, Similarity:${cacheUsage.similarityCache}`);
        },
        
        // üöÄ Ultra-Fast Cached Word Lookup
        getCachedWordData(word) {
            this.cacheSystem.stats.totalQueries++;
            
            // ‚ö° Check direct cache hit
            if (this.cacheSystem.wordCache.has(word)) {
                this.cacheSystem.stats.hits++;
                return this.cacheSystem.wordCache.get(word);
            }
            
            // üîç Check normalized version
            const normalized = this.normalizeQuranText(word);
            if (this.cacheSystem.wordCache.has(normalized)) {
                this.cacheSystem.stats.hits++;
                return this.cacheSystem.wordCache.get(normalized);
            }
            
            // üéØ Check plain text version
            const plain = this.convertToPlainText(word);
            if (this.cacheSystem.wordCache.has(plain)) {
                this.cacheSystem.stats.hits++;
                return this.cacheSystem.wordCache.get(plain);
            }
            
            this.cacheSystem.stats.misses++;
            return null;
        },
        
        // üéÜ Advanced Predictive Caching
        initPredictiveCaching() {
            // üî• Predict based on current memorization progress
            if (state.currentMemorizationWords) {
                this.predictMemorizationFlow();
            }
            
            // ‚ö° Predict based on common recitation patterns
            this.predictCommonPatterns();
            
            console.log('üéÜ Predictive caching initialized');
        },
        
        // üîç Predict Memorization Flow
        predictMemorizationFlow() {
            const currentIndex = state.memorizationStats.currentWordIndex;
            const words = state.currentMemorizationWords;
            
            if (!words || currentIndex >= words.length) return;
            
            // ‚ö° Predict next 10 words with high probability
            for (let i = currentIndex; i < Math.min(currentIndex + 10, words.length); i++) {
                const word = words[i];
                const probability = Math.max(0.1, 1 - (i - currentIndex) * 0.1);
                
                this.cacheSystem.predictionCache.set(word, {
                    word: word,
                    probability: probability,
                    timestamp: Date.now(),
                    cached: true
                });
                
                // üöÄ Pre-warm cache for high-probability words
                if (probability > 0.7) {
                    this.warmWordCache(word);
                }
            }
        },
        
        // üéØ Predict Common Patterns
        predictCommonPatterns() {
            const commonTransitions = [
                ['ÿ®ÿ≥ŸÖ', 'ÿßŸÑŸÑŸá'],
                ['ÿßŸÑŸÑŸá', 'ÿßŸÑÿ±ÿ≠ŸÖŸÜ'],
                ['ÿßŸÑÿ±ÿ≠ŸÖŸÜ', 'ÿßŸÑÿ±ÿ≠ŸäŸÖ'],
                ['ÿßŸÑÿ≠ŸÖÿØ', 'ŸÑŸÑŸá'],
                ['ŸÑŸÑŸá', 'ÿ±ÿ®'],
                ['ÿ±ÿ®', 'ÿßŸÑÿπÿßŸÑŸÖŸäŸÜ']
            ];
            
            // ‚ö° Cache common word transitions
            commonTransitions.forEach(([word1, word2]) => {
                if (this.cacheSystem.wordCache.has(word1)) {
                    this.warmWordCache(word2);
                }
            });
        },
        
        processSpeechResult(transcript, confidence) {
            console.log(`Processing speech result: "${transcript}" with confidence: ${confidence}`);
            
            // Update last heard display
            const lastHeardEl = document.getElementById('last-heard-word');
            if (lastHeardEl) {
                lastHeardEl.textContent = transcript;
            }
            
            // Use the enhanced Quranic speech processing
            this.processQuranicSpeech(transcript, confidence);
        },
        
        // Simplified and optimized Quranic speech processing
        processQuranicSpeech(transcript, confidence) {
            console.log(`Processing Quranic speech: "${transcript}" with confidence: ${confidence}`);
            
            // Update display immediately
            const lastHeardEl = document.getElementById('last-heard-word');
            if (lastHeardEl) {
                lastHeardEl.textContent = transcript;
            }
            
            // First, try special Quranic patterns (like ÿßŸÑŸÖ, Ÿäÿ≥, etc.)
            if (this.processSpecialQuranicPatterns(transcript)) {
                return; // Success with special pattern
            }
            
            // Process as normal words with enhanced cleaning
            const words = this.parseQuranicSpeech(transcript);
            
            // Try each parsed word
            words.forEach(word => {
                if (word && word.trim().length > 0) {
                    this.processSequentialWord(word.trim());
                }
            });
            
            // Also try the full cleaned transcript
            const fullCleaned = this.cleanQuranicText(transcript);
            if (fullCleaned && fullCleaned.length > 0) {
                this.processSequentialWord(fullCleaned);
            }
        },
        
        // Simplified Quranic speech parsing
        parseQuranicSpeech(transcript) {
            const words = [];
            
            // Split by spaces and clean each word
            const segments = transcript.split(/\s+/);
            
            segments.forEach(segment => {
                const cleaned = segment.trim();
                if (cleaned.length === 0) return;
                
                // First try individual letter parsing for special cases
                const letterWords = this.parseQuranicLetters(cleaned);
                if (letterWords.length > 0) {
                    words.push(...letterWords);
                }
                
                // Always also try as a regular word
                const cleanedWord = this.cleanQuranicText(cleaned);
                if (cleanedWord && cleanedWord.length > 0) {
                    words.push(cleanedWord);
                }
            });
            
            // If no words found, try the whole transcript as one word
            if (words.length === 0) {
                const wholeCleaned = this.cleanQuranicText(transcript);
                if (wholeCleaned) {
                    words.push(wholeCleaned);
                }
            }
            
            return words;
        },
        
        // Advanced Quranic text cleaning with multiple normalization strategies
        cleanQuranicText(text) {
            if (!text) return '';
            
            let cleaned = text
                // Remove diacritics but preserve structure
                .replace(/[\u064B-\u065F\u0670\u06D6-\u06ED\u08F0-\u08FF]/g, '')
                // Remove tatweel
                .replace(/\u0640/g, '')
                // Advanced Alif normalization
                .replace(/[\u0622\u0623\u0625\u0671]/g, '\u0627') // ÿ¢ ÿ£ ÿ• Ÿ± ‚Üí ÿß
                // Ta Marbuta handling
                .replace(/\u0629/g, '\u0647') // ÿ© ‚Üí Ÿá
                // Ya variations
                .replace(/\u0649/g, '\u064A') // Ÿâ ‚Üí Ÿä
                // Waw variations
                .replace(/\u0624/g, '\u0648') // ÿ§ ‚Üí Ÿà
                // Ya Hamza
                .replace(/\u0626/g, '\u064A') // ÿ¶ ‚Üí Ÿä
                .trim();
            
            // Additional Quranic-specific normalizations
            cleaned = this.normalizeQuranicVariations(cleaned);
            
            return cleaned;
        },
        
        // Advanced Quranic text variations normalization
        normalizeQuranicVariations(text) {
            return text
                // Common Quranic word variations
                .replace(/ÿßŸÑÿ±ÿ≠ŸÖÿßŸÜ/g, 'ÿßŸÑÿ±ÿ≠ŸÖŸÜ') // ÿßŸÑÿ±ÿ≠ŸÖÿßŸÜ ‚Üí ÿßŸÑÿ±ÿ≠ŸÖŸÜ
                .replace(/ÿßŸÑÿµŸÑÿßÿ©/g, 'ÿßŸÑÿµŸÑŸàÿ©') // Handle prayer variations
                .replace(/ÿßŸÑÿ≤ŸÉÿßÿ©/g, 'ÿßŸÑÿ≤ŸÉŸàÿ©') // Handle zakat variations
                // Numbers in Arabic
                .replace(/Ÿ°/g, '1').replace(/Ÿ¢/g, '2').replace(/Ÿ£/g, '3')
                .replace(/Ÿ§/g, '4').replace(/Ÿ•/g, '5').replace(/Ÿ¶/g, '6')
                .replace(/Ÿß/g, '7').replace(/Ÿ®/g, '8').replace(/Ÿ©/g, '9').replace(/Ÿ†/g, '0')
                // Remove extra spaces
                .replace(/\s+/g, ' ')
                .trim();
        },
        
        // Enhanced special Quranic patterns with comprehensive mappings
        processSpecialQuranicPatterns(transcript) {
            const normalized = transcript.toLowerCase().trim();
            
            // Comprehensive map of Quranic disconnected letters with multiple pronunciations
            const quranicLetterMappings = {
                // ÿßŸÑŸÖ - Alif Lam Mim (multiple variations)
                'alif lam mim': 'ÿßŸÑŸÖ', 'alef lam mim': 'ÿßŸÑŸÖ', 'alf lam mim': 'ÿßŸÑŸÖ',
                'alif lam meem': 'ÿßŸÑŸÖ', 'alef lam meem': 'ÿßŸÑŸÖ', 'alf lam meem': 'ÿßŸÑŸÖ',
                'ÿ£ŸÑŸÅ ŸÑÿßŸÖ ŸÖŸäŸÖ': 'ÿßŸÑŸÖ', 'ÿßŸÑŸÅ ŸÑÿßŸÖ ŸÖŸäŸÖ': 'ÿßŸÑŸÖ',
                'a l m': 'ÿßŸÑŸÖ', 'a.l.m': 'ÿßŸÑŸÖ', 'alm': 'ÿßŸÑŸÖ',
                
                // ÿßŸÑŸÖÿµ - Alif Lam Mim Sad
                'alif lam mim sad': 'ÿßŸÑŸÖÿµ', 'alef lam mim sad': 'ÿßŸÑŸÖÿµ',
                'alif lam meem sad': 'ÿßŸÑŸÖÿµ', 'alef lam meem sad': 'ÿßŸÑŸÖÿµ',
                'ÿ£ŸÑŸÅ ŸÑÿßŸÖ ŸÖŸäŸÖ ÿµÿßÿØ': 'ÿßŸÑŸÖÿµ',
                'a l m s': 'ÿßŸÑŸÖÿµ', 'alms': 'ÿßŸÑŸÖÿµ',
                
                // ÿßŸÑÿ± - Alif Lam Ra
                'alif lam ra': 'ÿßŸÑÿ±', 'alef lam ra': 'ÿßŸÑÿ±', 'alf lam ra': 'ÿßŸÑÿ±',
                'alif lam raa': 'ÿßŸÑÿ±', 'alef lam raa': 'ÿßŸÑÿ±',
                'ÿ£ŸÑŸÅ ŸÑÿßŸÖ ÿ±ÿßÿ°': 'ÿßŸÑÿ±', 'ÿßŸÑŸÅ ŸÑÿßŸÖ ÿ±ÿß': 'ÿßŸÑÿ±',
                'a l r': 'ÿßŸÑÿ±', 'alr': 'ÿßŸÑÿ±',
                
                // ÿßŸÑŸÖÿ± - Alif Lam Mim Ra
                'alif lam mim ra': 'ÿßŸÑŸÖÿ±', 'alef lam mim ra': 'ÿßŸÑŸÖÿ±',
                'alif lam meem ra': 'ÿßŸÑŸÖÿ±', 'alef lam meem ra': 'ÿßŸÑŸÖÿ±',
                'ÿ£ŸÑŸÅ ŸÑÿßŸÖ ŸÖŸäŸÖ ÿ±ÿßÿ°': 'ÿßŸÑŸÖÿ±',
                'a l m r': 'ÿßŸÑŸÖÿ±', 'almr': 'ÿßŸÑŸÖÿ±',
                
                // ŸÉŸáŸäÿπÿµ - Kaf Ha Ya Ain Sad
                'kaf ha ya ain sad': 'ŸÉŸáŸäÿπÿµ', 'kaf haa yaa ain sad': 'ŸÉŸáŸäÿπÿµ',
                'ŸÉÿßŸÅ Ÿáÿßÿ° Ÿäÿßÿ° ÿπŸäŸÜ ÿµÿßÿØ': 'ŸÉŸáŸäÿπÿµ',
                'k h y a s': 'ŸÉŸáŸäÿπÿµ', 'khyas': 'ŸÉŸáŸäÿπÿµ',
                
                // ÿ∑Ÿá - Ta Ha
                'ta ha': 'ÿ∑Ÿá', 'taha': 'ÿ∑Ÿá', 'ta haa': 'ÿ∑Ÿá',
                'taa ha': 'ÿ∑Ÿá', 'taa haa': 'ÿ∑Ÿá',
                'ÿ∑ÿßÿ° Ÿáÿßÿ°': 'ÿ∑Ÿá', 'ÿ∑ÿß Ÿáÿß': 'ÿ∑Ÿá',
                't h': 'ÿ∑Ÿá', 'th': 'ÿ∑Ÿá',
                
                // ÿ∑ÿ≥ŸÖ - Ta Sin Mim
                'ta sin mim': 'ÿ∑ÿ≥ŸÖ', 'taa sin mim': 'ÿ∑ÿ≥ŸÖ',
                'ta seen mim': 'ÿ∑ÿ≥ŸÖ', 'taa seen mim': 'ÿ∑ÿ≥ŸÖ',
                'ÿ∑ÿßÿ° ÿ≥ŸäŸÜ ŸÖŸäŸÖ': 'ÿ∑ÿ≥ŸÖ',
                't s m': 'ÿ∑ÿ≥ŸÖ', 'tsm': 'ÿ∑ÿ≥ŸÖ',
                
                // Ÿäÿ≥ - Ya Sin
                'ya sin': 'Ÿäÿ≥', 'yaa sin': 'Ÿäÿ≥', 'ya seen': 'Ÿäÿ≥',
                'yaa seen': 'Ÿäÿ≥', 'yasin': 'Ÿäÿ≥', 'yaseen': 'Ÿäÿ≥',
                'Ÿäÿßÿ° ÿ≥ŸäŸÜ': 'Ÿäÿ≥', 'Ÿäÿß ÿ≥ŸäŸÜ': 'Ÿäÿ≥',
                'y s': 'Ÿäÿ≥', 'ys': 'Ÿäÿ≥',
                
                // ÿµ - Sad
                'sad': 'ÿµ', 'saad': 'ÿµ', 'ÿµÿßÿØ': 'ÿµ', 's': 'ÿµ',
                
                // ŸÇ - Qaf
                'qaf': 'ŸÇ', 'qaaf': 'ŸÇ', 'ŸÇÿßŸÅ': 'ŸÇ', 'q': 'ŸÇ',
                
                // ŸÜ - Nun
                'nun': 'ŸÜ', 'noon': 'ŸÜ', 'ŸÜŸàŸÜ': 'ŸÜ', 'n': 'ŸÜ',
                
                // ÿ≠ŸÖ - Ha Mim
                'ha mim': 'ÿ≠ŸÖ', 'haa mim': 'ÿ≠ŸÖ', 'ha meem': 'ÿ≠ŸÖ',
                'haa meem': 'ÿ≠ŸÖ', 'ÿ≠ÿßÿ° ŸÖŸäŸÖ': 'ÿ≠ŸÖ',
                'h m': 'ÿ≠ŸÖ', 'hm': 'ÿ≠ŸÖ'
            };
            
            // Check for exact matches first (highest accuracy)
            for (const [pronunciation, arabic] of Object.entries(quranicLetterMappings)) {
                if (normalized === pronunciation) {
                    console.log(`‚úÖ Exact Quranic pattern match: "${pronunciation}" ‚Üí "${arabic}"`);
                    this.processSequentialWord(arabic);
                    return true;
                }
            }
            
            // Check for fuzzy matches with enhanced accuracy
            for (const [pronunciation, arabic] of Object.entries(quranicLetterMappings)) {
                const similarity = this.calculateAdvancedSimilarity(normalized, pronunciation);
                if (similarity >= 0.6) { // Higher threshold for special patterns
                    console.log(`‚úÖ Fuzzy Quranic pattern match: "${pronunciation}" ‚Üí "${arabic}" (similarity: ${similarity.toFixed(2)})`);
                    this.processSequentialWord(arabic);
                    return true;
                }
            }
            
            // Check for partial matches in the transcript
            for (const [pronunciation, arabic] of Object.entries(quranicLetterMappings)) {
                if (normalized.includes(pronunciation) || pronunciation.includes(normalized)) {
                    console.log(`‚úÖ Partial Quranic pattern match: "${pronunciation}" ‚Üí "${arabic}"`);
                    this.processSequentialWord(arabic);
                    return true;
                }
            }
            
            return false; // No special pattern found
        },
        
        // Parse individual Quranic letters from speech
        parseQuranicLetters(speech) {
            const words = [];
            const normalized = speech.toLowerCase().trim();
            
            // Individual letter mappings
            const letterMappings = {
                'alif': 'ÿß', 'alef': 'ÿß', 'ÿ£ŸÑŸÅ': 'ÿß',
                'ba': 'ÿ®', 'baa': 'ÿ®', 'ÿ®ÿßÿ°': 'ÿ®',
                'ta': 'ÿ™', 'taa': 'ÿ™', 'ÿ™ÿßÿ°': 'ÿ™',
                'tha': 'ÿ´', 'thaa': 'ÿ´', 'ÿ´ÿßÿ°': 'ÿ´',
                'jim': 'ÿ¨', 'jeem': 'ÿ¨', 'ÿ¨ŸäŸÖ': 'ÿ¨',
                'ha': 'ÿ≠', 'haa': 'ÿ≠', 'ÿ≠ÿßÿ°': 'ÿ≠',
                'kha': 'ÿÆ', 'khaa': 'ÿÆ', 'ÿÆÿßÿ°': 'ÿÆ',
                'dal': 'ÿØ', 'ÿØÿßŸÑ': 'ÿØ',
                'thal': 'ÿ∞', 'zal': 'ÿ∞', 'ÿ∞ÿßŸÑ': 'ÿ∞',
                'ra': 'ÿ±', 'raa': 'ÿ±', 'ÿ±ÿßÿ°': 'ÿ±',
                'zay': 'ÿ≤', 'za': 'ÿ≤', 'ÿ≤ÿßŸä': 'ÿ≤',
                'sin': 'ÿ≥', 'seen': 'ÿ≥', 'ÿ≥ŸäŸÜ': 'ÿ≥',
                'shin': 'ÿ¥', 'sheen': 'ÿ¥', 'ÿ¥ŸäŸÜ': 'ÿ¥',
                'sad': 'ÿµ', 'ÿµÿßÿØ': 'ÿµ',
                'dad': 'ÿ∂', 'daad': 'ÿ∂', 'ÿ∂ÿßÿØ': 'ÿ∂',
                'taa': 'ÿ∑', 'ÿ∑ÿßÿ°': 'ÿ∑',
                'zaa': 'ÿ∏', 'ÿ∏ÿßÿ°': 'ÿ∏',
                'ain': 'ÿπ', 'ÿπŸäŸÜ': 'ÿπ',
                'ghain': 'ÿ∫', 'ÿ∫ŸäŸÜ': 'ÿ∫',
                'fa': 'ŸÅ', 'faa': 'ŸÅ', 'ŸÅÿßÿ°': 'ŸÅ',
                'qaf': 'ŸÇ', 'ŸÇÿßŸÅ': 'ŸÇ',
                'kaf': 'ŸÉ', 'ŸÉÿßŸÅ': 'ŸÉ',
                'lam': 'ŸÑ', 'ŸÑÿßŸÖ': 'ŸÑ',
                'mim': 'ŸÖ', 'meem': 'ŸÖ', 'ŸÖŸäŸÖ': 'ŸÖ',
                'nun': 'ŸÜ', 'noon': 'ŸÜ', 'ŸÜŸàŸÜ': 'ŸÜ',
                'ha': 'Ÿá', 'haa': 'Ÿá', 'Ÿáÿßÿ°': 'Ÿá',
                'waw': 'Ÿà', 'ŸàÿßŸà': 'Ÿà',
                'ya': 'Ÿä', 'yaa': 'Ÿä', 'Ÿäÿßÿ°': 'Ÿä'
            };
            
            // Check if speech contains individual letter names
            for (const [letterName, arabic] of Object.entries(letterMappings)) {
                if (normalized.includes(letterName)) {
                    words.push(arabic);
                }
            }
            
            return words;
        },
        
        // Enhanced sequence processing for fast recitation
        processWordSequence(spokenWords) {
            console.log('Processing word sequence:', spokenWords);
            
            // Try to match each word in sequence
            spokenWords.forEach(word => {
                if (word && word.trim().length > 0) {
                    this.processSequentialWord(word.trim());
                }
            });
            
            // Also try to match combined words for connected speech
            if (spokenWords.length > 1) {
                const combined = spokenWords.join('');
                if (combined.length > 2) {
                    this.processSequentialWord(combined);
                }
            }
        },
        
        // Show interim feedback for better user experience
        showInterimFeedback(transcript) {
            const feedbackEl = document.getElementById('speech-interim-feedback');
            if (feedbackEl) {
                feedbackEl.textContent = transcript;
                feedbackEl.style.opacity = '0.7';
                
                // Clear after a short time if no final result
                clearTimeout(this.interimFeedbackTimeout);
                this.interimFeedbackTimeout = setTimeout(() => {
                    feedbackEl.style.opacity = '0.3';
                }, 1000);
            }
        },
        
        // Ultra-responsive sequential word processing
        processSequentialWord(spokenWord) {
            // Very short duplicate filtering for maximum responsiveness
            const now = Date.now();
            if (this.lastProcessedWord && this.lastProcessedWord.word === spokenWord && 
                (now - this.lastProcessedWord.time) < 200) { // Reduced to 200ms for maximum responsiveness
                console.log('Skipping very recent duplicate word:', spokenWord);
                return;
            }
            
            this.lastProcessedWord = { word: spokenWord, time: now };
            
            // Process the word immediately
            this.checkSingleWord(spokenWord);
        },
        
        // ŸÖŸÇÿßÿ±ŸÜÿ© ÿ±ÿ¶Ÿäÿ≥Ÿäÿ© ŸÑŸÑŸÉŸÑŸÖÿßÿ™ (Ÿäÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ™ÿ¨ŸàŸäÿØ)
        compareWords(spoken, correct) {
            return this.compareWordsTajweed(spoken, correct);
        },
        
        checkSingleWord(spokenWord) {
            if (state.memorizationStats.currentWordIndex >= state.currentMemorizationWords.length) {
                // ÿßŸÜÿ™ŸáŸâ ÿßŸÑÿ≠ŸÅÿ∏
                this.completeMemorization();
                return;
            }
            
            const currentWordIndex = state.memorizationStats.currentWordIndex;
            const correctWord = state.currentMemorizationWords[currentWordIndex];
            const wordElements = document.querySelectorAll('.ayah-word');
            const currentElement = wordElements[currentWordIndex];
            
            console.log(`Checking: "${spokenWord}" vs "${correctWord}"`);
            
            // ŸÖŸÇÿßÿ±ŸÜÿ© ÿßŸÑŸÉŸÑŸÖÿßÿ™ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ™ÿ¨ŸàŸäÿØ ÿßŸÑŸÖÿ≠ÿ≥ŸëŸÜ
            const isCorrect = this.compareWordsTajweed(spokenWord, correctWord);
            
            // ÿ™ÿ≠ÿØŸäÿ´ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ™ÿ¥ÿÆŸäÿµ
            this.updateDebugInfo(spokenWord, isCorrect);
            
            // ÿ™ÿ≠ÿØŸäÿ´: ÿØÿπŸÖ ÿßŸÑŸàÿßÿ¨Ÿáÿ© ÿßŸÑŸÖŸÜŸÅÿµŸÑÿ©
            const isMemorizationInterface = !document.getElementById('memorization-interface').classList.contains('hidden');
            if (isMemorizationInterface) {
                const memorizationWords = document.querySelectorAll('#memorization-page-content .ayah-word');
                const memCurrentElement = memorizationWords[currentWordIndex];
                if (memCurrentElement) {
                    // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿπŸÜÿßÿµÿ± Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑÿ≠ŸÅÿ∏
                    const memWordElements = document.querySelectorAll('#memorization-page-content .ayah-word');
                    memWordElements.forEach(el => {
                        el.classList.remove('waiting', 'current');
                    });
                    
                    if (isCorrect) {
                        memCurrentElement.classList.remove('hidden', 'incorrect');
                        memCurrentElement.classList.add('revealed');
                        
                        if (state.memorizationStats.currentWordIndex < memWordElements.length) {
                            setTimeout(() => {
                                memWordElements[state.memorizationStats.currentWordIndex].classList.add('waiting');
                            }, 500);
                        }
                    } else {
                        if (state.memorizationSettings.autoRepeat) {
                            memCurrentElement.classList.remove('hidden');
                            memCurrentElement.classList.add('incorrect');
                            setTimeout(() => {
                                memCurrentElement.classList.add('hidden');
                                memCurrentElement.classList.remove('incorrect');
                                memCurrentElement.classList.add('waiting');
                            }, 2000);
                        } else {
                            memCurrentElement.classList.add('waiting');
                        }
                    }
                    
                    // ÿ™ÿ≠ÿØŸäÿ´ ÿπÿ±ÿ∂ ÿßŸÑÿ™ŸÇÿØŸÖ
                    this.updateMemorizationProgressDisplay();
                }
            }
            
            if (!currentElement) {
                console.log('No current element found');
                return;
            }
            
            // ÿ•ÿ≤ÿßŸÑÿ© ÿ¨ŸÖŸäÿπ ÿßŸÑÿ≠ÿßŸÑÿßÿ™ ÿßŸÑÿ≥ÿßÿ®ŸÇÿ©
            wordElements.forEach(el => {
                el.classList.remove('waiting', 'current');
            });
            
            if (isCorrect) {
                // ŸÉŸÑŸÖÿ© ÿµÿ≠Ÿäÿ≠ÿ© - ÿ•ÿ∏Ÿáÿßÿ±Ÿáÿß ŸÅŸàÿ±ÿßŸã ŸÖÿπ ÿßŸÑŸÖÿ≠ÿßŸÅÿ∏ÿ© ÿπŸÑŸâ ÿßŸÑŸÜÿµ ÿßŸÑŸÇÿ±ÿ¢ŸÜŸä
                currentElement.classList.remove('hidden', 'incorrect', 'waiting');
                currentElement.classList.add('revealed');
                
                state.memorizationStats.correctWords++;
                state.memorizationStats.currentWordIndex++;
                
                // ÿ™ÿ¥ÿ∫ŸäŸÑ ÿµŸàÿ™ ŸÜÿ¨ÿßÿ≠
                if (state.memorizationSettings.soundAlerts) {
                    this.playSuccessSound();
                }
                
                // ÿ™ÿ≠ÿ∂Ÿäÿ± ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ©
                if (state.memorizationStats.currentWordIndex < wordElements.length) {
                    setTimeout(() => {
                        wordElements[state.memorizationStats.currentWordIndex].classList.add('waiting');
                    }, 100);
                }
                
                console.log(`Word "${spokenWord}" is CORRECT!`);
            } else {
                // ŸÉŸÑŸÖÿ© ÿÆÿßÿ∑ÿ¶ÿ©
                state.memorizationStats.incorrectWords++;
                
                // ÿπÿ±ÿ∂ ÿßŸÑÿÆÿ∑ÿ£ ŸÖÿπ ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©
                const error = {
                    spoken: spokenWord,
                    correct: correctWord,
                    index: currentWordIndex
                };
                state.memorizationStats.errors.push(error);
                
                // ÿ™ÿ¥ÿ∫ŸäŸÑ ÿµŸàÿ™ ÿÆÿ∑ÿ£
                if (state.memorizationSettings.soundAlerts) {
                    this.playErrorSound();
                }
                
                // ÿπÿ±ÿ∂ ÿßŸÑÿÆÿ∑ÿ£
                this.showError(error);
                
                // ÿπÿ±ÿ∂ ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ© ŸÑŸÅÿ™ÿ±ÿ© ŸÇÿµŸäÿ±ÿ© ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÖŸÅÿπŸëŸÑ
                if (state.memorizationSettings.autoRepeat) {
                    // ÿ•ÿ∏Ÿáÿßÿ± ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ© ŸÑÿ´ÿßŸÜŸäÿ™ŸäŸÜ
                    currentElement.classList.remove('hidden');
                    currentElement.classList.add('incorrect');
                    
                    setTimeout(() => {
                        currentElement.classList.add('hidden');
                        currentElement.classList.remove('incorrect');
                        currentElement.classList.add('waiting');
                    }, 2000);
                } else {
                    currentElement.classList.add('waiting');
                }
                
                console.log(`Word "${spokenWord}" is INCORRECT. Expected: "${correctWord}"`);
            }
            
            // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿπÿ±ÿ∂
            this.updateMemorizationDisplay();
            // Debug info already updated above with comparison result
        },
        
        normalizeTajweed(text) {
            // ÿ™ÿ∑ÿ®Ÿäÿπ ŸÖÿ≠ÿ≥ŸëŸÜ ŸÑŸÑÿ™ÿ¨ŸàŸäÿØ - Ÿäÿ≠ÿßŸÅÿ∏ ÿπŸÑŸâ ÿßŸÑÿßÿÆÿ™ŸÑÿßŸÅÿßÿ™ ÿßŸÑŸÖŸáŸÖÿ©
            return text
                // ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿ™ÿ¥ŸÉŸäŸÑ ÿßŸÑŸÅÿ±ÿπŸä ŸÖÿπ ÿßŸÑŸÖÿ≠ÿßŸÅÿ∏ÿ© ÿπŸÑŸâ ÿßŸÑŸÖŸáŸÖ
                .replace(/[\u064B\u064C\u064D\u064E\u064F\u0650\u0651\u0652]/g, '') // ÿ™ŸÜŸàŸäŸÜ Ÿàÿ≠ÿ±ŸÉÿßÿ™
                .replace(/[\u0653\u0654\u0655\u0656\u0657\u0658\u0659\u065A]/g, '') // ÿπŸÑÿßŸÖÿßÿ™ ÿ•ÿ∂ÿßŸÅŸäÿ©
                .replace(/[\u065B\u065C\u065D\u065E\u065F]/g, '') // ÿπŸÑÿßŸÖÿßÿ™ ÿ£ÿÆÿ±Ÿâ
                .replace(/\u0640/g, '') // ÿ™ÿ∑ŸàŸäŸÑ
                .replace(/[\u06D6-\u06ED]/g, '') // ÿπŸÑÿßŸÖÿßÿ™ ÿßŸÑŸàŸÇŸÅ
                // ÿßŸÑŸÖÿ≠ÿßŸÅÿ∏ÿ© ÿπŸÑŸâ ÿßŸÑÿ£ŸÑŸÅ ÿßŸÑÿÆŸÜÿ¨ÿ±Ÿäÿ© ŸÑŸÉŸÜ ŸÖÿπ ŸÖÿ±ŸàŸÜÿ©
                .replace(/\u0670/g, 'ÿß') // ÿ£ŸÑŸÅ ÿÆŸÜÿ¨ÿ±Ÿäÿ© ‚Üí ÿ£ŸÑŸÅ
                // ÿ™Ÿàÿ≠ŸäÿØ ÿ£ÿ¥ŸÉÿßŸÑ ÿßŸÑŸáŸÖÿ≤ÿ© ŸÖÿπ ŸÖÿ±ÿßÿπÿßÿ© ÿßŸÑŸÜÿ∑ŸÇ
                .replace(/[\u0622\u0623\u0625]/g, 'ÿß') // ÿ¢ ÿ£ ÿ• ‚Üí ÿß
                .replace(/\u0624/g, 'Ÿà') // ÿ§ ‚Üí Ÿà
                .replace(/\u0626/g, 'Ÿä') // ÿ¶ ‚Üí Ÿä
                // ÿ™Ÿàÿ≠ŸäÿØ ÿßŸÑÿ™ÿßÿ° ŸàÿßŸÑŸáÿßÿ°
                .replace(/\u0629/g, 'Ÿá') // ÿ© ‚Üí Ÿá
                // ÿ™Ÿàÿ≠ŸäÿØ ÿ£ÿ¥ŸÉÿßŸÑ ÿßŸÑŸäÿßÿ°
                .replace(/\u0649/g, 'Ÿä') // Ÿâ ‚Üí Ÿä
                // ÿ™ŸÜÿ∏ŸäŸÅ ÿπÿßŸÖ
                .replace(/[\u200C\u200D\u200E\u200F]/g, '') // ÿ•ÿ≤ÿßŸÑÿ© ÿ£ÿ≠ÿ±ŸÅ ÿßŸÑÿ™ÿ≠ŸÉŸÖ
                .trim()
                .replace(/\s+/g, ' ')
                .toLowerCase();
        },
        
        // Convert Quranic text with diacritics to plain Arabic text
        convertToPlainText(quranicText) {
            return quranicText
                // Remove all diacritical marks
                .replace(/[\u064B-\u0652\u0670\u0653-\u065F]/g, '') // Remove tashkeel
                .replace(/\u0640/g, '') // Remove tatweel (elongation)
                .replace(/[\u06D6-\u06ED]/g, '') // Remove Quranic punctuation
                .replace(/[\u08F0-\u08FF]/g, '') // Remove additional Arabic marks
                
                // Normalize different forms of the same letter
                .replace(/[\u0622\u0623\u0625]/g, 'ÿß') // ÿ¢ ÿ£ ÿ• ‚Üí ÿß
                .replace(/\u0624/g, 'Ÿà') // ÿ§ ‚Üí Ÿà  
                .replace(/\u0626/g, 'Ÿä') // ÿ¶ ‚Üí Ÿä
                .replace(/\u0629/g, 'ÿ©') // Keep ÿ© as ÿ© for display
                .replace(/[\u0649\u064A]/g, 'Ÿä') // Ÿâ Ÿä ‚Üí Ÿä
                
                // Handle special Quranic cases
                .replace(/\u0671/g, 'ÿß') // Ÿ± ‚Üí ÿß (Alif wasla)
                .replace(/[\u06C0\u06C1]/g, 'Ÿá') // Different heh forms
                
                // Clean up spaces and control characters
                .replace(/[\u200C\u200D\u200E\u200F]/g, '') // Remove invisible characters
                .trim();
        },
        
        // Check if a string contains actual Arabic words (not just diacritics or punctuation)
        isActualWord(text) {
            // Must contain at least one Arabic letter
            const hasArabicLetter = /[\u0621-\u063A\u0641-\u064A]/g.test(text);
            // Must not be just punctuation or very short
            const isNotJustPunctuation = text.length > 0 && !/^[\s\u06D6-\u06ED\u064B-\u0652]*$/.test(text);
            return hasArabicLetter && isNotJustPunctuation;
        },
        
        // Enhanced Arabic text normalization for better Quranic recitation recognition
        normalizeQuranText(text) {
            // Comprehensive normalization specifically for Quranic text
            return text
                // Remove all diacritical marks but preserve structure
                .replace(/[\u064B-\u0652\u0670\u0653-\u065F]/g, '') // Remove tashkeel
                .replace(/\u0640/g, '') // Remove tatweel (elongation)
                .replace(/[\u06D6-\u06ED]/g, '') // Remove Quranic punctuation
                .replace(/[\u08F0-\u08FF]/g, '') // Remove additional Arabic marks
                
                // Normalize different forms of the same letter
                .replace(/[\u0622\u0623\u0625]/g, 'ÿß') // ÿ¢ ÿ£ ÿ• ‚Üí ÿß
                .replace(/\u0624/g, 'Ÿà') // ÿ§ ‚Üí Ÿà  
                .replace(/\u0626/g, 'Ÿä') // ÿ¶ ‚Üí Ÿä
                .replace(/\u0629/g, 'Ÿá') // ÿ© ‚Üí Ÿá
                .replace(/[\u0649\u064A]/g, 'Ÿä') // Ÿâ Ÿä ‚Üí Ÿä
                
                // Handle special Quranic cases
                .replace(/\u0671/g, 'ÿß') // Ÿ± ‚Üí ÿß (Alif wasla)
                .replace(/[\u06C0\u06C1]/g, 'Ÿá') // Different heh forms
                
                // Clean up spaces and control characters
                .replace(/[\u200C\u200D\u200E\u200F]/g, '') // Remove invisible characters
                .replace(/\s+/g, ' ') // Normalize spaces
                .trim()
                .toLowerCase();
        },
        
        // üéØ Simplified and Enhanced Comparison Logic
        compareWordsTajweed(spoken, correct, confidence = 1.0) {
            // 1. Unified normalization approach - single powerful function
            const normalizedSpoken = this.normalizeArabicText(spoken);
            const normalizedCorrect = this.normalizeArabicText(correct);
            
            console.log(`üîç Comparing: "${spoken}" vs "${correct}"`);
            console.log(`üìù Normalized: "${normalizedSpoken}" vs "${normalizedCorrect}"`);
            
            // 2. Direct exact match (highest accuracy)
            if (normalizedSpoken === normalizedCorrect) {
                console.log('‚úÖ Exact normalized match');
                return true;
            }
            
            // 3. Sequence matching for connected speech
            if (this.isSequenceMatch(normalizedSpoken, normalizedCorrect)) {
                console.log('‚úÖ Sequence match found');
                return true;
            }
            
            // 4. Prefix matching for partial speech
            if (this.isPrefixMatch(normalizedSpoken, normalizedCorrect)) {
                console.log('‚úÖ Prefix match found');
                return true;
            }
            
            // 5. Intelligent similarity with dynamic threshold
            const similarity = this.calculateSimilarity(normalizedSpoken, normalizedCorrect);
            const threshold = this.getAdaptiveThreshold(normalizedCorrect.length, confidence);
            
            console.log(`üìä Similarity: ${similarity.toFixed(3)}, Threshold: ${threshold.toFixed(3)}`);
            
            if (similarity >= threshold) {
                console.log('‚úÖ Similarity match');
                return true;
            }
            
            console.log('‚ùå No match found');
            return false;
        },
        
        // üîó Sequence Matching for Connected Speech
        isSequenceMatch(spoken, correct) {
            // Handle cases where user combines words or speaks continuously
            const spokenLength = spoken.length;
            const correctLength = correct.length;
            
            // Check if spoken text appears at the beginning of expected sequence
            if (spokenLength >= 2 && correctLength >= 2) {
                if (correct.startsWith(spoken) || spoken.startsWith(correct)) {
                    return true;
                }
                
                // Check for core overlap (60% or more)
                const minLength = Math.min(spokenLength, correctLength);
                const overlapLength = Math.floor(minLength * 0.6);
                
                if (overlapLength >= 2) {
                    const spokenCore = spoken.substring(0, overlapLength);
                    const correctCore = correct.substring(0, overlapLength);
                    
                    if (spokenCore === correctCore) {
                        return true;
                    }
                }
            }
            
            return false;
        },
        
        // üìç Prefix Matching for Partial Speech
        isPrefixMatch(spoken, correct) {
            const minLength = Math.min(spoken.length, correct.length);
            
            // Require at least 2 characters for meaningful prefix
            if (minLength >= 2) {
                // Check if one is a prefix of the other
                if (spoken.length <= correct.length) {
                    return correct.startsWith(spoken);
                } else {
                    return spoken.startsWith(correct);
                }
            }
            
            return false;
        },
        
        // üéØ Adaptive Threshold Based on Word Length and Confidence
        getAdaptiveThreshold(wordLength, confidence) {
            let baseThreshold = 0.7;
            
            // Adjust based on word length
            if (wordLength <= 2) {
                baseThreshold = 0.8; // Stricter for short words
            } else if (wordLength <= 4) {
                baseThreshold = 0.7; // Standard for medium words  
            } else {
                baseThreshold = 0.6; // More lenient for long words
            }
            
            // Adjust based on speech recognition confidence
            const confidenceBonus = (confidence - 0.5) * 0.2;
            baseThreshold = Math.max(0.4, Math.min(0.9, baseThreshold + confidenceBonus));
            
            return baseThreshold;
        },
        
        // üéØ Evaluate Transcript Quality for Best Alternative Selection
        evaluateTranscriptQuality(transcript, confidence) {
            const normalized = this.normalizeArabicText(transcript);
            let score = confidence * 0.6; // Base confidence weight
            
            // Bonus for Arabic content
            const arabicRatio = (transcript.match(/[ÿ°-ÿ∫ŸÅ-Ÿä]/g) || []).length / transcript.length;
            score += arabicRatio * 0.2;
            
            // Bonus for reasonable length
            if (normalized.length >= 2 && normalized.length <= 10) {
                score += 0.1;
            }
            
            // Bonus if it matches common Quranic patterns
            if (this.isLikelyQuranicWord(normalized)) {
                score += 0.1;
            }
            
            return score;
        },
        
        // üîç Check if word is likely Quranic
        isLikelyQuranicWord(word) {
            const commonQuranicWords = [
                'ÿßŸÑŸÑŸá', 'ÿßŸÑÿ±ÿ≠ŸÖŸÜ', 'ÿßŸÑÿ±ÿ≠ŸäŸÖ', 'ÿ±ÿ®', 'ÿßŸÑÿπÿßŸÑŸÖŸäŸÜ',
                'ÿßŸÑÿ≠ŸÖÿØ', 'ŸÖÿßŸÑŸÉ', 'ŸäŸàŸÖ', 'ÿßŸÑÿØŸäŸÜ', 'ÿ•ŸäÿßŸÉ',
                'ŸÜÿπÿ®ÿØ', 'ŸÜÿ≥ÿ™ÿπŸäŸÜ', 'ÿßŸáÿØŸÜÿß', 'ÿßŸÑÿµÿ±ÿßÿ∑',
                'ÿßŸÑŸÖÿ≥ÿ™ŸÇŸäŸÖ', 'ÿßŸÑÿ∞ŸäŸÜ', 'ÿßŸÜÿπŸÖÿ™', 'ÿπŸÑŸäŸáŸÖ',
                'ÿ®ÿ≥ŸÖ', 'ŸàŸÑÿß', 'ŸÑŸäÿ≥', 'ÿßŸÑÿ∂ÿßŸÑŸäŸÜ'
            ];
            
            // Check exact match or prefix match
            return commonQuranicWords.some(qWord => 
                qWord === word || qWord.startsWith(word) || word.startsWith(qWord)
            );
        },
        
        // üîó Process Sequential Text (Improved from word-by-word)
        processSequentialText(transcript, confidence, processingStart) {
            console.log(`üîó Sequential processing: "${transcript}" with confidence: ${confidence}`);
            
            // Update display immediately
            const lastHeardEl = document.getElementById('last-heard-word');
            if (lastHeardEl) {
                lastHeardEl.textContent = transcript;
            }
            
            // üéØ First check for special Quranic patterns
            if (this.processSpecialQuranicPatterns(transcript)) {
                console.log('üéØ Special Quranic pattern processed');
                return;
            }
            
            // üîó Try sequence matching with remaining text
            if (this.trySequenceMatching(transcript, confidence)) {
                console.log('üîó Sequence matching successful');
                return;
            }
            
            // üîÑ Fallback to individual word processing if sequence fails
            const words = transcript.trim().split(/\s+/);
            words.forEach(word => {
                if (word && word.length > 0) {
                    this.processSequentialWordUltraFast(word.trim());
                }
            });
            
            // üìä Performance tracking
            const totalTime = performance.now() - processingStart;
            console.log(`üìä Sequential processing completed in ${totalTime.toFixed(2)}ms`);
        },
        
        // üîó Try Sequence Matching with Remaining Text
        trySequenceMatching(transcript, confidence) {
            if (state.memorizationStats.currentWordIndex >= state.currentMemorizationWords.length) {
                return false;
            }
            
            const normalizedTranscript = this.normalizeArabicText(transcript);
            
            // Get remaining text from current position
            const remainingWords = state.currentMemorizationWords.slice(state.memorizationStats.currentWordIndex);
            const remainingText = remainingWords.slice(0, 5).join(' '); // Look ahead 5 words
            const normalizedRemaining = this.normalizeArabicText(remainingText);
            
            console.log(`üîç Sequence check: "${normalizedTranscript}" vs "${normalizedRemaining}"`);
            
            // Check if transcript matches beginning of remaining text
            if (this.isSequenceMatch(normalizedTranscript, normalizedRemaining)) {
                // Calculate how many words this covers
                const wordsMatched = this.calculateWordsMatched(normalizedTranscript, remainingWords);
                
                if (wordsMatched > 0) {
                    console.log(`‚úÖ Sequence matched ${wordsMatched} words`);
                    
                    // Mark words as correct
                    for (let i = 0; i < wordsMatched; i++) {
                        this.processCorrectWordUltraFast(remainingWords[i]);
                    }
                    
                    return true;
                }
            }
            
            return false;
        },
        
        // üìä Calculate How Many Words Were Matched
        calculateWordsMatched(transcript, remainingWords) {
            let totalMatched = 0;
            let accumulatedText = '';
            
            for (let i = 0; i < Math.min(remainingWords.length, 5); i++) {
                accumulatedText += (i > 0 ? ' ' : '') + remainingWords[i];
                const normalizedAccumulated = this.normalizeArabicText(accumulatedText);
                
                // Check if transcript still matches or is contained in accumulated text
                if (normalizedAccumulated.startsWith(transcript) || 
                    transcript.startsWith(normalizedAccumulated) ||
                    this.calculateSimilarity(transcript, normalizedAccumulated) >= 0.7) {
                    totalMatched = i + 1;
                } else {
                    break;
                }
            }
            
            return totalMatched;
        },
        
        // üîç Process Interim Sequence (for partial results)
        processInterimSequence(transcript, confidence) {
            const normalizedTranscript = this.normalizeArabicText(transcript);
            
            // Show interim feedback with sequence preview
            if (state.memorizationStats.currentWordIndex < state.currentMemorizationWords.length) {
                const remainingWords = state.currentMemorizationWords.slice(state.memorizationStats.currentWordIndex, state.memorizationStats.currentWordIndex + 3);
                const expectedSequence = this.normalizeArabicText(remainingWords.join(' '));
                
                if (expectedSequence.startsWith(normalizedTranscript) && normalizedTranscript.length >= 2) {
                    this.showSequenceFeedback(`üéØ ŸÖÿ™ÿ∑ÿßÿ®ŸÇ: ${transcript}...`, '#22c55e');
                } else {
                    this.showSequenceFeedback(`üéôÔ∏è ${transcript}`, '#8b5cf6');
                }
            }
        },
        
        // üéØ Enhanced Interim Feedback
        showEnhancedInterimFeedback(transcript, processingTime) {
            this.showSequenceFeedback(`üéôÔ∏è ${transcript} (‚ö°${processingTime.toFixed(0)}ms)`, '#3b82f6');
        },
        
        // üéÜ Unified Sequence Feedback Display
        showSequenceFeedback(message, color = '#10b981', duration = 1000) {
            const feedbackEl = document.getElementById('speech-interim-feedback');
            if (feedbackEl) {
                feedbackEl.textContent = message;
                feedbackEl.style.color = color;
                feedbackEl.style.opacity = '1';
                feedbackEl.style.transform = 'scale(1.02)';
                feedbackEl.style.transition = 'all 0.15s ease';
                
                clearTimeout(this.sequenceFeedbackTimeout);
                this.sequenceFeedbackTimeout = setTimeout(() => {
                    feedbackEl.style.opacity = '0.3';
                    feedbackEl.style.transform = 'scale(1)';
                }, duration);
            }
        },
        
        // Enhanced function for fast recitation pattern matching
        isFastRecitationMatch(spoken, quranicCorrect, plainCorrect) {
            // Check for common fast recitation patterns
            const spokenShort = spoken.substring(0, Math.min(3, spoken.length));
            const quranicShort = quranicCorrect.substring(0, Math.min(3, quranicCorrect.length));
            const plainShort = plainCorrect.substring(0, Math.min(3, plainCorrect.length));
            
            // Beginning match for fast reading
            if (spokenShort === quranicShort || spokenShort === plainShort) {
                return true;
            }
            
            // Check if spoken word contains core of the correct word
            const coreLength = Math.floor(Math.max(quranicCorrect.length, plainCorrect.length) * 0.6);
            if (coreLength >= 2) {
                const quranicCore = quranicCorrect.substring(0, coreLength);
                const plainCore = plainCorrect.substring(0, coreLength);
                
                if (spoken.includes(quranicCore) || spoken.includes(plainCore) ||
                    quranicCorrect.includes(spoken) || plainCorrect.includes(spoken)) {
                    return true;
                }
            }
            
            // Fuzzy matching for connected speech in fast recitation
            const fuzzyThreshold = 0.5;
            const fuzzyQuranic = this.calculateAdvancedSimilarity(spoken, quranicCorrect);
            const fuzzyPlain = this.calculateAdvancedSimilarity(spoken, plainCorrect);
            
            return Math.max(fuzzyQuranic, fuzzyPlain) >= fuzzyThreshold;
        },
        
        // Ultra-fast speech matching for immediate recognition
        isUltraFastSpeechMatch(spoken, quranicCorrect, plainCorrect) {
            // For ultra-fast speech, check minimal patterns
            if (spoken.length >= 1 && (quranicCorrect.length >= 1 || plainCorrect.length >= 1)) {
                // Single character match for very fast speech
                const spokenFirst = spoken.charAt(0);
                const quranicFirst = quranicCorrect.charAt(0);
                const plainFirst = plainCorrect.charAt(0);
                
                if (spokenFirst === quranicFirst || spokenFirst === plainFirst) {
                    return true;
                }
            }
            
            // Ultra-aggressive substring matching
            const minLength = Math.min(spoken.length, Math.max(quranicCorrect.length, plainCorrect.length));
            if (minLength >= 2) {
                const spokenSub = spoken.substring(0, Math.ceil(minLength * 0.6));
                const quranicSub = quranicCorrect.substring(0, Math.ceil(minLength * 0.6));
                const plainSub = plainCorrect.substring(0, Math.ceil(minLength * 0.6));
                
                if (spokenSub === quranicSub || spokenSub === plainSub) {
                    return true;
                }
            }
            
            // Check if any part of spoken word exists in correct words
            if (spoken.length >= 2) {
                for (let i = 0; i <= spoken.length - 2; i++) {
                    const fragment = spoken.substring(i, i + 2);
                    if (quranicCorrect.includes(fragment) || plainCorrect.includes(fragment)) {
                        return true;
                    }
                }
            }
            
            // Ultra-lenient similarity for any resemblance
            const ultraFuzzyThreshold = 0.3;
            const ultraFuzzyQuranic = this.calculateAdvancedSimilarity(spoken, quranicCorrect);
            const ultraFuzzyPlain = this.calculateAdvancedSimilarity(spoken, plainCorrect);
            
            return Math.max(ultraFuzzyQuranic, ultraFuzzyPlain) >= ultraFuzzyThreshold;
        },
        
        arePhoneticallySimilarTajweed(word1, word2) {
            // ŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑÿ≠ÿ±ŸàŸÅ ÿßŸÑŸÖÿ™ÿ¥ÿßÿ®Ÿáÿ© ÿµŸàÿ™ŸäÿßŸã ŸÅŸä ÿßŸÑÿ™ÿ¨ŸàŸäÿØ
            const similarGroups = [
                // ÿ≠ÿ±ŸàŸÅ ÿßŸÑÿ•ÿ∑ÿ®ÿßŸÇ
                ['ÿ™', 'ÿ∑'], // ÿ™ Ÿà ÿ∑
                ['ÿØ', 'ÿ∂'], // ÿØ Ÿà ÿ∂
                ['ÿ≥', 'ÿµ'], // ÿ≥ Ÿà ÿµ
                ['ÿ´', 'ÿ∏'], // ÿ´ Ÿà ÿ∏
                // ÿ≠ÿ±ŸàŸÅ ŸÖÿ™ÿ¥ÿßÿ®Ÿáÿ© ÿ£ÿÆÿ±Ÿâ
                ['Ÿá', 'ÿ≠'], // Ÿá Ÿà ÿ≠
                ['ŸÇ', 'ŸÉ'], // ŸÇ Ÿà ŸÉ
                ['ÿ∞', 'ÿ≤'], // ÿ∞ Ÿà ÿ≤
                ['ÿ∫', 'ÿÆ'], // ÿ∫ Ÿà ÿÆ
                ['ŸÅ', 'ÿ®'], // ŸÅ Ÿà ÿ® (ŸÅŸä ÿ®ÿπÿ∂ ÿßŸÑŸÑŸáÿ¨ÿßÿ™)
                ['ÿ¨', 'ÿ¥'], // ÿ¨ Ÿà ÿ¥
                ['ÿ±', 'ŸÑ'], // ÿ± Ÿà ŸÑ (ÿ£ÿ≠ŸäÿßŸÜÿßŸã)
            ];
            
            let substituted1 = word1;
            let substituted2 = word2;
            
            // ÿßÿ≥ÿ™ÿ®ÿØÿßŸÑ ÿßŸÑÿ≠ÿ±ŸàŸÅ ÿßŸÑŸÖÿ™ÿ¥ÿßÿ®Ÿáÿ©
            similarGroups.forEach(group => {
                group.forEach(char => {
                    substituted1 = substituted1.replace(new RegExp(char, 'g'), group[0]);
                    substituted2 = substituted2.replace(new RegExp(char, 'g'), group[0]);
                });
            });
            
            return substituted1 === substituted2;
        },
        
        getLevenshteinDistance(a, b) {
            const matrix = [];
            
            for (let i = 0; i <= b.length; i++) {
                matrix[i] = [i];
            }
            
            for (let j = 0; j <= a.length; j++) {
                matrix[0][j] = j;
            }
            
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    if (b.charAt(i - 1) === a.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            
            return matrix[b.length][a.length];
        },
        
        arePhoneticallySimilar(word1, word2) {
            // ŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑÿ≠ÿ±ŸàŸÅ ÿßŸÑŸÖÿ™ÿ¥ÿßÿ®Ÿáÿ© ÿµŸàÿ™ŸäÿßŸã
            const similarGroups = [
                ['ÿ™', 'ÿ∑'], // ÿ™ Ÿà ÿ∑
                ['ÿØ', 'ÿ∂'], // ÿØ Ÿà ÿ∂
                ['ÿ≥', 'ÿµ'], // ÿ≥ Ÿà ÿµ
                ['ÿ´', 'ÿ∏'], // ÿ´ Ÿà ÿ∏
                ['Ÿá', 'ÿ≠'], // Ÿá Ÿà ÿ≠
                ['ŸÇ', 'ŸÉ'], // ŸÇ Ÿà ŸÉ
                ['ÿ∞', 'ÿ≤'], // ÿ∞ Ÿà ÿ≤
            ];
            
            let substituted1 = word1;
            let substituted2 = word2;
            
            // ÿßÿ≥ÿ™ÿ®ÿØÿßŸÑ ÿßŸÑÿ≠ÿ±ŸàŸÅ ÿßŸÑŸÖÿ™ÿ¥ÿßÿ®Ÿáÿ©
            similarGroups.forEach(group => {
                group.forEach(char => {
                    substituted1 = substituted1.replace(new RegExp(char, 'g'), group[0]);
                    substituted2 = substituted2.replace(new RegExp(char, 'g'), group[0]);
                });
            });
            
            return substituted1 === substituted2;
        },
        
        calculateSimilarity(a, b) {
            const matrix = [];
            
            for (let i = 0; i <= b.length; i++) {
                matrix[i] = [i];
            }
            
            for (let j = 0; j <= a.length; j++) {
                matrix[0][j] = j;
            }
            
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    if (b.charAt(i - 1) === a.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            
            const maxLength = Math.max(a.length, b.length);
            return maxLength === 0 ? 1 : (maxLength - matrix[b.length][a.length]) / maxLength;
        },
        
        // Enhanced similarity calculation with multiple algorithms
        calculateAdvancedSimilarity(a, b) {
            if (!a || !b) return 0;
            if (a === b) return 1;
            
            // Multiple similarity calculations for highest accuracy
            const levenshtein = this.calculateLevenshteinSimilarity(a, b);
            const jaro = this.calculateJaroSimilarity(a, b);
            const phonetic = this.calculatePhoneticSimilarity(a, b);
            const substring = this.calculateSubstringSimilarity(a, b);
            
            // Weighted combination for optimal results
            const weightedScore = (
                levenshtein * 0.4 +    // 40% Levenshtein (exact matching)
                jaro * 0.3 +           // 30% Jaro (word structure)
                phonetic * 0.2 +       // 20% Phonetic (sound similarity)
                substring * 0.1        // 10% Substring (partial matching)
            );
            
            return Math.min(1, weightedScore);
        },
        
        // Levenshtein distance similarity
        calculateLevenshteinSimilarity(a, b) {
            const matrix = [];
            
            for (let i = 0; i <= b.length; i++) {
                matrix[i] = [i];
            }
            
            for (let j = 0; j <= a.length; j++) {
                matrix[0][j] = j;
            }
            
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    if (b.charAt(i - 1) === a.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            
            const maxLength = Math.max(a.length, b.length);
            return maxLength === 0 ? 1 : (maxLength - matrix[b.length][a.length]) / maxLength;
        },
        
        // Jaro similarity for word structure
        calculateJaroSimilarity(s1, s2) {
            if (s1 === s2) return 1;
            
            const len1 = s1.length;
            const len2 = s2.length;
            
            if (len1 === 0 || len2 === 0) return 0;
            
            const matchWindow = Math.floor(Math.max(len1, len2) / 2) - 1;
            const s1Matches = new Array(len1).fill(false);
            const s2Matches = new Array(len2).fill(false);
            
            let matches = 0;
            let transpositions = 0;
            
            // Find matches
            for (let i = 0; i < len1; i++) {
                const start = Math.max(0, i - matchWindow);
                const end = Math.min(i + matchWindow + 1, len2);
                
                for (let j = start; j < end; j++) {
                    if (s2Matches[j] || s1[i] !== s2[j]) continue;
                    s1Matches[i] = true;
                    s2Matches[j] = true;
                    matches++;
                    break;
                }
            }
            
            if (matches === 0) return 0;
            
            // Find transpositions
            let k = 0;
            for (let i = 0; i < len1; i++) {
                if (!s1Matches[i]) continue;
                while (!s2Matches[k]) k++;
                if (s1[i] !== s2[k]) transpositions++;
                k++;
            }
            
            return (matches / len1 + matches / len2 + (matches - transpositions / 2) / matches) / 3;
        },
        
        // Phonetic similarity for Arabic sounds
        calculatePhoneticSimilarity(a, b) {
            const phoneticA = this.getArabicPhoneticCode(a);
            const phoneticB = this.getArabicPhoneticCode(b);
            
            if (phoneticA === phoneticB) return 1;
            
            return this.calculateLevenshteinSimilarity(phoneticA, phoneticB);
        },
        
        // Arabic phonetic encoding
        getArabicPhoneticCode(word) {
            return word
                // Similar sounding Arabic letters
                .replace(/[ÿ™ÿ∑]/g, 't')      // ÿ™ ÿ∑
                .replace(/[ÿØÿ∂]/g, 'd')      // ÿØ ÿ∂
                .replace(/[ÿ≥ÿµ]/g, 's')      // ÿ≥ ÿµ
                .replace(/[ÿ´ÿ∏]/g, 'th')     // ÿ´ ÿ∏
                .replace(/[Ÿáÿ≠]/g, 'h')      // Ÿá ÿ≠
                .replace(/[ŸÇŸÉ]/g, 'k')      // ŸÇ ŸÉ
                .replace(/[ÿ∞ÿ≤]/g, 'z')      // ÿ∞ ÿ≤
                .replace(/[ÿ∫ÿÆ]/g, 'gh')     // ÿ∫ ÿÆ
                .replace(/[ŸÅÿ®]/g, 'f')      // ŸÅ ÿ® (sometimes)
                .replace(/[ÿ¨ÿ¥]/g, 'j')      // ÿ¨ ÿ¥
                .replace(/[ÿ±ŸÑ]/g, 'r');     // ÿ± ŸÑ (sometimes)
        },
        
        // Substring similarity
        calculateSubstringSimilarity(a, b) {
            if (a.length === 0 || b.length === 0) return 0;
            
            let maxMatch = 0;
            const minLen = Math.min(a.length, b.length);
            
            for (let len = minLen; len > 0; len--) {
                for (let i = 0; i <= a.length - len; i++) {
                    const substr = a.substring(i, i + len);
                    if (b.includes(substr)) {
                        maxMatch = Math.max(maxMatch, len);
                        break;
                    }
                }
                if (maxMatch === len) break;
            }
            
            return maxMatch / Math.max(a.length, b.length);
        },
        
        // Intelligent dynamic threshold calculation
        calculateDynamicThreshold(correctWord, spokenWord, confidence) {
            let baseThreshold = 0.7; // Start with high accuracy requirement
            
            // Adjust based on word length
            if (correctWord.length <= 2) {
                baseThreshold = 0.8; // Higher threshold for short words (more precision needed)
            } else if (correctWord.length <= 4) {
                baseThreshold = 0.7; // Standard threshold for medium words
            } else if (correctWord.length <= 6) {
                baseThreshold = 0.65; // Slightly lower for longer words
            } else {
                baseThreshold = 0.6; // Lower threshold for very long words
            }
            
            // Adjust based on speech recognition confidence
            const confidenceAdjustment = (confidence - 0.7) * 0.2; // -0.14 to +0.06 adjustment
            baseThreshold += confidenceAdjustment;
            
            // Adjust for common Quranic patterns
            if (this.isCommonQuranicWord(correctWord)) {
                baseThreshold -= 0.1; // More lenient for common words
            }
            
            // Adjust for special characters or patterns
            if (correctWord.includes('ÿßŸÑ') || correctWord.includes('ÿ®ÿßŸÑ')) {
                baseThreshold -= 0.05; // More lenient for words with definite articles
            }
            
            // Adjust based on speech length similarity
            const lengthRatio = Math.min(spokenWord.length, correctWord.length) / Math.max(spokenWord.length, correctWord.length);
            if (lengthRatio < 0.7) {
                baseThreshold += 0.1; // Stricter if lengths are very different
            }
            
            // Ensure threshold stays within reasonable bounds
            return Math.max(0.4, Math.min(0.9, baseThreshold));
        },
        
        // Check if word is a common Quranic word
        isCommonQuranicWord(word) {
            const commonWords = [
                'ÿßŸÑŸÑŸá', 'ÿßŸÑÿ±ÿ≠ŸÖŸÜ', 'ÿßŸÑÿ±ÿ≠ŸäŸÖ', 'ÿ±ÿ®', 'ÿßŸÑÿπÿßŸÑŸÖŸäŸÜ',
                'ÿßŸÑÿ≠ŸÖÿØ', 'ŸÖÿßŸÑŸÉ', 'ŸäŸàŸÖ', 'ÿßŸÑÿØŸäŸÜ', 'ÿ•ŸäÿßŸÉ',
                'ŸÜÿπÿ®ÿØ', 'ŸÜÿ≥ÿ™ÿπŸäŸÜ', 'ÿßŸáÿØŸÜÿß', 'ÿßŸÑÿµÿ±ÿßÿ∑',
                'ÿßŸÑŸÖÿ≥ÿ™ŸÇŸäŸÖ', 'ÿßŸÑÿ∞ŸäŸÜ', 'ÿ£ŸÜÿπŸÖÿ™', 'ÿπŸÑŸäŸáŸÖ',
                'ÿ∫Ÿäÿ±', 'ÿßŸÑŸÖÿ∫ÿ∂Ÿàÿ®', 'ÿßŸÑÿ∂ÿßŸÑŸäŸÜ', 'ÿ®ÿ≥ŸÖ',
                'ÿ∞ŸÑŸÉ', 'ÿßŸÑŸÉÿ™ÿßÿ®', 'ÿ±Ÿäÿ®', 'ŸÅŸäŸá', 'ŸáÿØŸâ'
            ];
            
            return commonWords.includes(word);
        },
        
        updateMemorizationDisplay() {
            // ÿ™ÿ≠ÿØŸäÿ´ ÿ¥ÿ±Ÿäÿ∑ ÿßŸÑÿ™ŸÇÿØŸÖ
            const progress = (state.memorizationStats.currentWordIndex / state.memorizationStats.totalWords) * 100;
            const progressEl = document.getElementById('memorization-progress');
            const totalEl = document.getElementById('memorization-total');
            const progressBarEl = document.getElementById('memorization-progress-bar');
            
            if (progressEl) progressEl.textContent = state.memorizationStats.currentWordIndex;
            if (totalEl) totalEl.textContent = state.memorizationStats.totalWords;
            if (progressBarEl) progressBarEl.style.width = progress + '%';
            
            // ÿ≠ÿ≥ÿßÿ® ÿßŸÑÿØŸÇÿ©
            const totalAttempts = state.memorizationStats.correctWords + state.memorizationStats.incorrectWords;
            state.memorizationStats.accuracy = totalAttempts > 0 ? 
                Math.round((state.memorizationStats.correctWords / totalAttempts) * 100) : 0;
            
            // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ŸÅŸä ÿßŸÑŸÑŸàÿ≠ÿ©
            const totalWordsEl = document.getElementById('memorization-total-words');
            const correctWordsEl = document.getElementById('memorization-correct-words');
            const incorrectWordsEl = document.getElementById('memorization-incorrect-words');
            const accuracyEl = document.getElementById('memorization-accuracy');
            
            if (totalWordsEl) totalWordsEl.textContent = state.memorizationStats.totalWords;
            if (correctWordsEl) correctWordsEl.textContent = state.memorizationStats.correctWords;
            if (incorrectWordsEl) incorrectWordsEl.textContent = state.memorizationStats.incorrectWords;
            if (accuracyEl) accuracyEl.textContent = state.memorizationStats.accuracy + '%';
        },
        
        updateDebugInfo(lastSpoken = null, comparisonResult = null) {
            const currentWordEl = document.getElementById('current-expected-word');
            const currentNormalizedEl = document.getElementById('current-normalized-word');
            const lastHeardEl = document.getElementById('last-heard-word');
            const lastHeardNormalizedEl = document.getElementById('last-heard-normalized');
            const statusEl = document.getElementById('recognition-status');
            const comparisonEl = document.getElementById('comparison-result');
            
            if (currentWordEl && state.memorizationStats.currentWordIndex < state.currentMemorizationWords.length) {
                const currentWord = state.currentMemorizationWords[state.memorizationStats.currentWordIndex];
                currentWordEl.textContent = currentWord;
                
                if (currentNormalizedEl) {
                    currentNormalizedEl.textContent = this.normalizeArabic(currentWord);
                }
            }
            
            if (lastSpoken && lastHeardEl) {
                lastHeardEl.textContent = lastSpoken;
                
                if (lastHeardNormalizedEl) {
                    lastHeardNormalizedEl.textContent = this.normalizeArabic(lastSpoken);
                }
            }
            
            if (statusEl) {
                statusEl.textContent = state.speechRecognition ? 'ŸÜÿ¥ÿ∑' : 'ŸÖÿ™ŸàŸÇŸÅ';
            }
            
            if (comparisonResult !== null && comparisonEl) {
                comparisonEl.textContent = comparisonResult ? '‚úÖ ŸÖÿ∑ÿßÿ®ŸÇ' : '‚ùå ÿ∫Ÿäÿ± ŸÖÿ∑ÿßÿ®ŸÇ';
                comparisonEl.className = comparisonResult ? 'font-bold text-green-600' : 'font-bold text-red-600';
            }
        },
        
        showError(error) {
            const errorsContainer = document.getElementById('memorization-errors');
            const errorsList = document.getElementById('memorization-errors-list');
            
            if (errorsContainer && errorsList) {
                errorsContainer.classList.remove('hidden');
                
                const errorElement = document.createElement('div');
                errorElement.className = 'error-item flex justify-between items-center p-4 bg-gradient-to-r from-red-50 to-pink-50 dark:from-red-900/20 dark:to-pink-900/20 rounded-xl text-sm border-l-4 border-red-500 mb-3 shadow-lg transition-all duration-300 hover:shadow-xl';
                
                // Enhanced error display with better formatting
                errorElement.innerHTML = `
                    <div class="flex-1">
                        <div class="flex items-center gap-2 mb-2">
                            <i class="fas fa-exclamation-triangle text-red-500"></i>
                            <span class="font-bold text-red-700 text-xs">ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ™ŸÑÿßŸàÿ©</span>
                            <span class="text-gray-500 text-xs">${new Date().toLocaleTimeString('ar-SA')}</span>
                        </div>
                        <div class="bg-white/70 rounded-lg p-3 mb-2">
                            <div class="text-red-600 mb-1 font-arabic text-base">
                                <span class="text-xs text-gray-600">ŸÇŸÑÿ™:</span> 
                                <span class="font-semibold">‚Äú${error.spoken}‚Äù</span>
                            </div>
                            <div class="text-green-600 font-arabic text-base">
                                <span class="text-xs text-gray-600">ÿßŸÑÿµÿ≠Ÿäÿ≠:</span> 
                                <span class="font-semibold">‚Äú${error.correct}‚Äù</span>
                            </div>
                        </div>
                        <div class="flex items-center gap-2 text-xs text-gray-500">
                            <i class="fas fa-info-circle"></i>
                            <span>ÿßÿπÿØ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© - ÿßŸÇÿ±ÿ£ ÿ®Ÿàÿ∂Ÿàÿ≠ ÿ£ŸÉÿ®ÿ±</span>
                        </div>
                    </div>
                    <div class="flex flex-col gap-2 ml-3">
                        <button onclick="this.closest('.error-item').remove()" class="text-gray-400 hover:text-red-600 transition-colors p-2 rounded-full hover:bg-red-50">
                            <i class="fas fa-times"></i>
                        </button>
                        <button onclick="App.repeatWord('${error.correct.replace(/'/g, "\\'")}')"
                                class="text-purple-500 hover:text-purple-700 transition-colors p-2 rounded-full hover:bg-purple-50" 
                                title="ÿ•ÿπÿßÿØÿ© ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ©">
                            <i class="fas fa-redo"></i>
                        </button>
                    </div>
                `;
                
                // Add with smooth animation
                errorElement.style.opacity = '0';
                errorElement.style.transform = 'translateX(100%)';
                errorsList.appendChild(errorElement);
                
                // Animate in
                requestAnimationFrame(() => {
                    errorElement.style.transition = 'all 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
                    errorElement.style.opacity = '1';
                    errorElement.style.transform = 'translateX(0)';
                });
                
                // Auto-remove after 10 seconds
                setTimeout(() => {
                    if (errorElement.parentNode) {
                        errorElement.style.transform = 'translateX(100%)';
                        errorElement.style.opacity = '0';
                        setTimeout(() => {
                            if (errorElement.parentNode) {
                                errorElement.remove();
                            }
                        }, 400);
                    }
                }, 10000);
            }
        },
        
        // Add function to repeat a word when user clicks retry
        repeatWord(word) {
            // Highlight the word again for retry
            const currentWordIndex = state.memorizationStats.currentWordIndex;
            const wordElements = document.querySelectorAll('.ayah-word');
            
            if (currentWordIndex < wordElements.length) {
                const currentElement = wordElements[currentWordIndex];
                currentElement.classList.remove('hidden', 'incorrect');
                currentElement.classList.add('waiting');
                
                // Show encouraging message
                // Speech feedback disabled per user request
                
                // Provide audio hint if available
                if (state.memorizationSettings.soundAlerts) {
                    this.playHintSound();
                }
            }
        },
        
        // Enhanced sound feedback
        playHintSound() {
            this.playSound('hint');
        },
        
        showMemorizationResults() {
            if (state.memorizationStats.totalWords === 0) return;
            
            const modal = document.createElement('div');
            modal.className = 'modal active';
            modal.innerHTML = `
                <div class="modal-content p-6">
                    <h3 class="text-xl font-bold mb-4">ŸÜÿ™ÿßÿ¶ÿ¨ ÿßŸÑÿ≠ŸÅÿ∏</h3>
                    <div class="grid grid-cols-2 gap-4 mb-4">
                        <div class="text-center">
                            <p class="text-2xl font-bold text-green-600">${state.memorizationStats.correctWords}</p>
                            <p class="text-sm">ŸÉŸÑŸÖÿßÿ™ ÿµÿ≠Ÿäÿ≠ÿ©</p>
                        </div>
                        <div class="text-center">
                            <p class="text-2xl font-bold text-red-600">${state.memorizationStats.incorrectWords}</p>
                            <p class="text-sm">ŸÉŸÑŸÖÿßÿ™ ÿÆÿßÿ∑ÿ¶ÿ©</p>
                        </div>
                        <div class="text-center col-span-2">
                            <p class="text-3xl font-bold" style="color: var(--primary)">${state.memorizationStats.accuracy}%</p>
                            <p class="text-sm">ÿØŸÇÿ© ÿßŸÑÿ≠ŸÅÿ∏</p>
                        </div>
                    </div>
                    <button onclick="this.closest('.modal').remove()" class="btn btn-primary w-full">
                        ÿ•ÿ∫ŸÑÿßŸÇ
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // ÿ•ÿ≤ÿßŸÑÿ© ÿ®ÿπÿØ 10 ÿ´ŸàÿßŸÜŸä
            setTimeout(() => {
                if (modal.parentElement) {
                    modal.remove();
                }
            }, 10000);
        },
        
        // Ÿàÿ∏ÿßÿ¶ŸÅ ŸÖÿ≥ÿßÿπÿØÿ© ŸÑŸÑÿ≠ŸÅÿ∏
        showVerse() {
            const wordElements = document.querySelectorAll('.ayah-word');
            const memWordElements = document.querySelectorAll('#memorization-page-content .ayah-word');
            const elements = memWordElements.length > 0 ? memWordElements : wordElements;
            
            elements.forEach((word, index) => {
                // ÿ•ÿ∏Ÿáÿßÿ± ÿ¨ŸÖŸäÿπ ÿßŸÑŸÉŸÑŸÖÿßÿ™ ŸÖÿ§ŸÇÿ™ÿßŸã
                word.classList.remove('hidden', 'waiting');
                word.classList.add('revealed');
                word.style.background = 'linear-gradient(135deg, rgba(59, 130, 246, 0.3), rgba(37, 99, 235, 0.4))';
                word.style.border = '2px solid rgba(59, 130, 246, 0.6)';
            });
            
            this.showToast('ÿ™ŸÖ ÿ•ÿ∏Ÿáÿßÿ± ÿßŸÑÿ¢Ÿäÿßÿ™ ŸÑŸÖÿØÿ© 3 ÿ´ŸàÿßŸÜ', 'info');
            
            setTimeout(() => {
                elements.forEach((word, index) => {
                    if (index >= state.memorizationStats.currentWordIndex) {
                        // ÿ•ÿÆŸÅÿßÿ° ÿßŸÑŸÉŸÑŸÖÿßÿ™ ÿ∫Ÿäÿ± ÿßŸÑŸÖŸÇŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ
                        word.classList.add('hidden');
                        word.classList.remove('revealed');
                        word.style.background = '';
                        word.style.border = '';
                        
                        // ÿ•ÿ∏Ÿáÿßÿ± ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ© ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±
                        if (index === state.memorizationStats.currentWordIndex) {
                            word.classList.add('waiting');
                        }
                    }
                });
            }, 3000);
        },
        
        giveHint() {
            if (state.memorizationStats.currentWordIndex >= state.currentMemorizationWords.length) {
                this.showToast('ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÉŸÑŸÖÿßÿ™ ŸÖÿ™ÿ®ŸÇŸäÿ©', 'warning');
                return;
            }
            
            const currentWord = state.currentMemorizationWords[state.memorizationStats.currentWordIndex];
            const hint = currentWord.length > 2 ? currentWord.substring(0, 2) + '...' : currentWord;
            
            // ÿπÿ±ÿ∂ ÿßŸÑÿ™ŸÑŸÖŸäÿ≠ ŸÅŸä ÿ™Ÿàÿ≥ÿ™
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black/50 flex items-center justify-center z-50 animate-fadeIn';
            modal.innerHTML = `
                <div class="bg-white rounded-xl p-6 m-4 max-w-sm text-center shadow-2xl transform animate-scaleIn">
                    <i class="fas fa-lightbulb text-yellow-500 text-4xl mb-4 animate-pulse"></i>
                    <h3 class="text-xl font-bold mb-3 text-gray-800">ÿ™ŸÑŸÖŸäÿ≠</h3>
                    <p class="text-gray-600 mb-3">ÿßŸÑŸÉŸÑŸÖÿ© ÿ™ÿ®ÿØÿ£ ÿ®ŸÄ:</p>
                    <p class="font-arabic text-3xl font-bold text-emerald-600 mb-6 bg-emerald-50 p-3 rounded-lg">${hint}</p>
                    <button class="btn btn-primary px-6 py-2" onclick="this.parentElement.parentElement.remove()">ÿ≠ÿ≥ŸÜÿßŸã</button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            setTimeout(() => {
                if (modal.parentElement) {
                    modal.remove();
                }
            }, 5000);
            
            this.showToast(`ÿ™ŸÑŸÖŸäÿ≠: ÿßŸÑŸÉŸÑŸÖÿ© ÿ™ÿ®ÿØÿ£ ÿ®ŸÄ "${hint}"`, 'info');
        },
        
        skipWord() {
            if (state.memorizationStats.currentWordIndex >= state.currentMemorizationWords.length) {
                this.showToast('ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÉŸÑŸÖÿßÿ™ ŸÑÿ™ÿÆÿ∑ŸäŸáÿß', 'warning');
                return;
            }
            
            const skippedWord = state.currentMemorizationWords[state.memorizationStats.currentWordIndex];
            
            // ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿ™ÿÆÿ∑Ÿä ŸÉÿÆÿ∑ÿ£
            const error = {
                wordIndex: state.memorizationStats.currentWordIndex,
                expected: skippedWord,
                spoken: 'ÿ™ŸÖ ÿßŸÑÿ™ÿÆÿ∑Ÿä',
                timestamp: new Date().toISOString()
            };
            
            state.memorizationStats.errors.push(error);
            state.memorizationStats.incorrectWords++;
            
            // ÿ•ÿ∏Ÿáÿßÿ± ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ™ÿÆÿ∑ÿßÿ©
            this.markWordCorrect(state.memorizationStats.currentWordIndex);
            
            // ÿßŸÑÿßŸÜÿ™ŸÇÿßŸÑ ÿ•ŸÑŸâ ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ©
            state.memorizationStats.currentWordIndex++;
            
            if (state.memorizationStats.currentWordIndex < state.currentMemorizationWords.length) {
                this.setCurrentWord(state.memorizationStats.currentWordIndex);
            } else {
                this.completeMemorization();
            }
            
            this.updateMemorizationProgressDisplay();
            this.showToast(`ÿ™ŸÖ ÿ™ÿÆÿ∑Ÿä ÿßŸÑŸÉŸÑŸÖÿ©: "${skippedWord}"`, 'warning');
        },
        
        // Mark a word as correctly spoken and reveal it
        markWordCorrect(wordIndex) {
            const wordElements = document.querySelectorAll('.ayah-word');
            const memWordElements = document.querySelectorAll('#memorization-page-content .ayah-word');
            const elements = memWordElements.length > 0 ? memWordElements : wordElements;
            
            if (wordIndex < elements.length) {
                const wordElement = elements[wordIndex];
                wordElement.classList.remove('hidden', 'waiting', 'incorrect');
                
                // Keep original Quranic text display (no conversion to plain text)
                // The original text with diacritics remains as is
                
                // Immediately reveal without animation out of respect for Quran
                wordElement.classList.add('revealed');
            }
        },
        
        // Set current word to waiting state
        setCurrentWord(wordIndex) {
            const wordElements = document.querySelectorAll('.ayah-word');
            const memWordElements = document.querySelectorAll('#memorization-page-content .ayah-word');
            const elements = memWordElements.length > 0 ? memWordElements : wordElements;
            
            // Remove waiting state from all words
            elements.forEach(el => el.classList.remove('waiting'));
            
            // Set current word to waiting if it exists and is still hidden
            if (wordIndex < elements.length) {
                const currentElement = elements[wordIndex];
                if (currentElement.classList.contains('hidden')) {
                    currentElement.classList.add('waiting');
                }
            }
        },

        resetMemorization() {
            // ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™
            this.resetMemorizationStats();
            
            // ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿπÿ±ÿ∂ ÿßŸÑŸÉŸÑŸÖÿßÿ™
            const wordElements = document.querySelectorAll('.ayah-word');
            const memWordElements = document.querySelectorAll('#memorization-page-content .ayah-word');
            const elements = memWordElements.length > 0 ? memWordElements : wordElements;
            
            elements.forEach((word, index) => {
                word.classList.remove('revealed', 'waiting', 'correct', 'incorrect');
                word.classList.add('hidden');
                word.style.background = '';
                word.style.border = '';
                word.style.animation = '';
                
                // ÿ•ÿ∏Ÿáÿßÿ± ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑÿ£ŸàŸÑŸâ
                if (index === 0) {
                    word.classList.add('waiting');
                }
            });
            
            // ŸÖÿ≥ÿ≠ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ£ÿÆÿ∑ÿßÿ°
            const errorsContainer = document.getElementById('memorization-errors-list');
            if (errorsContainer) {
                errorsContainer.innerHTML = '';
            }
            
            this.updateMemorizationProgressDisplay();
            this.showToast('ÿ™ŸÖ ÿ•ÿπÿßÿØÿ© ÿ®ÿØÿ° ÿßŸÑÿ≠ŸÅÿ∏', 'success');
        },
        
        playMemorizationAudio() {
            // ÿ™ÿ¥ÿ∫ŸäŸÑ ÿµŸàÿ™ ÿßŸÑÿ¢Ÿäÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©
            if (state.pageData && state.pageData.length > 0) {
                const firstVerse = state.pageData[0];
                if (firstVerse && firstVerse.verse_key) {
                    this.playAyahAudio(firstVerse.verse_key);
                }
            } else {
                this.showToast('ŸÑÿß ŸäŸÖŸÉŸÜ ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿµŸàÿ™ ÿ≠ÿßŸÑŸäÿßŸã', 'error');
            }
        },

        convertToArabicNumbers(number) {
            const arabicNumbers = ['Ÿ†', 'Ÿ¢', 'Ÿ¢', 'Ÿ£', 'Ÿ§', 'Ÿ•', 'Ÿ¶', 'Ÿß', 'Ÿ®', 'Ÿ©'];
            return number.toString().split('').map(digit => arabicNumbers[digit]).join('');
        },
        
        // Enhanced memorization helper functions
        showVerse() {
            const wordElements = document.querySelectorAll('.ayah-word');
            const memWordElements = document.querySelectorAll('#memorization-page-content .ayah-word');
            const elements = memWordElements.length > 0 ? memWordElements : wordElements;
            
            elements.forEach((word, index) => {
                // ÿ•ÿ∏Ÿáÿßÿ± ÿ¨ŸÖŸäÿπ ÿßŸÑŸÉŸÑŸÖÿßÿ™ ŸÖÿ§ŸÇÿ™ÿßŸã
                word.classList.remove('hidden', 'waiting');
                word.classList.add('revealed');
                word.style.background = 'linear-gradient(135deg, rgba(59, 130, 246, 0.3), rgba(37, 99, 235, 0.4))';
                word.style.border = '2px solid rgba(59, 130, 246, 0.6)';
            });
            
            this.showToast('ÿ™ŸÖ ÿ•ÿ∏Ÿáÿßÿ± ÿßŸÑÿ¢Ÿäÿßÿ™ ŸÑŸÖÿØÿ© 3 ÿ´ŸàÿßŸÜ', 'info');
            
            setTimeout(() => {
                elements.forEach((word, index) => {
                    if (index >= state.memorizationStats.currentWordIndex) {
                        // ÿ•ÿÆŸÅÿßÿ° ÿßŸÑŸÉŸÑŸÖÿßÿ™ ÿ∫Ÿäÿ± ÿßŸÑŸÖŸÇŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ
                        word.classList.add('hidden');
                        word.classList.remove('revealed');
                        word.style.background = '';
                        word.style.border = '';
                        
                        // ÿ•ÿ∏Ÿáÿßÿ± ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ© ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±
                        if (index === state.memorizationStats.currentWordIndex) {
                            word.classList.add('waiting');
                        }
                    }
                });
            }, 3000);
        },
        
        giveHint() {
            if (state.memorizationStats.currentWordIndex >= state.currentMemorizationWords.length) {
                this.showToast('ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÉŸÑŸÖÿßÿ™ ŸÖÿ™ÿ®ŸÇŸäÿ©', 'warning');
                return;
            }
            
            const currentWord = state.currentMemorizationWords[state.memorizationStats.currentWordIndex];
            const hint = currentWord.length > 2 ? currentWord.substring(0, 2) + '...' : currentWord;
            
            // ÿπÿ±ÿ∂ ÿßŸÑÿ™ŸÑŸÖŸäÿ≠ ŸÅŸä ÿ™Ÿàÿ≥ÿ™
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black/50 flex items-center justify-center z-50 animate-fadeIn';
            modal.innerHTML = `
                <div class="bg-white rounded-xl p-6 m-4 max-w-sm text-center shadow-2xl transform animate-scaleIn">
                    <i class="fas fa-lightbulb text-yellow-500 text-4xl mb-4 animate-pulse"></i>
                    <h3 class="text-xl font-bold mb-3 text-gray-800">ÿ™ŸÑŸÖŸäÿ≠</h3>
                    <p class="text-gray-600 mb-3">ÿßŸÑŸÉŸÑŸÖÿ© ÿ™ÿ®ÿØÿ£ ÿ®ŸÄ:</p>
                    <p class="font-arabic text-3xl font-bold text-emerald-600 mb-6 bg-emerald-50 p-3 rounded-lg">${hint}</p>
                    <button class="btn btn-primary px-6 py-2" onclick="this.parentElement.parentElement.remove()">ÿ≠ÿ≥ŸÜÿßŸã</button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            setTimeout(() => {
                if (modal.parentElement) {
                    modal.remove();
                }
            }, 5000);
            
            this.showToast(`ÿ™ŸÑŸÖŸäÿ≠: ÿßŸÑŸÉŸÑŸÖÿ© ÿ™ÿ®ÿØÿ£ ÿ®ŸÄ "${hint}"`, 'info');
        },
        
        skipWord() {
            if (state.memorizationStats.currentWordIndex >= state.currentMemorizationWords.length) {
                this.showToast('ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÉŸÑŸÖÿßÿ™ ŸÑÿ™ÿÆÿ∑ŸäŸáÿß', 'warning');
                return;
            }
            
            const skippedWord = state.currentMemorizationWords[state.memorizationStats.currentWordIndex];
            
            // ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿ™ÿÆÿ∑Ÿä ŸÉÿÆÿ∑ÿ£
            const error = {
                wordIndex: state.memorizationStats.currentWordIndex,
                expected: skippedWord,
                spoken: 'ÿ™ŸÖ ÿßŸÑÿ™ÿÆÿ∑Ÿä',
                timestamp: new Date().toISOString()
            };
            
            state.memorizationStats.errors.push(error);
            state.memorizationStats.incorrectWords++;
            
            // ÿ•ÿ∏Ÿáÿßÿ± ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ™ÿÆÿ∑ÿßÿ©
            this.markWordCorrect(state.memorizationStats.currentWordIndex);
            
            // ÿßŸÑÿßŸÜÿ™ŸÇÿßŸÑ ÿ•ŸÑŸâ ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ©
            state.memorizationStats.currentWordIndex++;
            
            if (state.memorizationStats.currentWordIndex < state.currentMemorizationWords.length) {
                this.setCurrentWord(state.memorizationStats.currentWordIndex);
            } else {
                this.completeMemorization();
            }
            
            this.updateMemorizationProgressDisplay();
            this.showToast(`ÿ™ŸÖ ÿ™ÿÆÿ∑Ÿä ÿßŸÑŸÉŸÑŸÖÿ©: "${skippedWord}"`, 'warning');
        },
        
        resetMemorization() {
            // ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™
            this.resetMemorizationStats();
            
            // ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿπÿ±ÿ∂ ÿßŸÑŸÉŸÑŸÖÿßÿ™
            const wordElements = document.querySelectorAll('.ayah-word');
            const memWordElements = document.querySelectorAll('#memorization-page-content .ayah-word');
            const elements = memWordElements.length > 0 ? memWordElements : wordElements;
            
            elements.forEach((word, index) => {
                word.classList.remove('revealed', 'waiting', 'correct', 'incorrect');
                word.classList.add('hidden');
                word.style.background = '';
                word.style.border = '';
                word.style.animation = '';
                
                // ÿ•ÿ∏Ÿáÿßÿ± ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑÿ£ŸàŸÑŸâ
                if (index === 0) {
                    word.classList.add('waiting');
                }
            });
            
            // ŸÖÿ≥ÿ≠ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ£ÿÆÿ∑ÿßÿ°
            const errorsContainer = document.getElementById('memorization-errors-list');
            if (errorsContainer) {
                errorsContainer.innerHTML = '';
            }
            
            this.updateMemorizationProgressDisplay();
            this.showToast('ÿ™ŸÖ ÿ•ÿπÿßÿØÿ© ÿ®ÿØÿ° ÿßŸÑÿ≠ŸÅÿ∏', 'success');
        },
        
        playMemorizationAudio() {
            // ÿ™ÿ¥ÿ∫ŸäŸÑ ÿµŸàÿ™ ÿßŸÑÿ¢Ÿäÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©
            if (state.pageData && state.pageData.length > 0) {
                const firstVerse = state.pageData[0];
                if (firstVerse && firstVerse.verse_key) {
                    this.playAyahAudio(firstVerse.verse_key);
                }
            } else {
                this.showToast('ŸÑÿß ŸäŸÖŸÉŸÜ ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿµŸàÿ™ ÿ≠ÿßŸÑŸäÿßŸã', 'error');
            }
        },

        playSuccessSound() {
            try {
                // ÿµŸàÿ™ ŸÜÿ¨ÿßÿ≠ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Web Audio API
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
            } catch (error) {
                console.log('Audio context not available');
            }
        },
        
        playErrorSound() {
            try {
                // ÿµŸàÿ™ ÿÆÿ∑ÿ£
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                oscillator.type = 'square';
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.2);
            } catch (error) {
                console.log('Audio context not available');
            }
        },
        
        navigatePage(direction) {
            const newPage = state.currentPage + direction;
            if (newPage >= 1 && newPage <= CONFIG.TOTAL_PAGES) {
                this.loadPage(newPage);
            }
        },
        
        setupAudio() {
            state.audioQueue = [];
            state.currentAudioIndex = 0;
            
            if (state.pageData) {
                state.pageData.forEach(verse => {
                    if (verse.audio?.url) {
                        state.audioQueue.push({
                            url: CONFIG.AUDIO_BASE + verse.audio.url,
                            verseKey: verse.verse_key
                        });
                    }
                });
            }
            
            const audioEl = document.getElementById('page-audio');
            if (state.audioQueue.length > 0) {
                audioEl.src = state.audioQueue[0].url;
            }
        },
        
        playNextAyah() {
            if (state.currentAudioIndex < state.audioQueue.length - 1) {
                state.currentAudioIndex++;
                const audioEl = document.getElementById('page-audio');
                audioEl.src = state.audioQueue[state.currentAudioIndex].url;
                audioEl.play();
            }
        },
        
        // Show interim speech feedback (disabled per user request)
        showInterimFeedback(interimText) {
            // Speech feedback disabled - user requested no listening indicator
            return;
        },
        
        // Add empty updateSpeechFeedback function to prevent errors
        updateSpeechFeedback(message, confidence) {
            // Speech feedback disabled per user request
            return;
        },
        
        // Enhanced error tracking and display
        updateErrorsList() {
            const errorsContainer = document.getElementById('memorization-errors-list');
            if (!errorsContainer) return;
            
            errorsContainer.innerHTML = '';
            
            state.memorizationStats.errors.slice(-5).forEach((error, index) => {
                const errorEl = document.createElement('div');
                errorEl.className = 'error-item p-3 mb-2 bg-red-50 border border-red-200 rounded-lg text-sm shadow-sm animate-slideIn';
                errorEl.innerHTML = `
                    <div class="flex items-center justify-between mb-1">
                        <div class="text-red-800 font-semibold text-xs">ÿÆÿ∑ÿ£ ${state.memorizationStats.errors.length - index}</div>
                        <div class="text-red-500 text-xs">${new Date(error.timestamp || Date.now()).toLocaleTimeString('ar')}</div>
                    </div>
                    <div class="text-red-600 mb-1">ŸÇŸÑÿ™: <span class="font-arabic font-medium">"${error.spoken}"</span></div>
                    <div class="text-green-600">ÿßŸÑÿµÿ≠Ÿäÿ≠: <span class="font-arabic font-medium">"${error.expected || error.correct}"</span></div>
                `;
                errorsContainer.appendChild(errorEl);
            });
        },
        
        // Enhanced sound feedback
        playSound(type) {
            if (!state.memorizationSettings.soundAlerts) return;
            
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                if (type === 'success') {
                    // Success tone - beautiful ascending
                    oscillator.frequency.setValueAtTime(523, audioContext.currentTime); // C5
                    oscillator.frequency.setValueAtTime(659, audioContext.currentTime + 0.1); // E5
                    oscillator.frequency.setValueAtTime(784, audioContext.currentTime + 0.2); // G5
                    
                    gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.4);
                } else if (type === 'error') {
                    // Error tone - gentle descending
                    oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // A4
                    oscillator.frequency.setValueAtTime(349, audioContext.currentTime + 0.15); // F4
                    oscillator.frequency.setValueAtTime(294, audioContext.currentTime + 0.3); // D4
                    
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                }
            } catch (error) {
                console.warn('Could not play sound:', error);
            }
        },
        
        playMemorizationAudio() {
            // ÿ™ÿ¥ÿ∫ŸäŸÑ ÿµŸàÿ™ ÿßŸÑÿ¢Ÿäÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©
            if (state.pageData && state.pageData.length > 0) {
                const firstVerse = state.pageData[0];
                if (firstVerse && firstVerse.verse_key) {
                    this.playAyahAudio(firstVerse.verse_key);
                }
            } else {
                this.showToast('ŸÑÿß ŸäŸÖŸÉŸÜ ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿµŸàÿ™ ÿ≠ÿßŸÑŸäÿßŸã', 'error');
            }
        },
        
        playNextAyah() {
            if (state.currentAudioIndex < state.audioQueue.length - 1) {
                state.currentAudioIndex++;
                const audioEl = document.getElementById('page-audio');
                audioEl.src = state.audioQueue[state.currentAudioIndex].url;
                audioEl.play();
                
                this.highlightPlayingAyah();
            }
        },
        
        playPreviousAyah() {
            if (state.currentAudioIndex > 0) {
                state.currentAudioIndex--;
                const audioEl = document.getElementById('page-audio');
                audioEl.src = state.audioQueue[state.currentAudioIndex].url;
                audioEl.play();
                
                this.highlightPlayingAyah();
            }
        },
        
        highlightPlayingAyah() {
            document.querySelectorAll('.ayah').forEach(ayah => {
                ayah.classList.remove('playing');
            });
            
            if (state.audioQueue[state.currentAudioIndex]) {
                const currentVerseKey = state.audioQueue[state.currentAudioIndex].verseKey;
                const ayahEl = document.querySelector(`[data-verse-key="${currentVerseKey}"]`);
                if (ayahEl) {
                    ayahEl.classList.add('playing');
                    ayahEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }
        },
        
        initSurahList() {
            const list = document.getElementById('surah-list');
            list.innerHTML = '';
            
            const surahPages = [1, 2, 50, 77, 106, 128, 151, 177, 187, 208, 221, 235, 249, 255, 262, 267, 282, 293, 305, 312, 322, 332, 342, 350, 359, 367, 377, 385, 396, 404, 411, 415, 418, 428, 434, 440, 446, 453, 458, 467, 477, 483, 489, 496, 499, 502, 507, 511, 515, 518, 520, 523, 526, 528, 531, 534, 537, 542, 545, 549, 551, 553, 554, 556, 558, 560, 562, 564, 566, 568, 570, 572, 574, 575, 577, 578, 580, 582, 583, 585, 586, 587, 587, 589, 590, 591, 591, 592, 593, 594, 595, 595, 596, 596, 597, 597, 598, 598, 599, 599, 600, 600, 601, 601, 601, 602, 602, 602, 603, 603, 603, 604, 604, 604];
            
            state.surahs.forEach((surah, index) => {
                const item = document.createElement('div');
                item.className = 'card mb-3 cursor-pointer';
                item.innerHTML = `
                    <div class="flex items-center justify-between">
                        <div class="flex items-center gap-3">
                            <div class="w-10 h-10 rounded-full bg-gradient-to-br from-emerald-500 to-emerald-600 text-white flex items-center justify-center font-bold">
                                ${surah.id}
                            </div>
                            <div>
                                <h4 class="font-bold">${surah.name_arabic}</h4>
                                <p class="text-xs" style="color: var(--text-secondary)">
                                    ${surah.revelation_place === 'makkah' ? 'ŸÖŸÉŸäÿ©' : 'ŸÖÿØŸÜŸäÿ©'} ‚Ä¢ ${surah.verses_count} ÿ¢Ÿäÿ©
                                </p>
                            </div>
                        </div>
                        <i class="fas fa-chevron-left" style="color: var(--text-tertiary)"></i>
                    </div>
                `;
                
                item.onclick = () => {
                    const pageToLoad = surahPages[index] || 1;
                    this.loadPage(pageToLoad);
                    this.closePanel('index-panel');
                };
                
                list.appendChild(item);
            });
        },
        
        async searchQuran(query) {
            try {
                const results = await API.searchQuran(query);
                const searchResultsEl = document.getElementById('search-results');
                searchResultsEl.innerHTML = '';
                
                if (!results || !results.results || results.results.length === 0) {
                    searchResultsEl.innerHTML = '<p class="text-center opacity-50 mt-8">ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÜÿ™ÿßÿ¶ÿ¨</p>';
                    return;
                }
                
                for (const result of results.results) {
                    const [surahId, ayahNumber] = result.verse_key.split(':');
                    const surah = state.surahs.find(s => s.id == surahId);
                    
                    const resultEl = document.createElement('div');
                    resultEl.className = 'card mb-3 cursor-pointer';
                    resultEl.innerHTML = `
                        <div>
                            <p class="font-arabic text-lg mb-2">${result.text}</p>
                            <p class="text-sm" style="color: var(--text-secondary)">
                                ÿ≥Ÿàÿ±ÿ© ${surah?.name_arabic || ''} - ÿ¢Ÿäÿ© ${ayahNumber}
                            </p>
                        </div>
                    `;
                    
                    resultEl.onclick = async () => {
                        try {
                            const verseData = await API.getVerseByKey(result.verse_key);
                            await this.loadPage(verseData.page_number);
                            
                            setTimeout(() => {
                                const ayahEl = document.querySelector(`[data-verse-key="${result.verse_key}"]`);
                                if (ayahEl) {
                                    ayahEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                    ayahEl.classList.add('playing');
                                    setTimeout(() => ayahEl.classList.remove('playing'), 2000);
                                }
                            }, 500);
                            
                            this.closePanel('search-panel');
                        } catch (error) {
                            console.error('Error loading search result:', error);
                        }
                    };
                    
                    searchResultsEl.appendChild(resultEl);
                }
            } catch (error) {
                console.error('Search error:', error);
                document.getElementById('search-results').innerHTML = '<p class="text-center text-red-500 mt-8">ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ®ÿ≠ÿ´</p>';
            }
        },
        
        // Bookmarks Functions - ŸÖÿ≠ÿ≥ŸÜÿ©
        toggleBookmark(verseKey, verseText) {
            const existingIndex = state.bookmarks.findIndex(b => b.verseKey === verseKey);
            
            if (existingIndex > -1) {
                state.bookmarks.splice(existingIndex, 1);
                this.showToast('ÿ™ŸÖ ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿπŸÑÿßŸÖÿ©', 'info');
            } else {
                const [surahId, ayahNum] = verseKey.split(':');
                const surah = state.surahs.find(s => s.id == surahId);
                
                state.bookmarks.push({
                    verseKey: verseKey,
                    verseText: verseText,
                    surahName: surah?.name_arabic || '',
                    surahId: surahId,
                    ayahNumber: ayahNum,
                    timestamp: Date.now(),
                    pageNumber: state.currentPage
                });
                this.showToast('ÿ™ŸÖÿ™ ÿßŸÑÿ•ÿ∂ÿßŸÅÿ© ŸÑŸÑŸÖŸÅÿ∂ŸÑÿ©', 'success');
            }
            
            localStorage.setItem('bookmarks', JSON.stringify(state.bookmarks));
            this.renderPage(); // Re-render to show bookmark icon
            this.renderBookmarks(); // Update bookmarks list if open
        },
        
        renderBookmarks() {
            const list = document.getElementById('bookmarks-list');
            
            if (state.bookmarks.length === 0) {
                list.innerHTML = '<p class="text-center opacity-50">ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿπŸÜÿßÿµÿ± ŸÖÿ≠ŸÅŸàÿ∏ÿ©</p>';
                return;
            }
            
            list.innerHTML = '';
            
            // Sort bookmarks by timestamp (newest first)
            const sortedBookmarks = [...state.bookmarks].sort((a, b) => b.timestamp - a.timestamp);
            
            sortedBookmarks.forEach(bookmark => {
                const item = document.createElement('div');
                item.className = 'card mb-3';
                item.innerHTML = `
                    <div class="mb-2">
                        <p class="font-arabic text-lg mb-2">${bookmark.verseText}</p>
                        <div class="flex items-center justify-between">
                            <p class="text-sm" style="color: var(--text-secondary)">
                                ${bookmark.surahName} - ÿ¢Ÿäÿ© ${bookmark.ayahNumber}
                            </p>
                            <div class="flex gap-2">
                                <button class="btn btn-secondary text-xs" onclick="App.goToBookmark('${bookmark.verseKey}', ${bookmark.pageNumber})">
                                    <i class="fas fa-arrow-left"></i> ÿßŸÜÿ™ŸÇŸÑ
                                </button>
                                <button class="text-red-500 hover:text-red-600" onclick="App.removeBookmark('${bookmark.verseKey}')">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                
                list.appendChild(item);
            });
        },
        
        async goToBookmark(verseKey, pageNumber) {
            await this.loadPage(pageNumber);
            
            setTimeout(() => {
                const ayahEl = document.querySelector(`[data-verse-key="${verseKey}"]`);
                if (ayahEl) {
                    ayahEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    ayahEl.classList.add('playing');
                    setTimeout(() => ayahEl.classList.remove('playing'), 2000);
                }
            }, 500);
            
            this.closePanel('bookmarks-panel');
        },
        
        removeBookmark(verseKey) {
            const index = state.bookmarks.findIndex(b => b.verseKey === verseKey);
            if (index > -1) {
                state.bookmarks.splice(index, 1);
                localStorage.setItem('bookmarks', JSON.stringify(state.bookmarks));
                this.renderBookmarks();
                this.renderPage();
            }
        },
        
        // Khatmah Functions
        createKhatmah() {
            const name = document.getElementById('khatmah-name').value.trim();
            const goal = document.getElementById('khatmah-goal').value.trim();
            const dailyPages = parseInt(document.getElementById('khatmah-daily-pages').value) || 20;
            
            if (!name) {
                this.showToast('ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿØÿÆÿßŸÑ ÿßÿ≥ŸÖ ÿßŸÑÿÆÿ™ŸÖÿ©', 'error');
                return;
            }
            
            const khatmah = {
                id: Date.now(),
                name: name,
                goal: goal,
                dailyPages: dailyPages,
                startDate: new Date().toISOString(),
                pagesRead: [],
                totalPages: CONFIG.TOTAL_PAGES,
                completed: false
            };
            
            state.khatmahs.push(khatmah);
            localStorage.setItem('khatmahs', JSON.stringify(state.khatmahs));
            
            // Clear form
            document.getElementById('khatmah-name').value = '';
            document.getElementById('khatmah-goal').value = '';
            document.getElementById('khatmah-daily-pages').value = '20';
            
            this.updateKhatmahsDisplay();
            this.showToast('ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿÆÿ™ŸÖÿ© ÿ®ŸÜÿ¨ÿßÿ≠', 'success');
        },
        
        updateKhatmahsDisplay() {
            const currentContainer = document.getElementById('current-khatmahs');
            const completedContainer = document.getElementById('completed-khatmahs');
            
            const current = state.khatmahs.filter(k => !k.completed);
            const completed = state.khatmahs.filter(k => k.completed);
            
            // Current Khatmahs
            if (current.length === 0) {
                currentContainer.innerHTML = '<p class="text-center opacity-50">ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿÆÿ™ŸÖÿßÿ™ ÿ≠ÿßŸÑŸäÿ©</p>';
            } else {
                currentContainer.innerHTML = '';
                current.forEach(khatmah => {
                    const progress = (khatmah.pagesRead.length / khatmah.totalPages) * 100;
                    const daysElapsed = Math.ceil((Date.now() - new Date(khatmah.startDate)) / (1000 * 60 * 60 * 24));
                    const estimatedDays = Math.ceil((khatmah.totalPages - khatmah.pagesRead.length) / khatmah.dailyPages);
                    
                    const card = document.createElement('div');
                    card.className = 'khatmah-card';
                    card.innerHTML = `
                        <div class="flex justify-between items-start mb-3">
                            <div>
                                <h4 class="font-bold">${khatmah.name}</h4>
                                <p class="text-sm" style="color: var(--text-secondary)">${khatmah.goal || 'ŸÑÿß ŸäŸàÿ¨ÿØ ŸáÿØŸÅ ŸÖÿ≠ÿØÿØ'}</p>
                            </div>
                            <span class="khatmah-status active">ŸÜÿ¥ÿ∑ÿ©</span>
                        </div>
                        <div class="mb-3">
                            <div class="flex justify-between text-sm mb-1">
                                <span>ÿßŸÑÿ™ŸÇÿØŸÖ</span>
                                <span>${Math.round(progress)}%</span>
                            </div>
                            <div class="w-full h-2 bg-gray-200 rounded-full">
                                <div class="h-full bg-gradient-to-r from-emerald-500 to-emerald-600 rounded-full transition-all" style="width: ${progress}%"></div>
                            </div>
                        </div>
                        <div class="grid grid-cols-3 gap-2 text-center text-sm mb-3">
                            <div>
                                <p class="font-bold">${khatmah.pagesRead.length}</p>
                                <p style="color: var(--text-secondary)">ÿµŸÅÿ≠ÿ© ŸÖŸÇÿ±Ÿàÿ°ÿ©</p>
                            </div>
                            <div>
                                <p class="font-bold">${daysElapsed}</p>
                                <p style="color: var(--text-secondary)">ŸäŸàŸÖ ŸÖÿ∂Ÿâ</p>
                            </div>
                            <div>
                                <p class="font-bold">${estimatedDays}</p>
                                <p style="color: var(--text-secondary)">ŸäŸàŸÖ ŸÖÿ™ÿ®ŸÇŸä</p>
                            </div>
                        </div>
                        <div class="flex gap-2">
                            <button onclick="App.showKhatmahAnalytics(${khatmah.id})" class="btn btn-secondary flex-1 text-sm">
                                <i class="fas fa-chart-bar"></i> ÿ™ÿ≠ŸÑŸäŸÑ
                            </button>
                            <button onclick="App.deleteKhatmah(${khatmah.id})" class="text-red-500 hover:text-red-600 px-3">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    `;
                    
                    currentContainer.appendChild(card);
                });
            }
            
            // Completed Khatmahs
            if (completed.length === 0) {
                completedContainer.innerHTML = '<p class="text-center opacity-50">ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿÆÿ™ŸÖÿßÿ™ ŸÖŸÉÿ™ŸÖŸÑÿ©</p>';
            } else {
                completedContainer.innerHTML = '';
                completed.forEach(khatmah => {
                    const daysElapsed = Math.ceil((new Date(khatmah.completedDate) - new Date(khatmah.startDate)) / (1000 * 60 * 60 * 24));
                    
                    const card = document.createElement('div');
                    card.className = 'khatmah-card';
                    card.innerHTML = `
                        <div class="flex justify-between items-start mb-3">
                            <div>
                                <h4 class="font-bold">${khatmah.name}</h4>
                                <p class="text-sm" style="color: var(--text-secondary)">ÿßŸÉÿ™ŸÖŸÑÿ™ ŸÅŸä ${daysElapsed} ŸäŸàŸÖ</p>
                            </div>
                            <span class="khatmah-status completed">ŸÖŸÉÿ™ŸÖŸÑÿ©</span>
                        </div>
                        <div class="flex gap-2">
                            <button onclick="App.showKhatmahAnalytics(${khatmah.id})" class="btn btn-secondary flex-1 text-sm">
                                <i class="fas fa-chart-bar"></i> ÿ™ÿ≠ŸÑŸäŸÑ
                            </button>
                            <button onclick="App.deleteKhatmah(${khatmah.id})" class="text-red-500 hover:text-red-600 px-3">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    `;
                    
                    completedContainer.appendChild(card);
                });
            }
        },
        
        trackPageInKhatmah(pageNumber) {
            state.khatmahs.forEach(khatmah => {
                if (!khatmah.completed && !khatmah.pagesRead.includes(pageNumber)) {
                    khatmah.pagesRead.push(pageNumber);
                    
                    // Check if completed
                    if (khatmah.pagesRead.length >= khatmah.totalPages) {
                        khatmah.completed = true;
                        khatmah.completedDate = new Date().toISOString();
                        this.showToast(`ŸÖÿ®ÿßÿ±ŸÉ! ŸÑŸÇÿØ ÿ£ŸÉŸÖŸÑÿ™ ${khatmah.name}`, 'success');
                    }
                }
            });
            
            localStorage.setItem('khatmahs', JSON.stringify(state.khatmahs));
        },
        
        showKhatmahAnalytics(khatmahId) {
            const khatmah = state.khatmahs.find(k => k.id === khatmahId);
            if (!khatmah) return;
            
            const modal = document.getElementById('khatmah-analytics-modal');
            const content = document.getElementById('analytics-content');
            
            const progress = (khatmah.pagesRead.length / khatmah.totalPages) * 100;
            const daysElapsed = Math.ceil((Date.now() - new Date(khatmah.startDate)) / (1000 * 60 * 60 * 24));
            const avgPagesPerDay = khatmah.pagesRead.length / Math.max(daysElapsed, 1);
            
            content.innerHTML = `
                <div class="mb-4">
                    <h4 class="font-bold text-lg mb-2">${khatmah.name}</h4>
                    <p class="text-sm" style="color: var(--text-secondary)">${khatmah.goal || 'ŸÑÿß ŸäŸàÿ¨ÿØ ŸáÿØŸÅ ŸÖÿ≠ÿØÿØ'}</p>
                </div>
                
                <div class="grid grid-cols-2 gap-4 mb-4">
                    <div class="card text-center">
                        <p class="text-2xl font-bold" style="color: var(--primary)">${Math.round(progress)}%</p>
                        <p class="text-sm">ŸÜÿ≥ÿ®ÿ© ÿßŸÑÿ•ŸÜÿ¨ÿßÿ≤</p>
                    </div>
                    <div class="card text-center">
                        <p class="text-2xl font-bold" style="color: var(--primary)">${khatmah.pagesRead.length}</p>
                        <p class="text-sm">ÿµŸÅÿ≠ÿ© ŸÖŸÇÿ±Ÿàÿ°ÿ©</p>
                    </div>
                    <div class="card text-center">
                        <p class="text-2xl font-bold" style="color: var(--primary)">${Math.round(avgPagesPerDay)}</p>
                        <p class="text-sm">ŸÖÿ™Ÿàÿ≥ÿ∑ ŸäŸàŸÖŸä</p>
                    </div>
                    <div class="card text-center">
                        <p class="text-2xl font-bold" style="color: var(--primary)">${daysElapsed}</p>
                        <p class="text-sm">ŸäŸàŸÖ ŸÖÿ∂Ÿâ</p>
                    </div>
                </div>
                
                <div class="chart-container">
                    <canvas id="khatmah-chart"></canvas>
                </div>
            `;
            
            modal.classList.add('active');
            
            // Create chart
            setTimeout(() => {
                const ctx = document.getElementById('khatmah-chart').getContext('2d');
                new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: Array.from({length: Math.min(daysElapsed, 30)}, (_, i) => `ŸäŸàŸÖ ${i + 1}`),
                        datasets: [{
                            label: 'ÿßŸÑÿµŸÅÿ≠ÿßÿ™ ÿßŸÑŸÖŸÇÿ±Ÿàÿ°ÿ©',
                            data: Array.from({length: Math.min(daysElapsed, 30)}, (_, i) => 
                                khatmah.pagesRead.filter(p => p <= (i + 1) * khatmah.dailyPages).length
                            ),
                            borderColor: 'rgb(16, 185, 129)',
                            backgroundColor: 'rgba(16, 185, 129, 0.1)',
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: false
                            }
                        }
                    }
                });
            }, 100);
        },
        
        deleteKhatmah(khatmahId) {
            if (confirm('ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ≠ÿ∞ŸÅ Ÿáÿ∞Ÿá ÿßŸÑÿÆÿ™ŸÖÿ©ÿü')) {
                state.khatmahs = state.khatmahs.filter(k => k.id !== khatmahId);
                localStorage.setItem('khatmahs', JSON.stringify(state.khatmahs));
                this.updateKhatmahsDisplay();
                this.showToast('ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑÿÆÿ™ŸÖÿ©', 'info');
            }
        },
        
        // Share Functions
        shareAsText() {
            if (!state.selectedAyah) return;
            
            const [surahId, ayahNum] = state.selectedAyah.key.split(':');
            const surah = state.surahs.find(s => s.id == surahId);
            
            const shareText = `${state.selectedAyah.text}\n\nÿ≥Ÿàÿ±ÿ© ${surah?.name_arabic || ''} - ÿ¢Ÿäÿ© ${ayahNum}\n\nŸÖÿµÿ≠ŸÅ ÿßŸÑŸáÿßÿØŸä`;
            
            if (navigator.share) {
                navigator.share({
                    title: 'ÿ¢Ÿäÿ© ŸÖŸÜ ÿßŸÑŸÇÿ±ÿ¢ŸÜ ÿßŸÑŸÉÿ±ŸäŸÖ',
                    text: shareText
                });
            } else {
                navigator.clipboard.writeText(shareText);
                this.showToast('ÿ™ŸÖ ŸÜÿ≥ÿÆ ÿßŸÑŸÜÿµ', 'success');
            }
        },
        
        prepareShareImage() {
            if (!state.selectedAyah) return;
            
            const [surahId, ayahNum] = state.selectedAyah.key.split(':');
            const surah = state.surahs.find(s => s.id == surahId);
            
            document.getElementById('share-text').textContent = state.selectedAyah.text;
            document.getElementById('share-info').textContent = `ÿ≥Ÿàÿ±ÿ© ${surah?.name_arabic || ''} - ÿ¢Ÿäÿ© ${ayahNum}`;
            
            this.updateSharePreview();
            this.openPanel('share-image-panel');
        },
        
        updateSharePreview() {
            const preview = document.getElementById('share-image-preview');
            preview.style.backgroundColor = state.shareSettings.bgColor;
            preview.style.color = state.shareSettings.textColor;
            preview.style.fontFamily = state.shareSettings.fontFamily;
            document.getElementById('share-text').style.fontSize = state.shareSettings.fontSize + 'px';
        },
        
        async generateShareImage(download = false) {
            const preview = document.getElementById('share-image-preview');
            
            try {
                const canvas = await html2canvas(preview, {
                    backgroundColor: state.shareSettings.bgColor,
                    scale: 3, // High quality
                    useCORS: true,
                    logging: false
                });
                
                canvas.toBlob(blob => {
                    if (download) {
                        // Download only
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `ayah_${Date.now()}.png`;
                        a.click();
                        URL.revokeObjectURL(url);
                        this.showToast('ÿ™ŸÖ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿµŸàÿ±ÿ© ÿ®ŸÜÿ¨ÿßÿ≠', 'success');
                    } else {
                        // Share
                        const file = new File([blob], 'ayah.png', { type: 'image/png' });
                        
                        if (navigator.share && navigator.canShare({ files: [file] })) {
                            navigator.share({
                                files: [file],
                                title: 'ÿ¢Ÿäÿ© ŸÖŸÜ ÿßŸÑŸÇÿ±ÿ¢ŸÜ ÿßŸÑŸÉÿ±ŸäŸÖ'
                            });
                        } else {
                            // Fallback to download
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `ayah_${Date.now()}.png`;
                            a.click();
                            URL.revokeObjectURL(url);
                            this.showToast('ÿ™ŸÖ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿµŸàÿ±ÿ©', 'success');
                        }
                    }
                }, 'image/png', 1.0); // Maximum quality
            } catch (error) {
                console.error('Error generating image:', error);
                this.showToast('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿµŸàÿ±ÿ©', 'error');
            }
        },
        
        initAI() {
            const suggestions = [
                "ŸÖÿß ŸÖÿπŸÜŸâ ÿßŸÑÿ™ŸÇŸàŸâÿü",
                "ÿßÿ∞Ÿáÿ® ÿ•ŸÑŸâ ÿ≥Ÿàÿ±ÿ© ÿßŸÑÿ®ŸÇÿ±ÿ©",
                "ŸÅÿ≥ÿ± ÿ¢Ÿäÿ© ÿßŸÑŸÉÿ±ÿ≥Ÿä",
                "ÿ£ÿ≠ŸÉÿßŸÖ ÿßŸÑÿ™ÿ¨ŸàŸäÿØ"
            ];
            
            const suggestionsEl = document.getElementById('ai-suggestions');
            suggestions.forEach(text => {
                const chip = document.createElement('button');
                chip.className = 'px-3 py-1 bg-white/20 rounded-full text-xs whitespace-nowrap';
                chip.textContent = text;
                chip.onclick = () => this.sendAIMessage(text);
                suggestionsEl.appendChild(chip);
            });
        },
        
        async sendAIMessage(text) {
            if (!text.trim()) return;
            
            this.addAIMessage(text, 'user');
            document.getElementById('ai-input').value = '';
            
            // Check for navigation commands
            if (text.includes('ÿßÿ∞Ÿáÿ® ÿ•ŸÑŸâ ÿ≥Ÿàÿ±ÿ©')) {
                const surahName = text.replace('ÿßÿ∞Ÿáÿ® ÿ•ŸÑŸâ ÿ≥Ÿàÿ±ÿ©', '').trim();
                const surah = state.surahs.find(s => s.name_arabic.includes(surahName));
                if (surah) {
                    const surahPages = [1, 2, 50, 77, 106, 128, 151, 177, 187, 208, 221, 235, 249, 255, 262, 267, 282, 293, 305, 312, 322, 332, 342, 350, 359, 367, 377, 385, 396, 404, 411, 415, 418, 428, 434, 440, 446, 453, 458, 467, 477, 483, 489, 496, 499, 502, 507, 511, 515, 518, 520, 523, 526, 528, 531, 534, 537, 542, 545, 549, 551, 553, 554, 556, 558, 560, 562, 564, 566, 568, 570, 572, 574, 575, 577, 578, 580, 582, 583, 585, 586, 587, 587, 589, 590, 591, 591, 592, 593, 594, 595, 595, 596, 596, 597, 597, 598, 598, 599, 599, 600, 600, 601, 601, 601, 602, 602, 602, 603, 603, 603, 604, 604, 604];
                    const pageToLoad = surahPages[surah.id - 1] || 1;
                    this.loadPage(pageToLoad);
                    this.addAIMessage(`ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™ŸÇÿßŸÑ ÿ•ŸÑŸâ ${surah.name_arabic}`, 'ai');
                    return;
                }
            }
            
            // Regular AI response
            try {
                const response = await fetch(`${CONFIG.GEMINI_API_URL}?key=${CONFIG.GEMINI_API_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: `ÿ£ŸÜÿ™ ÿπÿ®ÿØ ÿßŸÑÿ≠ŸÉŸäŸÖÿå ŸÖÿ≥ÿßÿπÿØ ÿ∞ŸÉŸä ŸÑŸÑŸÇÿ±ÿ¢ŸÜ. ÿ£ÿ¨ÿ® ÿ®ÿ•Ÿäÿ¨ÿßÿ≤: ${text}` }] }],
                        generationConfig: { temperature: 0.7, maxOutputTokens: 200 }
                    })
                });
                
                const data = await response.json();
                const aiResponse = data.candidates[0].content.parts[0].text;
                this.addAIMessage(aiResponse, 'ai');
            } catch (error) {
                console.error('AI error:', error);
                this.addAIMessage('ÿπÿ∞ÿ±ÿßŸãÿå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.', 'ai');
            }
        },
        
        addAIMessage(text, sender) {
            const messagesEl = document.getElementById('ai-messages');
            const msgEl = document.createElement('div');
            msgEl.className = `flex gap-3 mb-4 ${sender === 'user' ? 'flex-row-reverse' : ''}`;
            
            const iconBg = sender === 'user' ? 'from-blue-500 to-blue-600' : 'from-emerald-500 to-emerald-600';
            const icon = sender === 'user' ? 'fa-user' : 'fa-robot';
            const bubbleBg = sender === 'user' ? 
                'bg-gradient-to-l from-blue-50 to-blue-100 dark:from-blue-900/20 dark:to-blue-800/20' : 
                'bg-gradient-to-l from-emerald-50 to-emerald-100 dark:from-emerald-900/20 dark:to-emerald-800/20';
            
            msgEl.innerHTML = `
                <div class="w-8 h-8 bg-gradient-to-br ${iconBg} rounded-full flex items-center justify-center flex-shrink-0">
                    <i class="fas ${icon} text-white text-xs"></i>
                </div>
                <div class="${bubbleBg} p-3 rounded-2xl max-w-[80%]">
                    <p class="text-sm">${text}</p>
                </div>
            `;
            
            messagesEl.appendChild(msgEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        },
        
        showToast(message, type = 'info') {
            const toast = document.createElement('div');
            const bgColor = type === 'error' ? 'from-red-500 to-red-600' : 
                           type === 'success' ? 'from-green-500 to-green-600' : 
                           'from-blue-500 to-blue-600';
            
            toast.className = `fixed top-20 left-1/2 -translate-x-1/2 bg-gradient-to-r ${bgColor} text-white px-4 py-2 rounded-lg shadow-lg z-[200] animate-slideDown`;
            toast.innerHTML = `<i class="fas fa-${type === 'error' ? 'exclamation-circle' : 'check-circle'} ml-2"></i>${message}`;
            
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        },
        
        showError() {
            const loadingScreen = document.getElementById('loading-screen');
            const pageContent = document.getElementById('page-content');
            
            const errorContent = `
                <div class="text-center">
                    <i class="fas fa-exclamation-triangle text-4xl text-red-500 mb-4"></i>
                    <p class="text-lg">ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ</p>
                    <button onclick="location.reload()" class="btn btn-primary mt-4">
                        <i class="fas fa-redo"></i> ÿ•ÿπÿßÿØÿ© ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ©
                    </button>
                </div>
            `;
            
            if (loadingScreen) {
                loadingScreen.innerHTML = errorContent;
            } else if (pageContent) {
                pageContent.innerHTML = errorContent;
            }
        },
        
        openPanel(panelId) {
            const panel = document.getElementById(panelId);
            if (panel) {
                panel.classList.add('visible');
                
                document.querySelectorAll('.nav-item').forEach(item => {
                    item.classList.toggle('active', item.dataset.panel === panelId);
                });
                
                if (panelId === 'bookmarks-panel') {
                    this.renderBookmarks();
                } else if (panelId === 'khatmah-panel') {
                    this.updateKhatmahsDisplay();
                }
            }
        },
        
        closePanel(panelId) {
            const panel = document.getElementById(panelId);
            if (panel) {
                panel.classList.remove('visible');
                
                document.querySelectorAll('.nav-item').forEach(item => {
                    item.classList.toggle('active', item.dataset.panel === 'home');
                });
            }
        },
        
        initEventListeners() {
            // Menu button
            document.getElementById('menu-btn').addEventListener('click', () => {
                this.openPanel('menu-panel');
            });
            
            // Swipe handling - ŸÖÿ≠ÿ≥ŸÜ ŸÑŸÑŸÉŸÖÿ®ŸäŸàÿ™ÿ± ÿ£Ÿäÿ∂ÿßŸã
            let touchStartX = 0;
            let touchStartY = 0;
            
            const mainContent = document.getElementById('main-content');
            
            // Touch support
            mainContent.addEventListener('touchstart', e => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            });
            
            // Add swipe support for memorization interface content too
            const memorizationContent = document.getElementById('memorization-content');
            if (memorizationContent) {
                memorizationContent.addEventListener('touchstart', e => {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                });
                
                memorizationContent.addEventListener('touchend', e => {
                    const touchEndX = e.changedTouches[0].clientX;
                    const touchEndY = e.changedTouches[0].clientY;
                    const diffX = touchEndX - touchStartX;
                    const diffY = Math.abs(touchEndY - touchStartY);
                    
                    if (Math.abs(diffX) > 50 && diffY < 100) {
                        if (diffX > 0 && state.currentPage > 1) {
                            this.navigatePageInMemorization(-1);
                        } else if (diffX < 0 && state.currentPage < CONFIG.TOTAL_PAGES) {
                            this.navigatePageInMemorization(1);
                        }
                    }
                });
            }
            
            mainContent.addEventListener('touchend', e => {
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                const diffX = touchEndX - touchStartX;
                const diffY = Math.abs(touchEndY - touchStartY);
                
                if (Math.abs(diffX) > 50 && diffY < 100) {
                    if (diffX > 0 && state.currentPage > 1) {
                        const rightHint = document.querySelector('.swipe-hint.right');
                        if (rightHint) {
                            rightHint.classList.add('show');
                            setTimeout(() => rightHint.classList.remove('show'), 300);
                        }
                        if (state.memorizationMode) {
                            this.navigatePageInMemorization(-1);
                        } else {
                            this.loadPage(state.currentPage - 1);
                        }
                    } else if (diffX < 0 && state.currentPage < CONFIG.TOTAL_PAGES) {
                        const leftHint = document.querySelector('.swipe-hint.left');
                        if (leftHint) {
                            leftHint.classList.add('show');
                            setTimeout(() => leftHint.classList.remove('show'), 300);
                        }
                        if (state.memorizationMode) {
                            this.navigatePageInMemorization(1);
                        } else {
                            this.loadPage(state.currentPage + 1);
                        }
                    }
                }
            });
            
            // Keyboard navigation for desktop
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft' && state.currentPage < CONFIG.TOTAL_PAGES) {
                    if (state.memorizationMode) {
                        this.navigatePageInMemorization(1);
                    } else {
                        this.loadPage(state.currentPage + 1);
                    }
                } else if (e.key === 'ArrowRight' && state.currentPage > 1) {
                    if (state.memorizationMode) {
                        this.navigatePageInMemorization(-1);
                    } else {
                        this.loadPage(state.currentPage - 1);
                    }
                }
            });
            
            // Ayah click
            document.getElementById('page-content').addEventListener('click', e => {
                const ayah = e.target.closest('.ayah');
                if (ayah && !state.memorizationMode) {
                    state.selectedAyah = {
                        key: ayah.dataset.verseKey,
                        text: ayah.dataset.text
                    };
                    
                    const [surahId, ayahNum] = ayah.dataset.verseKey.split(':');
                    const surah = state.surahs.find(s => s.id == surahId);
                    
                    document.getElementById('selected-ayah').textContent = ayah.dataset.text;
                    document.getElementById('selected-info').textContent = `ÿ≥Ÿàÿ±ÿ© ${surah?.name_arabic || ''} - ÿ¢Ÿäÿ© ${ayahNum}`;
                    
                    // Update bookmark button
                    const isBookmarked = state.bookmarks.some(b => b.verseKey === ayah.dataset.verseKey);
                    document.getElementById('ayah-bookmark').querySelector('span').textContent = isBookmarked ? 'ÿ•ÿ≤ÿßŸÑÿ©' : 'ÿ≠ŸÅÿ∏';
                    
                    const menu = document.getElementById('ayah-menu');
                    const backdrop = document.getElementById('ayah-menu-backdrop');
                    
                    menu.classList.remove('hidden');
                    backdrop.classList.remove('hidden');
                    setTimeout(() => {
                        menu.style.transform = 'translateY(0)';
                    }, 10);
                }
            });
            
            // Close ayah menu
            document.getElementById('ayah-menu-backdrop').addEventListener('click', () => {
                const menu = document.getElementById('ayah-menu');
                const backdrop = document.getElementById('ayah-menu-backdrop');
                
                menu.style.transform = 'translateY(100%)';
                setTimeout(() => {
                    menu.classList.add('hidden');
                    backdrop.classList.add('hidden');
                }, 300);
            });
            
            // Bottom nav
            document.querySelectorAll('.nav-item').forEach(item => {
                item.addEventListener('click', () => {
                    const panel = item.dataset.panel;
                    if (panel === 'home') {
                        document.querySelectorAll('.panel').forEach(p => p.classList.remove('visible'));
                        document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
                        item.classList.add('active');
                    } else {
                        this.openPanel(panel);
                    }
                });
            });
            
            // Search button
            document.getElementById('search-btn').addEventListener('click', () => {
                this.openPanel('search-panel');
            });
            
            // Close panels
            document.querySelectorAll('.close-panel').forEach(btn => {
                btn.addEventListener('click', () => {
                    const panel = btn.closest('.panel');
                    this.closePanel(panel.id);
                });
            });
            
            // AI
            document.querySelector('.ai-fab').addEventListener('click', () => {
                document.querySelector('.ai-window').classList.toggle('active');
            });
            
            document.getElementById('close-ai').addEventListener('click', () => {
                document.querySelector('.ai-window').classList.remove('active');
            });
            
            document.getElementById('ai-send').addEventListener('click', () => {
                const input = document.getElementById('ai-input');
                this.sendAIMessage(input.value);
            });
            
            document.getElementById('ai-input').addEventListener('keypress', e => {
                if (e.key === 'Enter') {
                    this.sendAIMessage(e.target.value);
                }
            });
            
            // Audio
            const audioEl = document.getElementById('page-audio');
            const playBtn = document.getElementById('audio-play-btn');
            const playIcon = document.getElementById('play-icon');
            const pauseIcon = document.getElementById('pause-icon');
            
            playBtn.addEventListener('click', () => {
                if (audioEl.paused && state.audioQueue.length > 0) {
                    audioEl.play();
                    this.highlightPlayingAyah();
                } else {
                    audioEl.pause();
                }
            });
            
            // Next/Previous audio buttons
            document.getElementById('audio-next-btn').addEventListener('click', () => {
                this.playNextAyah();
            });
            
            document.getElementById('audio-prev-btn').addEventListener('click', () => {
                this.playPreviousAyah();
            });
            
            audioEl.addEventListener('play', () => {
                playIcon.classList.add('hidden');
                pauseIcon.classList.remove('hidden');
            });
            
            audioEl.addEventListener('pause', () => {
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
            });
            
            audioEl.addEventListener('ended', () => {
                this.playNextAyah();
            });
            
            audioEl.addEventListener('timeupdate', () => {
                const progress = (audioEl.currentTime / audioEl.duration) * 100;
                document.getElementById('audio-progress').style.width = `${progress}%`;
            });
            
            // Progress bar click
            document.getElementById('audio-progress-bar').addEventListener('click', (e) => {
                if (audioEl.duration) {
                    const rect = e.currentTarget.getBoundingClientRect();
                    const percent = (e.clientX - rect.left) / rect.width;
                    audioEl.currentTime = percent * audioEl.duration;
                }
            });
            
            // Settings
            document.querySelectorAll('.theme-option').forEach(btn => {
                btn.addEventListener('click', () => {
                    state.currentTheme = btn.dataset.theme;
                    localStorage.setItem('theme', state.currentTheme);
                    document.body.setAttribute('data-theme', state.currentTheme);
                    
                    document.querySelectorAll('.theme-option').forEach(b => {
                        b.style.borderColor = 'var(--border)';
                        b.style.background = 'transparent';
                    });
                    btn.style.borderColor = 'var(--primary)';
                    btn.style.background = 'var(--bg-tertiary)';
                });
            });
            
            // Apply current theme selection on load
            const currentThemeBtn = document.querySelector(`.theme-option[data-theme="${state.currentTheme}"]`);
            if (currentThemeBtn) {
                currentThemeBtn.style.borderColor = 'var(--primary)';
                currentThemeBtn.style.background = 'var(--bg-tertiary)';
            }
            
            // Font size
            document.getElementById('font-size').addEventListener('input', (e) => {
                state.fontSize = parseInt(e.target.value);
                localStorage.setItem('fontSize', state.fontSize);
                document.getElementById('font-size-value').textContent = state.fontSize + 'px';
                document.getElementById('page-content').style.fontSize = state.fontSize + 'px';
            });
            
            // Font type
            document.getElementById('font-type').addEventListener('change', (e) => {
                state.fontType = e.target.value;
                localStorage.setItem('fontType', state.fontType);
                document.getElementById('page-content').className = state.fontType + ' text-xl leading-loose';
            });
            
            // Reciter
            document.getElementById('reciter-select').addEventListener('change', (e) => {
                state.selectedReciter = parseInt(e.target.value);
                localStorage.setItem('selectedReciter', state.selectedReciter);
                this.loadPage(state.currentPage);
            });
            
            // Tafsir
            document.getElementById('tafsir-select').addEventListener('change', (e) => {
                state.selectedTafsir = parseInt(e.target.value);
                localStorage.setItem('selectedTafsir', state.selectedTafsir);
                this.loadPage(state.currentPage);
            });
            
            // Translation
            document.getElementById('translation-select').addEventListener('change', (e) => {
                state.selectedTranslation = parseInt(e.target.value);
                localStorage.setItem('selectedTranslation', state.selectedTranslation);
                this.loadPage(state.currentPage);
            });
            
            // Search
            let searchTimeout;
            document.getElementById('search-input').addEventListener('input', (e) => {
                clearTimeout(searchTimeout);
                const query = e.target.value.trim();
                
                if (query.length > 2) {
                    searchTimeout = setTimeout(() => {
                        this.searchQuran(query);
                    }, 500);
                } else if (query.length === 0) {
                    document.getElementById('search-results').innerHTML = '';
                }
            });
            
            // Surah search
            document.getElementById('surah-search').addEventListener('input', (e) => {
                const query = e.target.value.toLowerCase();
                const items = document.querySelectorAll('#surah-list .card');
                
                items.forEach(item => {
                    const text = item.textContent.toLowerCase();
                    item.style.display = text.includes(query) ? 'block' : 'none';
                });
            });
            
            // Ayah context menu actions
            document.getElementById('ayah-play').addEventListener('click', async () => {
                if (state.selectedAyah) {
                    try {
                        const verseData = await API.getVerseByKey(state.selectedAyah.key);
                        if (verseData.audio?.url) {
                            const ayahAudio = document.getElementById('ayah-audio');
                            ayahAudio.src = CONFIG.AUDIO_BASE + verseData.audio.url;
                            ayahAudio.play();
                        }
                    } catch (error) {
                        console.error('Error playing ayah:', error);
                    }
                }
                
                document.getElementById('ayah-menu-backdrop').click();
            });
            
            document.getElementById('ayah-tafsir').addEventListener('click', async () => {
                if (state.selectedAyah) {
                    try {
                        const verseData = await API.getVerseByKey(state.selectedAyah.key);
                        const tafsirContent = document.getElementById('tafsir-content');
                        
                        // Get tafsir and translation texts
                        const tafsirText = verseData.tafsirs && verseData.tafsirs.length > 0 ? 
                            verseData.tafsirs[0].text.replace(/<[^>]*>/g, '') : 
                            'ÿßŸÑÿ™ŸÅÿ≥Ÿäÿ± ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÅÿ±';
                        
                        const translationText = verseData.translations && verseData.translations.length > 0 ? 
                            verseData.translations[0].text : 
                            'ÿßŸÑÿ™ÿ±ÿ¨ŸÖÿ© ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÅÿ±ÿ©';
                        
                        tafsirContent.innerHTML = `
                            <div class="mb-4">
                                <h4 class="font-bold mb-2">ÿßŸÑÿ¢Ÿäÿ©:</h4>
                                <p class="font-arabic text-xl">${verseData.text_uthmani || state.selectedAyah.text}</p>
                            </div>
                            <div class="mb-4">
                                <h4 class="font-bold mb-2">ÿßŸÑÿ™ŸÅÿ≥Ÿäÿ±:</h4>
                                <p>${tafsirText}</p>
                            </div>
                            <div>
                                <h4 class="font-bold mb-2">ÿßŸÑÿ™ÿ±ÿ¨ŸÖÿ©:</h4>
                                <p>${translationText}</p>
                            </div>
                        `;
                        
                        document.getElementById('tafsir-popup').style.display = 'flex';
                    } catch (error) {
                        console.error('Error loading tafsir:', error);
                        this.showToast('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ™ŸÅÿ≥Ÿäÿ±', 'error');
                    }
                }
                
                document.getElementById('ayah-menu-backdrop').click();
            });
            
            document.getElementById('close-tafsir').addEventListener('click', () => {
                document.getElementById('tafsir-popup').style.display = 'none';
            });
            
            document.getElementById('ayah-bookmark').addEventListener('click', () => {
                if (state.selectedAyah) {
                    this.toggleBookmark(state.selectedAyah.key, state.selectedAyah.text);
                }
                
                document.getElementById('ayah-menu-backdrop').click();
            });
            
            document.getElementById('ayah-share').addEventListener('click', () => {
                const modal = document.getElementById('share-options-modal');
                modal.classList.add('active');
                document.getElementById('ayah-menu-backdrop').click();
            });
            
            document.getElementById('ayah-copy').addEventListener('click', () => {
                if (state.selectedAyah) {
                    navigator.clipboard.writeText(state.selectedAyah.text);
                    this.showToast('ÿ™ŸÖ ŸÜÿ≥ÿÆ ÿßŸÑÿ¢Ÿäÿ©', 'success');
                }
                
                document.getElementById('ayah-menu-backdrop').click();
            });
            
            document.getElementById('ayah-ai').addEventListener('click', () => {
                if (state.selectedAyah) {
                    document.querySelector('.ai-window').classList.add('active');
                    document.getElementById('ai-input').value = `ÿßÿ¥ÿ±ÿ≠ Ÿáÿ∞Ÿá ÿßŸÑÿ¢Ÿäÿ©: ${state.selectedAyah.text}`;
                }
                
                document.getElementById('ayah-menu-backdrop').click();
            });
            
            // Share modal
            document.getElementById('share-as-text').addEventListener('click', () => {
                this.shareAsText();
                document.getElementById('share-options-modal').classList.remove('active');
            });
            
            document.getElementById('share-as-image-btn').addEventListener('click', () => {
                this.prepareShareImage();
                document.getElementById('share-options-modal').classList.remove('active');
            });
            
            document.getElementById('close-share-modal').addEventListener('click', () => {
                document.getElementById('share-options-modal').classList.remove('active');
            });
            
            // Share image customization
            document.getElementById('share-font-size').addEventListener('input', (e) => {
                state.shareSettings.fontSize = parseInt(e.target.value);
                document.getElementById('share-font-size-value').textContent = state.shareSettings.fontSize + 'px';
                this.updateSharePreview();
            });
            
            document.querySelectorAll('.share-bg-color').forEach(btn => {
                btn.addEventListener('click', () => {
                    state.shareSettings.bgColor = btn.dataset.color;
                    document.querySelectorAll('.share-bg-color').forEach(b => b.style.borderColor = 'transparent');
                    btn.style.borderColor = 'var(--primary)';
                    this.updateSharePreview();
                });
            });
            
            document.querySelectorAll('.share-text-color').forEach(btn => {
                btn.addEventListener('click', () => {
                    state.shareSettings.textColor = btn.dataset.color;
                    document.querySelectorAll('.share-text-color').forEach(b => b.style.borderColor = 'transparent');
                    btn.style.borderColor = 'var(--primary)';
                    this.updateSharePreview();
                });
            });
            
            document.getElementById('share-font-type').addEventListener('change', (e) => {
                state.shareSettings.fontFamily = e.target.value;
                this.updateSharePreview();
            });
            
            // Share and Download buttons
            document.getElementById('generate-share-image').addEventListener('click', () => {
                this.generateShareImage(false); // Share
            });
            
            document.getElementById('download-share-image').addEventListener('click', () => {
                this.generateShareImage(true); // Download only
            });
            
            // Khatmah
            document.getElementById('create-khatmah').addEventListener('click', () => {
                this.createKhatmah();
            });
            
            // Khatmah analytics modal
            document.getElementById('close-analytics').addEventListener('click', () => {
                document.getElementById('khatmah-analytics-modal').classList.remove('active');
            });
            
            // Close modal on outside click
            document.getElementById('khatmah-analytics-modal').addEventListener('click', (e) => {
                if (e.target === e.currentTarget) {
                    e.currentTarget.classList.remove('active');
                }
            });
            
            // Memorization Interface Event Listeners  
            document.getElementById('back-to-main')?.addEventListener('click', () => {
                this.exitMemorizationInterface();
            });
            
            document.getElementById('memorization-show-verse-header')?.addEventListener('click', () => {
                this.showVerse();
            });
            
            document.getElementById('memorization-hint-header')?.addEventListener('click', () => {
                this.giveHint();
            });
            
            document.getElementById('memorization-play-audio-header')?.addEventListener('click', () => {
                this.playMemorizationAudio();
            });
            
            document.getElementById('memorization-skip-word-footer')?.addEventListener('click', () => {
                this.skipWord();
            });
            
            document.getElementById('memorization-reset-footer')?.addEventListener('click', () => {
                this.resetMemorization();
            });
            
            document.getElementById('stop-memorization')?.addEventListener('click', () => {
                this.stopMemorizationMode();
            });
            document.getElementById('start-verse-memorization')?.addEventListener('click', () => {
                this.startMemorizationMode('ayah');
            });
            
            document.getElementById('start-page-memorization')?.addEventListener('click', () => {
                this.startMemorizationMode('page');
            });
            
            document.getElementById('start-surah-memorization')?.addEventListener('click', () => {
                this.startMemorizationMode('surah');
            });
            
            document.getElementById('start-custom-memorization')?.addEventListener('click', () => {
                this.startMemorizationMode('custom');
            });
            
            // Memorization Control Buttons
            document.getElementById('memorization-show-verse')?.addEventListener('click', () => {
                this.showVerse();
            });
            
            document.getElementById('memorization-hint')?.addEventListener('click', () => {
                this.giveHint();
            });
            
            document.getElementById('memorization-skip-word')?.addEventListener('click', () => {
                this.skipWord();
            });
            
            document.getElementById('memorization-play-audio')?.addEventListener('click', () => {
                this.playMemorizationAudio();
            });
            
            document.getElementById('memorization-reset')?.addEventListener('click', () => {
                this.resetMemorization();
            });
            
            // Memorization Settings
            document.getElementById('memorization-sound-alerts')?.addEventListener('change', (e) => {
                state.memorizationSettings.soundAlerts = e.target.checked;
            });
            
            document.getElementById('memorization-show-tashkeel')?.addEventListener('change', (e) => {
                state.memorizationSettings.showTashkeel = e.target.checked;
            });
            
            document.getElementById('memorization-auto-repeat')?.addEventListener('change', (e) => {
                state.memorizationSettings.autoRepeat = e.target.checked;
            });
            
            document.getElementById('memorization-sensitivity')?.addEventListener('input', (e) => {
                state.memorizationSettings.sensitivity = parseFloat(e.target.value);
                const percentage = Math.round(state.memorizationSettings.sensitivity * 100);
                document.getElementById('memorization-sensitivity-value').textContent = percentage + '%';
            });
        }
    };
    
    // ================================================================
    // ==   ÿßŸÑŸÉŸàÿØ ÿßŸÑÿ¨ÿØŸäÿØ ŸàÿßŸÑŸÜŸáÿßÿ¶Ÿä ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ AssemblyAI - ÿ£ŸÉÿ´ÿ± ÿ≥ŸáŸàŸÑÿ© ŸàŸÇŸàÿ©  ==
    // ================================================================
    
    // ŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿ≠ÿßŸÑÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑ ŸàÿßŸÑŸÖŸäŸÉÿ±ŸàŸÅŸàŸÜ ÿÆÿßÿ±ÿ¨ ŸÉÿßÿ¶ŸÜ App
    let assemblyAiSocket;
    let recorder;
    
    // ÿØÿßŸÑÿ© ÿ®ÿØÿ° ÿßŸÑÿßÿ≥ÿ™ŸÖÿßÿπ ÿßŸÑÿ¨ÿØŸäÿØÿ©
    async function startAssemblyAiStreaming() {
        console.log('üöÄ Starting AssemblyAI audio streaming...');
    
        try {
            // ÿ∑ŸÑÿ® ÿ™ŸÅÿπŸäŸÑ ÿßŸÑŸÖŸäŸÉÿ±ŸàŸÅŸàŸÜ
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    
            // ÿ•ÿπÿØÿßÿØ ŸÖÿ≥ÿ¨ŸÑ ÿßŸÑÿµŸàÿ™
            recorder = new MediaRecorder(stream);
    
            // ŸÖŸÅÿ™ÿßÿ≠ ÿßŸÑŸÄ API
            const ASSEMBLYAI_API_KEY = '036ced8e18894eaba5d519152132d98c';
    
            // ÿ±ÿßÿ®ÿ∑ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿßŸÑÿÆÿØŸÖÿ©
            const url = `wss://api.assemblyai.com/v2/realtime/ws?sample_rate=16000&token=${ASSEMBLYAI_API_KEY}`;
    
            // ÿ•ŸÜÿ¥ÿßÿ° ÿßÿ™ÿµÿßŸÑ WebSocket
            assemblyAiSocket = new WebSocket(url);
    
            // ÿπŸÜÿØ ŸÅÿ™ÿ≠ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ŸÜÿ¨ÿßÿ≠
            assemblyAiSocket.onopen = () => {
                console.log('‚úÖ Connected to AssemblyAI WebSocket');
                App.showToast('üé§ ÿßŸÑÿßÿ≥ÿ™ŸÖÿßÿπ ŸÅÿπÿßŸÑ ÿßŸÑÿ¢ŸÜ', 'success');
    
                recorder.addEventListener('dataavailable', async (event) => {
                    if (event.data.size > 0 && assemblyAiSocket.readyState === WebSocket.OPEN) {
                        const audio_data = await event.data.arrayBuffer();
                        const base64_data = btoa(String.fromCharCode.apply(null, new Uint8Array(audio_data)));
                        assemblyAiSocket.send(JSON.stringify({ audio_data: base64_data }));
                    }
                });
    
                // ÿ®ÿØÿ° ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿµŸàÿ™ Ÿàÿ•ÿ±ÿ≥ÿßŸÑŸá ŸÉŸÑ 500 ŸÖŸäŸÑŸä ÿ´ÿßŸÜŸäÿ©
                recorder.start(500);
            };
    
            // ÿπŸÜÿØ ÿßÿ≥ÿ™ŸÇÿ®ÿßŸÑ ŸÜÿµ ŸÖŸÜ ÿßŸÑÿÆÿØŸÖÿ©
            assemblyAiSocket.onmessage = (message) => {
                const result = JSON.parse(message.data);
                // ŸÜÿ≠ŸÜ ŸÜŸáÿ™ŸÖ ŸÅŸÇÿ∑ ÿ®ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨ ÿßŸÑŸÜŸáÿßÿ¶Ÿäÿ© ŸÑÿ∂ŸÖÿßŸÜ ÿßŸÑÿØŸÇÿ©
                if (result.text && result.message_type === 'FinalTranscript') {
                    console.log("API Response:", result.text);
                    // ÿßÿ≥ÿ™ÿØÿπÿßÿ° ÿØÿßŸÑÿ© ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÜÿµ ÿßŸÑŸÖŸàÿ¨ŸàÿØÿ© ŸÅŸä ÿ™ÿ∑ÿ®ŸäŸÇŸÉ
                    App.processSequentialText(result.text, 1.0, performance.now());
                }
            };
    
            // ÿπŸÜÿØ ÿ≠ÿØŸàÿ´ ÿÆÿ∑ÿ£
            assemblyAiSocket.onerror = (event) => {
                console.error('WebSocket Error:', event);
                App.showToast('ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿÆÿØŸÖÿ© ÿßŸÑÿµŸàÿ™', 'error');
            };
    
            // ÿπŸÜÿØ ÿ•ÿ∫ŸÑÿßŸÇ ÿßŸÑÿßÿ™ÿµÿßŸÑ
            assemblyAiSocket.onclose = event => {
                console.log('WebSocket Closed:', event);
                // ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ•ŸäŸÇÿßŸÅ ÿßŸÑŸÖŸäŸÉÿ±ŸàŸÅŸàŸÜ ÿ™ŸÖÿßŸÖÿßŸã
                if (recorder && recorder.state === 'recording') {
                    recorder.stream.getTracks().forEach(track => track.stop());
                }
            };
    
        } catch (error) {
            console.error('Error starting AssemblyAI streaming:', error);
            App.showToast('ÿÆÿ∑ÿ£: ŸÑŸÖ Ÿäÿ™ŸÖŸÉŸÜ ŸÖŸÜ ÿßŸÑŸàÿµŸàŸÑ ŸÑŸÑŸÖŸäŸÉÿ±ŸàŸÅŸàŸÜ', 'error');
        }
    }
    
    // ÿØÿßŸÑÿ© ÿ•ŸäŸÇÿßŸÅ ÿßŸÑÿßÿ≥ÿ™ŸÖÿßÿπ ÿßŸÑÿ¨ÿØŸäÿØÿ©
    function stopAssemblyAiStreaming() {
        if (recorder && recorder.state === 'recording') {
            recorder.stop();
        }
        if (assemblyAiSocket) {
            assemblyAiSocket.send(JSON.stringify({ terminate_session: true }));
            assemblyAiSocket.close();
            assemblyAiSocket = null;
        }
        console.log('üõë Stopped AssemblyAI audio streaming.');
        App.showToast('ÿ™ŸÖ ÿ•ŸäŸÇÿßŸÅ ÿßŸÑÿßÿ≥ÿ™ŸÖÿßÿπ', 'info');
    }
    
    // Make App globally accessible
    window.App = App;
    
    // Initialize app when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
        App.init();
    });
    
    // Service Worker Registration (PWA)
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('./sw.js').then(registration => {
                console.log('Service Worker registered:', registration);
            }).catch(error => {
                console.log('Service Worker registration failed:', error);
            });
        });
    }
    </script>
</body>
</html>
